{"ast":null,"code":"import _toConsumableArray from \"/Users/tbeckett/Documents/Azure dev/Azure Test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _defineProperty from \"/Users/tbeckett/Documents/Azure dev/Azure Test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _createForOfIteratorHelper from \"/Users/tbeckett/Documents/Azure dev/Azure Test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _asyncToGenerator from \"/Users/tbeckett/Documents/Azure dev/Azure Test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/tbeckett/Documents/Azure dev/Azure Test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/tbeckett/Documents/Azure dev/Azure Test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport * as utils from \"./util/utils\";\nimport { MapperType } from \"./serializer\";\nimport { DefaultDeserializationOptions, deserializationPolicy } from \"./policies/deserializationPolicy\";\nimport { DefaultKeepAliveOptions, keepAlivePolicy } from \"./policies/keepAlivePolicy\";\nimport { DefaultRedirectOptions, redirectPolicy } from \"./policies/redirectPolicy\";\nimport { DefaultRetryOptions, exponentialRetryPolicy } from \"./policies/exponentialRetryPolicy\";\nimport { logPolicy } from \"./policies/logPolicy\";\nimport { getPathStringFromParameter, getPathStringFromParameterPath } from \"./operationParameter\";\nimport { getStreamResponseStatusCodes } from \"./operationSpec\";\nimport { WebResource, isWebResourceLike } from \"./webResource\";\nimport { RequestPolicyOptions } from \"./policies/requestPolicy\";\nimport { XML_ATTRKEY, XML_CHARKEY } from \"./util/serializer.common\";\nimport { isNode } from \"./util/utils\";\nimport { isTokenCredential } from \"@azure/core-auth\";\nimport { getDefaultUserAgentHeaderName, getDefaultUserAgentValue, userAgentPolicy } from \"./policies/userAgentPolicy\";\nimport { QueryCollectionFormat } from \"./queryCollectionFormat\";\nimport { URLBuilder } from \"./url\";\nimport { bearerTokenAuthenticationPolicy } from \"./policies/bearerTokenAuthenticationPolicy\";\nimport { disableResponseDecompressionPolicy } from \"./policies/disableResponseDecompressionPolicy\";\nimport { generateClientRequestIdPolicy } from \"./policies/generateClientRequestIdPolicy\";\nimport { getCachedDefaultHttpClient } from \"./httpClientCache\";\nimport { logger } from \"./log\";\nimport { ndJsonPolicy } from \"./policies/ndJsonPolicy\";\nimport { proxyPolicy } from \"./policies/proxyPolicy\";\nimport { rpRegistrationPolicy } from \"./policies/rpRegistrationPolicy\";\nimport { signingPolicy } from \"./policies/signingPolicy\";\nimport { stringifyXML } from \"./util/xml\";\nimport { systemErrorRetryPolicy } from \"./policies/systemErrorRetryPolicy\";\nimport { throttlingRetryPolicy } from \"./policies/throttlingRetryPolicy\";\nimport { tracingPolicy } from \"./policies/tracingPolicy\";\n/**\n * ServiceClient sends service requests and receives responses.\n */\nexport var ServiceClient = /*#__PURE__*/function () {\n  /**\n   * The ServiceClient constructor\n   * @param credentials - The credentials used for authentication with the service.\n   * @param options - The service client options that govern the behavior of the client.\n   */\n  function ServiceClient(credentials, /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options */\n  options) {\n    var _this = this;\n    _classCallCheck(this, ServiceClient);\n    if (!options) {\n      options = {};\n    }\n    this._withCredentials = options.withCredentials || false;\n    this._httpClient = options.httpClient || getCachedDefaultHttpClient();\n    this._requestPolicyOptions = new RequestPolicyOptions(options.httpPipelineLogger);\n    var requestPolicyFactories;\n    if (Array.isArray(options.requestPolicyFactories)) {\n      logger.info(\"ServiceClient: using custom request policies\");\n      requestPolicyFactories = options.requestPolicyFactories;\n    } else {\n      var authPolicyFactory = undefined;\n      if (isTokenCredential(credentials)) {\n        logger.info(\"ServiceClient: creating bearer token authentication policy from provided credentials\");\n        // Create a wrapped RequestPolicyFactory here so that we can provide the\n        // correct scope to the BearerTokenAuthenticationPolicy at the first time\n        // one is requested.  This is needed because generated ServiceClient\n        // implementations do not set baseUri until after ServiceClient's constructor\n        // is finished, leaving baseUri empty at the time when it is needed to\n        // build the correct scope name.\n        var wrappedPolicyFactory = function wrappedPolicyFactory() {\n          var bearerTokenPolicyFactory = undefined;\n          // eslint-disable-next-line @typescript-eslint/no-this-alias\n          var serviceClient = _this;\n          var serviceClientOptions = options;\n          return {\n            create: function create(nextPolicy, createOptions) {\n              var credentialScopes = getCredentialScopes(serviceClientOptions, serviceClient.baseUri);\n              if (!credentialScopes) {\n                throw new Error(\"When using credential, the ServiceClient must contain a baseUri or a credentialScopes in ServiceClientOptions. Unable to create a bearerTokenAuthenticationPolicy\");\n              }\n              if (bearerTokenPolicyFactory === undefined || bearerTokenPolicyFactory === null) {\n                bearerTokenPolicyFactory = bearerTokenAuthenticationPolicy(credentials, credentialScopes);\n              }\n              return bearerTokenPolicyFactory.create(nextPolicy, createOptions);\n            }\n          };\n        };\n        authPolicyFactory = wrappedPolicyFactory();\n      } else if (credentials && typeof credentials.signRequest === \"function\") {\n        logger.info(\"ServiceClient: creating signing policy from provided credentials\");\n        authPolicyFactory = signingPolicy(credentials);\n      } else if (credentials !== undefined && credentials !== null) {\n        throw new Error(\"The credentials argument must implement the TokenCredential interface\");\n      }\n      logger.info(\"ServiceClient: using default request policies\");\n      requestPolicyFactories = createDefaultRequestPolicyFactories(authPolicyFactory, options);\n      if (options.requestPolicyFactories) {\n        // options.requestPolicyFactories can also be a function that manipulates\n        // the default requestPolicyFactories array\n        var newRequestPolicyFactories = options.requestPolicyFactories(requestPolicyFactories);\n        if (newRequestPolicyFactories) {\n          requestPolicyFactories = newRequestPolicyFactories;\n        }\n      }\n    }\n    this._requestPolicyFactories = requestPolicyFactories;\n  }\n  /**\n   * Send the provided httpRequest.\n   */\n  _createClass(ServiceClient, [{\n    key: \"sendRequest\",\n    value: function sendRequest(options) {\n      if (options === null || options === undefined || typeof options !== \"object\") {\n        throw new Error(\"options cannot be null or undefined and it must be of type object.\");\n      }\n      var httpRequest;\n      try {\n        if (isWebResourceLike(options)) {\n          options.validateRequestProperties();\n          httpRequest = options;\n        } else {\n          httpRequest = new WebResource();\n          httpRequest = httpRequest.prepare(options);\n        }\n      } catch (error) {\n        return Promise.reject(error);\n      }\n      var httpPipeline = this._httpClient;\n      if (this._requestPolicyFactories && this._requestPolicyFactories.length > 0) {\n        for (var i = this._requestPolicyFactories.length - 1; i >= 0; --i) {\n          httpPipeline = this._requestPolicyFactories[i].create(httpPipeline, this._requestPolicyOptions);\n        }\n      }\n      return httpPipeline.sendRequest(httpRequest);\n    }\n    /**\n     * Send an HTTP request that is populated using the provided OperationSpec.\n     * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.\n     * @param operationSpec - The OperationSpec to use to populate the httpRequest.\n     * @param callback - The callback to call when the response is received.\n     */\n  }, {\n    key: \"sendOperationRequest\",\n    value: function () {\n      var _sendOperationRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(operationArguments, operationSpec, callback) {\n        var _a, serializerOptions, httpRequest, result, baseUri, requestUrl, _iterator, _step, urlParameter, urlParameterValue, _iterator2, _step2, queryParameter, queryParameterValue, index, item, _index, contentType, _iterator3, _step3, headerParameter, headerValue, headerCollectionPrefix, _i, _Object$keys, key, options, customHeaderName, rawResponse, sendRequestError, cb;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (typeof operationArguments.options === \"function\") {\n                  callback = operationArguments.options;\n                  operationArguments.options = undefined;\n                }\n                serializerOptions = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions;\n                httpRequest = new WebResource();\n                _context.prev = 3;\n                baseUri = operationSpec.baseUrl || this.baseUri;\n                if (baseUri) {\n                  _context.next = 7;\n                  break;\n                }\n                throw new Error(\"If operationSpec.baseUrl is not specified, then the ServiceClient must have a baseUri string property that contains the base URL to use.\");\n              case 7:\n                httpRequest.method = operationSpec.httpMethod;\n                httpRequest.operationSpec = operationSpec;\n                requestUrl = URLBuilder.parse(baseUri);\n                if (operationSpec.path) {\n                  requestUrl.appendPath(operationSpec.path);\n                }\n                if (operationSpec.urlParameters && operationSpec.urlParameters.length > 0) {\n                  _iterator = _createForOfIteratorHelper(operationSpec.urlParameters);\n                  try {\n                    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                      urlParameter = _step.value;\n                      urlParameterValue = getOperationArgumentValueFromParameter(this, operationArguments, urlParameter, operationSpec.serializer);\n                      urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, getPathStringFromParameter(urlParameter), serializerOptions);\n                      if (!urlParameter.skipEncoding) {\n                        urlParameterValue = encodeURIComponent(urlParameterValue);\n                      }\n                      requestUrl.replaceAll(\"{\".concat(urlParameter.mapper.serializedName || getPathStringFromParameter(urlParameter), \"}\"), urlParameterValue);\n                    }\n                  } catch (err) {\n                    _iterator.e(err);\n                  } finally {\n                    _iterator.f();\n                  }\n                }\n                if (!(operationSpec.queryParameters && operationSpec.queryParameters.length > 0)) {\n                  _context.next = 44;\n                  break;\n                }\n                _iterator2 = _createForOfIteratorHelper(operationSpec.queryParameters);\n                _context.prev = 14;\n                _iterator2.s();\n              case 16:\n                if ((_step2 = _iterator2.n()).done) {\n                  _context.next = 36;\n                  break;\n                }\n                queryParameter = _step2.value;\n                queryParameterValue = getOperationArgumentValueFromParameter(this, operationArguments, queryParameter, operationSpec.serializer);\n                if (!(queryParameterValue !== undefined && queryParameterValue !== null)) {\n                  _context.next = 34;\n                  break;\n                }\n                queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, getPathStringFromParameter(queryParameter), serializerOptions);\n                if (!(queryParameter.collectionFormat !== undefined && queryParameter.collectionFormat !== null)) {\n                  _context.next = 31;\n                  break;\n                }\n                if (!(queryParameter.collectionFormat === QueryCollectionFormat.Multi)) {\n                  _context.next = 30;\n                  break;\n                }\n                if (!(queryParameterValue.length === 0)) {\n                  _context.next = 27;\n                  break;\n                }\n                return _context.abrupt(\"continue\", 34);\n              case 27:\n                for (index in queryParameterValue) {\n                  item = queryParameterValue[index];\n                  queryParameterValue[index] = item === undefined || item === null ? \"\" : item.toString();\n                }\n              case 28:\n                _context.next = 31;\n                break;\n              case 30:\n                if (queryParameter.collectionFormat === QueryCollectionFormat.Ssv || queryParameter.collectionFormat === QueryCollectionFormat.Tsv) {\n                  queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);\n                }\n              case 31:\n                if (!queryParameter.skipEncoding) {\n                  if (Array.isArray(queryParameterValue)) {\n                    for (_index in queryParameterValue) {\n                      if (queryParameterValue[_index] !== undefined && queryParameterValue[_index] !== null) {\n                        queryParameterValue[_index] = encodeURIComponent(queryParameterValue[_index]);\n                      }\n                    }\n                  } else {\n                    queryParameterValue = encodeURIComponent(queryParameterValue);\n                  }\n                }\n                if (queryParameter.collectionFormat !== undefined && queryParameter.collectionFormat !== null && queryParameter.collectionFormat !== QueryCollectionFormat.Multi && queryParameter.collectionFormat !== QueryCollectionFormat.Ssv && queryParameter.collectionFormat !== QueryCollectionFormat.Tsv) {\n                  queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);\n                }\n                requestUrl.setQueryParameter(queryParameter.mapper.serializedName || getPathStringFromParameter(queryParameter), queryParameterValue);\n              case 34:\n                _context.next = 16;\n                break;\n              case 36:\n                _context.next = 41;\n                break;\n              case 38:\n                _context.prev = 38;\n                _context.t0 = _context[\"catch\"](14);\n                _iterator2.e(_context.t0);\n              case 41:\n                _context.prev = 41;\n                _iterator2.f();\n                return _context.finish(41);\n              case 44:\n                httpRequest.url = requestUrl.toString();\n                contentType = operationSpec.contentType || this.requestContentType;\n                if (contentType && operationSpec.requestBody) {\n                  httpRequest.headers.set(\"Content-Type\", contentType);\n                }\n                if (operationSpec.headerParameters) {\n                  _iterator3 = _createForOfIteratorHelper(operationSpec.headerParameters);\n                  try {\n                    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                      headerParameter = _step3.value;\n                      headerValue = getOperationArgumentValueFromParameter(this, operationArguments, headerParameter, operationSpec.serializer);\n                      if (headerValue !== undefined && headerValue !== null) {\n                        headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, getPathStringFromParameter(headerParameter), serializerOptions);\n                        headerCollectionPrefix = headerParameter.mapper.headerCollectionPrefix;\n                        if (headerCollectionPrefix) {\n                          for (_i = 0, _Object$keys = Object.keys(headerValue); _i < _Object$keys.length; _i++) {\n                            key = _Object$keys[_i];\n                            httpRequest.headers.set(headerCollectionPrefix + key, headerValue[key]);\n                          }\n                        } else {\n                          httpRequest.headers.set(headerParameter.mapper.serializedName || getPathStringFromParameter(headerParameter), headerValue);\n                        }\n                      }\n                    }\n                  } catch (err) {\n                    _iterator3.e(err);\n                  } finally {\n                    _iterator3.f();\n                  }\n                }\n                options = operationArguments.options;\n                if (options) {\n                  if (options.customHeaders) {\n                    for (customHeaderName in options.customHeaders) {\n                      httpRequest.headers.set(customHeaderName, options.customHeaders[customHeaderName]);\n                    }\n                  }\n                  if (options.abortSignal) {\n                    httpRequest.abortSignal = options.abortSignal;\n                  }\n                  if (options.timeout) {\n                    httpRequest.timeout = options.timeout;\n                  }\n                  if (options.onUploadProgress) {\n                    httpRequest.onUploadProgress = options.onUploadProgress;\n                  }\n                  if (options.onDownloadProgress) {\n                    httpRequest.onDownloadProgress = options.onDownloadProgress;\n                  }\n                  if (options.spanOptions) {\n                    // By passing spanOptions if they exist at runtime, we're backwards compatible with @azure/core-tracing@preview.13 and earlier.\n                    httpRequest.spanOptions = options.spanOptions;\n                  }\n                  if (options.tracingContext) {\n                    httpRequest.tracingContext = options.tracingContext;\n                  }\n                  if (options.shouldDeserialize !== undefined && options.shouldDeserialize !== null) {\n                    httpRequest.shouldDeserialize = options.shouldDeserialize;\n                  }\n                }\n                httpRequest.withCredentials = this._withCredentials;\n                serializeRequestBody(this, httpRequest, operationArguments, operationSpec);\n                if (httpRequest.streamResponseStatusCodes === undefined) {\n                  httpRequest.streamResponseStatusCodes = getStreamResponseStatusCodes(operationSpec);\n                }\n                _context.prev = 53;\n                _context.next = 56;\n                return this.sendRequest(httpRequest);\n              case 56:\n                rawResponse = _context.sent;\n                _context.next = 62;\n                break;\n              case 59:\n                _context.prev = 59;\n                _context.t1 = _context[\"catch\"](53);\n                sendRequestError = _context.t1;\n              case 62:\n                if (sendRequestError) {\n                  if (sendRequestError.response) {\n                    sendRequestError.details = flattenResponse(sendRequestError.response, operationSpec.responses[sendRequestError.statusCode] || operationSpec.responses[\"default\"]);\n                  }\n                  result = Promise.reject(sendRequestError);\n                } else {\n                  result = Promise.resolve(flattenResponse(rawResponse, operationSpec.responses[rawResponse.status]));\n                }\n                _context.next = 68;\n                break;\n              case 65:\n                _context.prev = 65;\n                _context.t2 = _context[\"catch\"](3);\n                result = Promise.reject(_context.t2);\n              case 68:\n                cb = callback;\n                if (cb) {\n                  result.then(function (res) {\n                    return cb(null, res._response.parsedBody, res._response.request, res._response);\n                  }).catch(function (err) {\n                    return cb(err);\n                  });\n                }\n                return _context.abrupt(\"return\", result);\n              case 71:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[3, 65], [14, 38, 41, 44], [53, 59]]);\n      }));\n      function sendOperationRequest(_x, _x2, _x3) {\n        return _sendOperationRequest.apply(this, arguments);\n      }\n      return sendOperationRequest;\n    }()\n  }]);\n  return ServiceClient;\n}();\nexport function serializeRequestBody(serviceClient, httpRequest, operationArguments, operationSpec) {\n  var _a, _b, _c, _d, _e, _f;\n  var serializerOptions = (_b = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions) !== null && _b !== void 0 ? _b : {};\n  var updatedOptions = {\n    rootName: (_c = serializerOptions.rootName) !== null && _c !== void 0 ? _c : \"\",\n    includeRoot: (_d = serializerOptions.includeRoot) !== null && _d !== void 0 ? _d : false,\n    xmlCharKey: (_e = serializerOptions.xmlCharKey) !== null && _e !== void 0 ? _e : XML_CHARKEY\n  };\n  var xmlCharKey = serializerOptions.xmlCharKey;\n  if (operationSpec.requestBody && operationSpec.requestBody.mapper) {\n    httpRequest.body = getOperationArgumentValueFromParameter(serviceClient, operationArguments, operationSpec.requestBody, operationSpec.serializer);\n    var bodyMapper = operationSpec.requestBody.mapper;\n    var required = bodyMapper.required,\n      xmlName = bodyMapper.xmlName,\n      xmlElementName = bodyMapper.xmlElementName,\n      serializedName = bodyMapper.serializedName,\n      xmlNamespace = bodyMapper.xmlNamespace,\n      xmlNamespacePrefix = bodyMapper.xmlNamespacePrefix;\n    var typeName = bodyMapper.type.name;\n    try {\n      if (httpRequest.body !== undefined && httpRequest.body !== null || required) {\n        var requestBodyParameterPathString = getPathStringFromParameter(operationSpec.requestBody);\n        httpRequest.body = operationSpec.serializer.serialize(bodyMapper, httpRequest.body, requestBodyParameterPathString, updatedOptions);\n        var isStream = typeName === MapperType.Stream;\n        if (operationSpec.isXML) {\n          var xmlnsKey = xmlNamespacePrefix ? \"xmlns:\".concat(xmlNamespacePrefix) : \"xmlns\";\n          var value = getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, httpRequest.body, updatedOptions);\n          if (typeName === MapperType.Sequence) {\n            httpRequest.body = stringifyXML(utils.prepareXMLRootList(value, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), {\n              rootName: xmlName || serializedName,\n              xmlCharKey: xmlCharKey\n            });\n          } else if (!isStream) {\n            httpRequest.body = stringifyXML(value, {\n              rootName: xmlName || serializedName,\n              xmlCharKey: xmlCharKey\n            });\n          }\n        } else if (typeName === MapperType.String && (((_f = operationSpec.contentType) === null || _f === void 0 ? void 0 : _f.match(\"text/plain\")) || operationSpec.mediaType === \"text\")) {\n          // the String serializer has validated that request body is a string\n          // so just send the string.\n          return;\n        } else if (!isStream) {\n          httpRequest.body = JSON.stringify(httpRequest.body);\n        }\n      }\n    } catch (error) {\n      throw new Error(\"Error \\\"\".concat(error.message, \"\\\" occurred in serializing the payload - \").concat(JSON.stringify(serializedName, undefined, \"  \"), \".\"));\n    }\n  } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {\n    httpRequest.formData = {};\n    var _iterator4 = _createForOfIteratorHelper(operationSpec.formDataParameters),\n      _step4;\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var formDataParameter = _step4.value;\n        var formDataParameterValue = getOperationArgumentValueFromParameter(serviceClient, operationArguments, formDataParameter, operationSpec.serializer);\n        if (formDataParameterValue !== undefined && formDataParameterValue !== null) {\n          var formDataParameterPropertyName = formDataParameter.mapper.serializedName || getPathStringFromParameter(formDataParameter);\n          httpRequest.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, getPathStringFromParameter(formDataParameter), updatedOptions);\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n  }\n}\n/**\n * Adds an xml namespace to the xml serialized object if needed, otherwise it just returns the value itself\n */\nfunction getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, serializedValue, options) {\n  // Composite and Sequence schemas already got their root namespace set during serialization\n  // We just need to add xmlns to the other schema types\n  if (xmlNamespace && ![\"Composite\", \"Sequence\", \"Dictionary\"].includes(typeName)) {\n    var result = {};\n    result[options.xmlCharKey] = serializedValue;\n    result[XML_ATTRKEY] = _defineProperty({}, xmlnsKey, xmlNamespace);\n    return result;\n  }\n  return serializedValue;\n}\nfunction getValueOrFunctionResult(value, defaultValueCreator) {\n  var result;\n  if (typeof value === \"string\") {\n    result = value;\n  } else {\n    result = defaultValueCreator();\n    if (typeof value === \"function\") {\n      result = value(result);\n    }\n  }\n  return result;\n}\nfunction createDefaultRequestPolicyFactories(authPolicyFactory, options) {\n  var factories = [];\n  if (options.generateClientRequestIdHeader) {\n    factories.push(generateClientRequestIdPolicy(options.clientRequestIdHeaderName));\n  }\n  if (authPolicyFactory) {\n    factories.push(authPolicyFactory);\n  }\n  var userAgentHeaderName = getValueOrFunctionResult(options.userAgentHeaderName, getDefaultUserAgentHeaderName);\n  var userAgentHeaderValue = getValueOrFunctionResult(options.userAgent, getDefaultUserAgentValue);\n  if (userAgentHeaderName && userAgentHeaderValue) {\n    factories.push(userAgentPolicy({\n      key: userAgentHeaderName,\n      value: userAgentHeaderValue\n    }));\n  }\n  factories.push(redirectPolicy());\n  factories.push(rpRegistrationPolicy(options.rpRegistrationRetryTimeout));\n  if (!options.noRetryPolicy) {\n    factories.push(exponentialRetryPolicy());\n    factories.push(systemErrorRetryPolicy());\n    factories.push(throttlingRetryPolicy());\n  }\n  factories.push(deserializationPolicy(options.deserializationContentTypes));\n  if (isNode) {\n    factories.push(proxyPolicy(options.proxySettings));\n  }\n  factories.push(logPolicy({\n    logger: logger.info\n  }));\n  return factories;\n}\n/**\n * Creates an HTTP pipeline based on the given options.\n * @param pipelineOptions - Defines options that are used to configure policies in the HTTP pipeline for an SDK client.\n * @param authPolicyFactory - An optional authentication policy factory to use for signing requests.\n * @returns A set of options that can be passed to create a new {@link ServiceClient}.\n */\nexport function createPipelineFromOptions(pipelineOptions, authPolicyFactory) {\n  var requestPolicyFactories = [];\n  if (pipelineOptions.sendStreamingJson) {\n    requestPolicyFactories.push(ndJsonPolicy());\n  }\n  var userAgentValue = undefined;\n  if (pipelineOptions.userAgentOptions && pipelineOptions.userAgentOptions.userAgentPrefix) {\n    var userAgentInfo = [];\n    userAgentInfo.push(pipelineOptions.userAgentOptions.userAgentPrefix);\n    // Add the default user agent value if it isn't already specified\n    // by the userAgentPrefix option.\n    var defaultUserAgentInfo = getDefaultUserAgentValue();\n    if (userAgentInfo.indexOf(defaultUserAgentInfo) === -1) {\n      userAgentInfo.push(defaultUserAgentInfo);\n    }\n    userAgentValue = userAgentInfo.join(\" \");\n  }\n  var keepAliveOptions = Object.assign(Object.assign({}, DefaultKeepAliveOptions), pipelineOptions.keepAliveOptions);\n  var retryOptions = Object.assign(Object.assign({}, DefaultRetryOptions), pipelineOptions.retryOptions);\n  var redirectOptions = Object.assign(Object.assign({}, DefaultRedirectOptions), pipelineOptions.redirectOptions);\n  if (isNode) {\n    requestPolicyFactories.push(proxyPolicy(pipelineOptions.proxyOptions));\n  }\n  var deserializationOptions = Object.assign(Object.assign({}, DefaultDeserializationOptions), pipelineOptions.deserializationOptions);\n  var loggingOptions = Object.assign({}, pipelineOptions.loggingOptions);\n  requestPolicyFactories.push(tracingPolicy({\n    userAgent: userAgentValue\n  }), keepAlivePolicy(keepAliveOptions), userAgentPolicy({\n    value: userAgentValue\n  }), generateClientRequestIdPolicy(), deserializationPolicy(deserializationOptions.expectedContentTypes), throttlingRetryPolicy(), systemErrorRetryPolicy(), exponentialRetryPolicy(retryOptions.maxRetries, retryOptions.retryDelayInMs, retryOptions.maxRetryDelayInMs));\n  if (redirectOptions.handleRedirects) {\n    requestPolicyFactories.push(redirectPolicy(redirectOptions.maxRetries));\n  }\n  if (authPolicyFactory) {\n    requestPolicyFactories.push(authPolicyFactory);\n  }\n  requestPolicyFactories.push(logPolicy(loggingOptions));\n  if (isNode && pipelineOptions.decompressResponse === false) {\n    requestPolicyFactories.push(disableResponseDecompressionPolicy());\n  }\n  return {\n    httpClient: pipelineOptions.httpClient,\n    requestPolicyFactories: requestPolicyFactories\n  };\n}\n/**\n * Get the property parent for the property at the provided path when starting with the provided\n * parent object.\n */\nexport function getPropertyParent(parent, propertyPath) {\n  if (parent && propertyPath) {\n    var propertyPathLength = propertyPath.length;\n    for (var i = 0; i < propertyPathLength - 1; ++i) {\n      var propertyName = propertyPath[i];\n      if (!parent[propertyName]) {\n        parent[propertyName] = {};\n      }\n      parent = parent[propertyName];\n    }\n  }\n  return parent;\n}\nfunction getOperationArgumentValueFromParameter(serviceClient, operationArguments, parameter, serializer) {\n  return getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, parameter.parameterPath, parameter.mapper, serializer);\n}\nexport function getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, parameterPath, parameterMapper, serializer) {\n  var _a;\n  var value;\n  if (typeof parameterPath === \"string\") {\n    parameterPath = [parameterPath];\n  }\n  var serializerOptions = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions;\n  if (Array.isArray(parameterPath)) {\n    if (parameterPath.length > 0) {\n      if (parameterMapper.isConstant) {\n        value = parameterMapper.defaultValue;\n      } else {\n        var propertySearchResult = getPropertyFromParameterPath(operationArguments, parameterPath);\n        if (!propertySearchResult.propertyFound) {\n          propertySearchResult = getPropertyFromParameterPath(serviceClient, parameterPath);\n        }\n        var useDefaultValue = false;\n        if (!propertySearchResult.propertyFound) {\n          useDefaultValue = parameterMapper.required || parameterPath[0] === \"options\" && parameterPath.length === 2;\n        }\n        value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;\n      }\n      // Serialize just for validation purposes.\n      var parameterPathString = getPathStringFromParameterPath(parameterPath, parameterMapper);\n      serializer.serialize(parameterMapper, value, parameterPathString, serializerOptions);\n    }\n  } else {\n    if (parameterMapper.required) {\n      value = {};\n    }\n    for (var propertyName in parameterPath) {\n      var propertyMapper = parameterMapper.type.modelProperties[propertyName];\n      var propertyPath = parameterPath[propertyName];\n      var propertyValue = getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, propertyPath, propertyMapper, serializer);\n      // Serialize just for validation purposes.\n      var propertyPathString = getPathStringFromParameterPath(propertyPath, propertyMapper);\n      serializer.serialize(propertyMapper, propertyValue, propertyPathString, serializerOptions);\n      if (propertyValue !== undefined && propertyValue !== null) {\n        if (!value) {\n          value = {};\n        }\n        value[propertyName] = propertyValue;\n      }\n    }\n  }\n  return value;\n}\nfunction getPropertyFromParameterPath(parent, parameterPath) {\n  var result = {\n    propertyFound: false\n  };\n  var i = 0;\n  for (; i < parameterPath.length; ++i) {\n    var parameterPathPart = parameterPath[i];\n    // Make sure to check inherited properties too, so don't use hasOwnProperty().\n    if (parent !== undefined && parent !== null && parameterPathPart in parent) {\n      parent = parent[parameterPathPart];\n    } else {\n      break;\n    }\n  }\n  if (i === parameterPath.length) {\n    result.propertyValue = parent;\n    result.propertyFound = true;\n  }\n  return result;\n}\n/**\n * Parses an {@link HttpOperationResponse} into a normalized HTTP response object ({@link RestResponse}).\n * @param _response - Wrapper object for http response.\n * @param responseSpec - Mappers for how to parse the response properties.\n * @returns - A normalized response object.\n */\nexport function flattenResponse(_response, responseSpec) {\n  var parsedHeaders = _response.parsedHeaders;\n  var bodyMapper = responseSpec && responseSpec.bodyMapper;\n  var addOperationResponse = function addOperationResponse(obj) {\n    return Object.defineProperty(obj, \"_response\", {\n      value: _response\n    });\n  };\n  if (bodyMapper) {\n    var typeName = bodyMapper.type.name;\n    if (typeName === \"Stream\") {\n      return addOperationResponse(Object.assign(Object.assign({}, parsedHeaders), {\n        blobBody: _response.blobBody,\n        readableStreamBody: _response.readableStreamBody\n      }));\n    }\n    var modelProperties = typeName === \"Composite\" && bodyMapper.type.modelProperties || {};\n    var isPageableResponse = Object.keys(modelProperties).some(function (k) {\n      return modelProperties[k].serializedName === \"\";\n    });\n    if (typeName === \"Sequence\" || isPageableResponse) {\n      var arrayResponse = _toConsumableArray(_response.parsedBody || []);\n      for (var _i2 = 0, _Object$keys2 = Object.keys(modelProperties); _i2 < _Object$keys2.length; _i2++) {\n        var key = _Object$keys2[_i2];\n        if (modelProperties[key].serializedName) {\n          arrayResponse[key] = _response.parsedBody[key];\n        }\n      }\n      if (parsedHeaders) {\n        for (var _i3 = 0, _Object$keys3 = Object.keys(parsedHeaders); _i3 < _Object$keys3.length; _i3++) {\n          var _key = _Object$keys3[_i3];\n          arrayResponse[_key] = parsedHeaders[_key];\n        }\n      }\n      addOperationResponse(arrayResponse);\n      return arrayResponse;\n    }\n    if (typeName === \"Composite\" || typeName === \"Dictionary\") {\n      return addOperationResponse(Object.assign(Object.assign({}, parsedHeaders), _response.parsedBody));\n    }\n  }\n  if (bodyMapper || _response.request.method === \"HEAD\" || utils.isPrimitiveType(_response.parsedBody)) {\n    // primitive body types and HEAD booleans\n    return addOperationResponse(Object.assign(Object.assign({}, parsedHeaders), {\n      body: _response.parsedBody\n    }));\n  }\n  return addOperationResponse(Object.assign(Object.assign({}, parsedHeaders), _response.parsedBody));\n}\nfunction getCredentialScopes(options, baseUri) {\n  if (options === null || options === void 0 ? void 0 : options.credentialScopes) {\n    var scopes = options.credentialScopes;\n    return Array.isArray(scopes) ? scopes.map(function (scope) {\n      return new URL(scope).toString();\n    }) : new URL(scopes).toString();\n  }\n  if (baseUri) {\n    return \"\".concat(baseUri, \"/.default\");\n  }\n  return undefined;\n}","map":{"version":3,"mappings":"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","names":["utils","MapperType","DefaultDeserializationOptions","deserializationPolicy","DefaultKeepAliveOptions","keepAlivePolicy","DefaultRedirectOptions","redirectPolicy","DefaultRetryOptions","exponentialRetryPolicy","logPolicy","getPathStringFromParameter","getPathStringFromParameterPath","getStreamResponseStatusCodes","WebResource","isWebResourceLike","RequestPolicyOptions","XML_ATTRKEY","XML_CHARKEY","isNode","isTokenCredential","getDefaultUserAgentHeaderName","getDefaultUserAgentValue","userAgentPolicy","QueryCollectionFormat","URLBuilder","bearerTokenAuthenticationPolicy","disableResponseDecompressionPolicy","generateClientRequestIdPolicy","getCachedDefaultHttpClient","logger","ndJsonPolicy","proxyPolicy","rpRegistrationPolicy","signingPolicy","stringifyXML","systemErrorRetryPolicy","throttlingRetryPolicy","tracingPolicy","ServiceClient","credentials","options","_withCredentials","withCredentials","_httpClient","httpClient","_requestPolicyOptions","httpPipelineLogger","requestPolicyFactories","Array","isArray","info","authPolicyFactory","undefined","wrappedPolicyFactory","bearerTokenPolicyFactory","serviceClient","serviceClientOptions","create","nextPolicy","createOptions","credentialScopes","getCredentialScopes","baseUri","Error","signRequest","createDefaultRequestPolicyFactories","newRequestPolicyFactories","_requestPolicyFactories","httpRequest","validateRequestProperties","prepare","error","Promise","reject","httpPipeline","length","i","sendRequest","operationArguments","operationSpec","callback","serializerOptions","baseUrl","method","httpMethod","requestUrl","parse","path","appendPath","urlParameters","urlParameter","urlParameterValue","getOperationArgumentValueFromParameter","serializer","serialize","mapper","skipEncoding","encodeURIComponent","replaceAll","serializedName","queryParameters","queryParameter","queryParameterValue","collectionFormat","Multi","index","item","toString","Ssv","Tsv","join","setQueryParameter","url","contentType","requestContentType","requestBody","headers","set","headerParameters","headerParameter","headerValue","headerCollectionPrefix","Object","keys","key","customHeaders","customHeaderName","abortSignal","timeout","onUploadProgress","onDownloadProgress","spanOptions","tracingContext","shouldDeserialize","serializeRequestBody","streamResponseStatusCodes","rawResponse","sendRequestError","response","details","flattenResponse","responses","statusCode","result","resolve","status","cb","then","res","_response","parsedBody","request","catch","err","updatedOptions","rootName","includeRoot","xmlCharKey","body","bodyMapper","required","xmlName","xmlElementName","xmlNamespace","xmlNamespacePrefix","typeName","type","name","requestBodyParameterPathString","isStream","Stream","isXML","xmlnsKey","value","getXmlValueWithNamespace","Sequence","prepareXMLRootList","String","match","mediaType","JSON","stringify","message","formDataParameters","formData","formDataParameter","formDataParameterValue","formDataParameterPropertyName","serializedValue","includes","getValueOrFunctionResult","defaultValueCreator","factories","generateClientRequestIdHeader","push","clientRequestIdHeaderName","userAgentHeaderName","userAgentHeaderValue","userAgent","rpRegistrationRetryTimeout","noRetryPolicy","deserializationContentTypes","proxySettings","createPipelineFromOptions","pipelineOptions","sendStreamingJson","userAgentValue","userAgentOptions","userAgentPrefix","userAgentInfo","defaultUserAgentInfo","indexOf","keepAliveOptions","retryOptions","redirectOptions","proxyOptions","deserializationOptions","loggingOptions","expectedContentTypes","maxRetries","retryDelayInMs","maxRetryDelayInMs","handleRedirects","decompressResponse","getPropertyParent","parent","propertyPath","propertyPathLength","propertyName","parameter","getOperationArgumentValueFromParameterPath","parameterPath","parameterMapper","isConstant","defaultValue","propertySearchResult","getPropertyFromParameterPath","propertyFound","useDefaultValue","propertyValue","parameterPathString","propertyMapper","modelProperties","propertyPathString","parameterPathPart","responseSpec","parsedHeaders","addOperationResponse","obj","defineProperty","blobBody","readableStreamBody","isPageableResponse","some","k","arrayResponse","isPrimitiveType","scopes","map","scope","URL"],"sourceRoot":"","sources":["../../src/serviceClient.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport * as utils from \"./util/utils\";\nimport { CompositeMapper, DictionaryMapper, Mapper, MapperType, Serializer } from \"./serializer\";\nimport {\n  DefaultDeserializationOptions,\n  DeserializationContentTypes,\n  deserializationPolicy,\n} from \"./policies/deserializationPolicy\";\nimport { DefaultKeepAliveOptions, keepAlivePolicy } from \"./policies/keepAlivePolicy\";\nimport { DefaultRedirectOptions, redirectPolicy } from \"./policies/redirectPolicy\";\nimport { DefaultRetryOptions, exponentialRetryPolicy } from \"./policies/exponentialRetryPolicy\";\nimport { HttpOperationResponse, RestResponse } from \"./httpOperationResponse\";\nimport { LogPolicyOptions, logPolicy } from \"./policies/logPolicy\";\nimport {\n  OperationParameter,\n  ParameterPath,\n  getPathStringFromParameter,\n  getPathStringFromParameterPath,\n} from \"./operationParameter\";\nimport { OperationSpec, getStreamResponseStatusCodes } from \"./operationSpec\";\nimport {\n  RequestOptionsBase,\n  RequestPrepareOptions,\n  WebResource,\n  WebResourceLike,\n  isWebResourceLike,\n} from \"./webResource\";\nimport {\n  RequestPolicy,\n  RequestPolicyFactory,\n  RequestPolicyOptions,\n} from \"./policies/requestPolicy\";\nimport { SerializerOptions, XML_ATTRKEY, XML_CHARKEY } from \"./util/serializer.common\";\nimport { ServiceCallback, isNode } from \"./util/utils\";\nimport { TokenCredential, isTokenCredential } from \"@azure/core-auth\";\nimport {\n  getDefaultUserAgentHeaderName,\n  getDefaultUserAgentValue,\n  userAgentPolicy,\n} from \"./policies/userAgentPolicy\";\nimport { HttpClient } from \"./httpClient\";\nimport { HttpPipelineLogger } from \"./httpPipelineLogger\";\nimport { InternalPipelineOptions } from \"./pipelineOptions\";\nimport { OperationArguments } from \"./operationArguments\";\nimport { OperationResponse } from \"./operationResponse\";\nimport { QueryCollectionFormat } from \"./queryCollectionFormat\";\nimport { ServiceClientCredentials } from \"./credentials/serviceClientCredentials\";\nimport { URLBuilder } from \"./url\";\nimport { bearerTokenAuthenticationPolicy } from \"./policies/bearerTokenAuthenticationPolicy\";\nimport { disableResponseDecompressionPolicy } from \"./policies/disableResponseDecompressionPolicy\";\nimport { generateClientRequestIdPolicy } from \"./policies/generateClientRequestIdPolicy\";\nimport { getCachedDefaultHttpClient } from \"./httpClientCache\";\nimport { logger } from \"./log\";\nimport { ndJsonPolicy } from \"./policies/ndJsonPolicy\";\nimport { proxyPolicy } from \"./policies/proxyPolicy\";\nimport { rpRegistrationPolicy } from \"./policies/rpRegistrationPolicy\";\nimport { signingPolicy } from \"./policies/signingPolicy\";\nimport { stringifyXML } from \"./util/xml\";\nimport { systemErrorRetryPolicy } from \"./policies/systemErrorRetryPolicy\";\nimport { throttlingRetryPolicy } from \"./policies/throttlingRetryPolicy\";\nimport { tracingPolicy } from \"./policies/tracingPolicy\";\n\n/**\n * Options to configure a proxy for outgoing requests (Node.js only).\n */\nexport interface ProxySettings {\n  /**\n   * The proxy's host address.\n   */\n  host: string;\n\n  /**\n   * The proxy host's port.\n   */\n  port: number;\n\n  /**\n   * The user name to authenticate with the proxy, if required.\n   */\n  username?: string;\n\n  /**\n   * The password to authenticate with the proxy, if required.\n   */\n  password?: string;\n}\n\n/**\n * An alias of {@link ProxySettings} for future use.\n */\nexport type ProxyOptions = ProxySettings;\n\n/**\n * Options to be provided while creating the client.\n */\nexport interface ServiceClientOptions {\n  /**\n   * An array of factories which get called to create the RequestPolicy pipeline used to send a HTTP\n   * request on the wire, or a function that takes in the defaultRequestPolicyFactories and returns\n   * the requestPolicyFactories that will be used.\n   */\n  requestPolicyFactories?:\n    | RequestPolicyFactory[]\n    | ((defaultRequestPolicyFactories: RequestPolicyFactory[]) => void | RequestPolicyFactory[]);\n  /**\n   * The HttpClient that will be used to send HTTP requests.\n   */\n  httpClient?: HttpClient;\n  /**\n   * The HttpPipelineLogger that can be used to debug RequestPolicies within the HTTP pipeline.\n   */\n  httpPipelineLogger?: HttpPipelineLogger;\n  /**\n   * If set to true, turn off the default retry policy.\n   */\n  noRetryPolicy?: boolean;\n  /**\n   * Gets or sets the retry timeout in seconds for AutomaticRPRegistration. Default value is 30.\n   */\n  rpRegistrationRetryTimeout?: number;\n  /**\n   * Whether or not to generate a client request ID header for each HTTP request.\n   */\n  generateClientRequestIdHeader?: boolean;\n  /**\n   * Whether to include credentials in CORS requests in the browser.\n   * See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials for more information.\n   */\n  withCredentials?: boolean;\n  /**\n   * If specified, a GenerateRequestIdPolicy will be added to the HTTP pipeline that will add a\n   * header to all outgoing requests with this header name and a random UUID as the request ID.\n   */\n  clientRequestIdHeaderName?: string;\n  /**\n   * The content-types that will be associated with JSON or XML serialization.\n   */\n  deserializationContentTypes?: DeserializationContentTypes;\n  /**\n   * The header name to use for the telemetry header while sending the request. If this is not\n   * specified, then \"User-Agent\" will be used when running on Node.js and \"x-ms-useragent\" will\n   * be used when running in a browser.\n   */\n  userAgentHeaderName?: string | ((defaultUserAgentHeaderName: string) => string);\n  /**\n   * The string to be set to the telemetry header while sending the request, or a function that\n   * takes in the default user-agent string and returns the user-agent string that will be used.\n   */\n  userAgent?: string | ((defaultUserAgent: string) => string);\n  /**\n   * Proxy settings which will be used for every HTTP request (Node.js only).\n   */\n  proxySettings?: ProxySettings;\n  /**\n   * If specified, will be used to build the BearerTokenAuthenticationPolicy.\n   */\n  credentialScopes?: string | string[];\n}\n\n/**\n * ServiceClient sends service requests and receives responses.\n */\nexport class ServiceClient {\n  /**\n   * If specified, this is the base URI that requests will be made against for this ServiceClient.\n   * If it is not specified, then all OperationSpecs must contain a baseUrl property.\n   */\n  protected baseUri?: string;\n\n  /**\n   * The default request content type for the service.\n   * Used if no requestContentType is present on an OperationSpec.\n   */\n  protected requestContentType?: string;\n\n  /**\n   * The HTTP client that will be used to send requests.\n   */\n  private readonly _httpClient: HttpClient;\n  private readonly _requestPolicyOptions: RequestPolicyOptions;\n\n  private readonly _requestPolicyFactories: RequestPolicyFactory[];\n  private readonly _withCredentials: boolean;\n\n  /**\n   * The ServiceClient constructor\n   * @param credentials - The credentials used for authentication with the service.\n   * @param options - The service client options that govern the behavior of the client.\n   */\n  constructor(\n    credentials?: TokenCredential | ServiceClientCredentials,\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options */\n    options?: ServiceClientOptions\n  ) {\n    if (!options) {\n      options = {};\n    }\n\n    this._withCredentials = options.withCredentials || false;\n    this._httpClient = options.httpClient || getCachedDefaultHttpClient();\n    this._requestPolicyOptions = new RequestPolicyOptions(options.httpPipelineLogger);\n\n    let requestPolicyFactories: RequestPolicyFactory[];\n    if (Array.isArray(options.requestPolicyFactories)) {\n      logger.info(\"ServiceClient: using custom request policies\");\n      requestPolicyFactories = options.requestPolicyFactories;\n    } else {\n      let authPolicyFactory: RequestPolicyFactory | undefined = undefined;\n      if (isTokenCredential(credentials)) {\n        logger.info(\n          \"ServiceClient: creating bearer token authentication policy from provided credentials\"\n        );\n        // Create a wrapped RequestPolicyFactory here so that we can provide the\n        // correct scope to the BearerTokenAuthenticationPolicy at the first time\n        // one is requested.  This is needed because generated ServiceClient\n        // implementations do not set baseUri until after ServiceClient's constructor\n        // is finished, leaving baseUri empty at the time when it is needed to\n        // build the correct scope name.\n        const wrappedPolicyFactory: () => RequestPolicyFactory = () => {\n          let bearerTokenPolicyFactory: RequestPolicyFactory | undefined = undefined;\n          // eslint-disable-next-line @typescript-eslint/no-this-alias\n          const serviceClient = this;\n          const serviceClientOptions = options;\n          return {\n            create(nextPolicy: RequestPolicy, createOptions: RequestPolicyOptions): RequestPolicy {\n              const credentialScopes = getCredentialScopes(\n                serviceClientOptions,\n                serviceClient.baseUri\n              );\n\n              if (!credentialScopes) {\n                throw new Error(\n                  `When using credential, the ServiceClient must contain a baseUri or a credentialScopes in ServiceClientOptions. Unable to create a bearerTokenAuthenticationPolicy`\n                );\n              }\n\n              if (bearerTokenPolicyFactory === undefined || bearerTokenPolicyFactory === null) {\n                bearerTokenPolicyFactory = bearerTokenAuthenticationPolicy(\n                  credentials,\n                  credentialScopes\n                );\n              }\n\n              return bearerTokenPolicyFactory.create(nextPolicy, createOptions);\n            },\n          };\n        };\n\n        authPolicyFactory = wrappedPolicyFactory();\n      } else if (credentials && typeof credentials.signRequest === \"function\") {\n        logger.info(\"ServiceClient: creating signing policy from provided credentials\");\n        authPolicyFactory = signingPolicy(credentials);\n      } else if (credentials !== undefined && credentials !== null) {\n        throw new Error(\"The credentials argument must implement the TokenCredential interface\");\n      }\n\n      logger.info(\"ServiceClient: using default request policies\");\n      requestPolicyFactories = createDefaultRequestPolicyFactories(authPolicyFactory, options);\n      if (options.requestPolicyFactories) {\n        // options.requestPolicyFactories can also be a function that manipulates\n        // the default requestPolicyFactories array\n        const newRequestPolicyFactories: void | RequestPolicyFactory[] =\n          options.requestPolicyFactories(requestPolicyFactories);\n        if (newRequestPolicyFactories) {\n          requestPolicyFactories = newRequestPolicyFactories;\n        }\n      }\n    }\n    this._requestPolicyFactories = requestPolicyFactories;\n  }\n\n  /**\n   * Send the provided httpRequest.\n   */\n  sendRequest(options: RequestPrepareOptions | WebResourceLike): Promise<HttpOperationResponse> {\n    if (options === null || options === undefined || typeof options !== \"object\") {\n      throw new Error(\"options cannot be null or undefined and it must be of type object.\");\n    }\n\n    let httpRequest: WebResourceLike;\n    try {\n      if (isWebResourceLike(options)) {\n        options.validateRequestProperties();\n        httpRequest = options;\n      } else {\n        httpRequest = new WebResource();\n        httpRequest = httpRequest.prepare(options);\n      }\n    } catch (error: any) {\n      return Promise.reject(error);\n    }\n\n    let httpPipeline: RequestPolicy = this._httpClient;\n    if (this._requestPolicyFactories && this._requestPolicyFactories.length > 0) {\n      for (let i = this._requestPolicyFactories.length - 1; i >= 0; --i) {\n        httpPipeline = this._requestPolicyFactories[i].create(\n          httpPipeline,\n          this._requestPolicyOptions\n        );\n      }\n    }\n    return httpPipeline.sendRequest(httpRequest);\n  }\n\n  /**\n   * Send an HTTP request that is populated using the provided OperationSpec.\n   * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.\n   * @param operationSpec - The OperationSpec to use to populate the httpRequest.\n   * @param callback - The callback to call when the response is received.\n   */\n  async sendOperationRequest(\n    operationArguments: OperationArguments,\n    operationSpec: OperationSpec,\n    callback?: ServiceCallback<any>\n  ): Promise<RestResponse> {\n    if (typeof operationArguments.options === \"function\") {\n      callback = operationArguments.options;\n      operationArguments.options = undefined;\n    }\n\n    const serializerOptions = operationArguments.options?.serializerOptions;\n    const httpRequest: WebResourceLike = new WebResource();\n\n    let result: Promise<RestResponse>;\n    try {\n      const baseUri: string | undefined = operationSpec.baseUrl || this.baseUri;\n      if (!baseUri) {\n        throw new Error(\n          \"If operationSpec.baseUrl is not specified, then the ServiceClient must have a baseUri string property that contains the base URL to use.\"\n        );\n      }\n\n      httpRequest.method = operationSpec.httpMethod;\n      httpRequest.operationSpec = operationSpec;\n\n      const requestUrl: URLBuilder = URLBuilder.parse(baseUri);\n      if (operationSpec.path) {\n        requestUrl.appendPath(operationSpec.path);\n      }\n      if (operationSpec.urlParameters && operationSpec.urlParameters.length > 0) {\n        for (const urlParameter of operationSpec.urlParameters) {\n          let urlParameterValue: string = getOperationArgumentValueFromParameter(\n            this,\n            operationArguments,\n            urlParameter,\n            operationSpec.serializer\n          );\n          urlParameterValue = operationSpec.serializer.serialize(\n            urlParameter.mapper,\n            urlParameterValue,\n            getPathStringFromParameter(urlParameter),\n            serializerOptions\n          );\n          if (!urlParameter.skipEncoding) {\n            urlParameterValue = encodeURIComponent(urlParameterValue);\n          }\n          requestUrl.replaceAll(\n            `{${urlParameter.mapper.serializedName || getPathStringFromParameter(urlParameter)}}`,\n            urlParameterValue\n          );\n        }\n      }\n      if (operationSpec.queryParameters && operationSpec.queryParameters.length > 0) {\n        for (const queryParameter of operationSpec.queryParameters) {\n          let queryParameterValue: any = getOperationArgumentValueFromParameter(\n            this,\n            operationArguments,\n            queryParameter,\n            operationSpec.serializer\n          );\n          if (queryParameterValue !== undefined && queryParameterValue !== null) {\n            queryParameterValue = operationSpec.serializer.serialize(\n              queryParameter.mapper,\n              queryParameterValue,\n              getPathStringFromParameter(queryParameter),\n              serializerOptions\n            );\n            if (\n              queryParameter.collectionFormat !== undefined &&\n              queryParameter.collectionFormat !== null\n            ) {\n              if (queryParameter.collectionFormat === QueryCollectionFormat.Multi) {\n                if (queryParameterValue.length === 0) {\n                  // The collection is empty, no need to try serializing the current queryParam\n                  continue;\n                } else {\n                  for (const index in queryParameterValue) {\n                    const item = queryParameterValue[index];\n                    queryParameterValue[index] =\n                      item === undefined || item === null ? \"\" : item.toString();\n                  }\n                }\n              } else if (\n                queryParameter.collectionFormat === QueryCollectionFormat.Ssv ||\n                queryParameter.collectionFormat === QueryCollectionFormat.Tsv\n              ) {\n                queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);\n              }\n            }\n            if (!queryParameter.skipEncoding) {\n              if (Array.isArray(queryParameterValue)) {\n                for (const index in queryParameterValue) {\n                  if (\n                    queryParameterValue[index] !== undefined &&\n                    queryParameterValue[index] !== null\n                  ) {\n                    queryParameterValue[index] = encodeURIComponent(queryParameterValue[index]);\n                  }\n                }\n              } else {\n                queryParameterValue = encodeURIComponent(queryParameterValue);\n              }\n            }\n            if (\n              queryParameter.collectionFormat !== undefined &&\n              queryParameter.collectionFormat !== null &&\n              queryParameter.collectionFormat !== QueryCollectionFormat.Multi &&\n              queryParameter.collectionFormat !== QueryCollectionFormat.Ssv &&\n              queryParameter.collectionFormat !== QueryCollectionFormat.Tsv\n            ) {\n              queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);\n            }\n            requestUrl.setQueryParameter(\n              queryParameter.mapper.serializedName || getPathStringFromParameter(queryParameter),\n              queryParameterValue\n            );\n          }\n        }\n      }\n      httpRequest.url = requestUrl.toString();\n\n      const contentType = operationSpec.contentType || this.requestContentType;\n      if (contentType && operationSpec.requestBody) {\n        httpRequest.headers.set(\"Content-Type\", contentType);\n      }\n\n      if (operationSpec.headerParameters) {\n        for (const headerParameter of operationSpec.headerParameters) {\n          let headerValue: any = getOperationArgumentValueFromParameter(\n            this,\n            operationArguments,\n            headerParameter,\n            operationSpec.serializer\n          );\n          if (headerValue !== undefined && headerValue !== null) {\n            headerValue = operationSpec.serializer.serialize(\n              headerParameter.mapper,\n              headerValue,\n              getPathStringFromParameter(headerParameter),\n              serializerOptions\n            );\n            const headerCollectionPrefix = (headerParameter.mapper as DictionaryMapper)\n              .headerCollectionPrefix;\n            if (headerCollectionPrefix) {\n              for (const key of Object.keys(headerValue)) {\n                httpRequest.headers.set(headerCollectionPrefix + key, headerValue[key]);\n              }\n            } else {\n              httpRequest.headers.set(\n                headerParameter.mapper.serializedName ||\n                  getPathStringFromParameter(headerParameter),\n                headerValue\n              );\n            }\n          }\n        }\n      }\n\n      const options: RequestOptionsBase | undefined = operationArguments.options;\n      if (options) {\n        if (options.customHeaders) {\n          for (const customHeaderName in options.customHeaders) {\n            httpRequest.headers.set(customHeaderName, options.customHeaders[customHeaderName]);\n          }\n        }\n\n        if (options.abortSignal) {\n          httpRequest.abortSignal = options.abortSignal;\n        }\n\n        if (options.timeout) {\n          httpRequest.timeout = options.timeout;\n        }\n\n        if (options.onUploadProgress) {\n          httpRequest.onUploadProgress = options.onUploadProgress;\n        }\n\n        if (options.onDownloadProgress) {\n          httpRequest.onDownloadProgress = options.onDownloadProgress;\n        }\n\n        if (options.spanOptions) {\n          // By passing spanOptions if they exist at runtime, we're backwards compatible with @azure/core-tracing@preview.13 and earlier.\n          (httpRequest as any).spanOptions = options.spanOptions;\n        }\n\n        if (options.tracingContext) {\n          httpRequest.tracingContext = options.tracingContext;\n        }\n\n        if (options.shouldDeserialize !== undefined && options.shouldDeserialize !== null) {\n          httpRequest.shouldDeserialize = options.shouldDeserialize;\n        }\n      }\n\n      httpRequest.withCredentials = this._withCredentials;\n\n      serializeRequestBody(this, httpRequest, operationArguments, operationSpec);\n\n      if (httpRequest.streamResponseStatusCodes === undefined) {\n        httpRequest.streamResponseStatusCodes = getStreamResponseStatusCodes(operationSpec);\n      }\n\n      let rawResponse: HttpOperationResponse;\n      let sendRequestError;\n      try {\n        rawResponse = await this.sendRequest(httpRequest);\n      } catch (error: any) {\n        sendRequestError = error;\n      }\n      if (sendRequestError) {\n        if (sendRequestError.response) {\n          sendRequestError.details = flattenResponse(\n            sendRequestError.response,\n            operationSpec.responses[sendRequestError.statusCode] ||\n              operationSpec.responses[\"default\"]\n          );\n        }\n        result = Promise.reject(sendRequestError);\n      } else {\n        result = Promise.resolve(\n          flattenResponse(rawResponse!, operationSpec.responses[rawResponse!.status])\n        );\n      }\n    } catch (error: any) {\n      result = Promise.reject(error);\n    }\n\n    const cb = callback;\n    if (cb) {\n      result\n        .then((res) => cb(null, res._response.parsedBody, res._response.request, res._response))\n        .catch((err) => cb(err));\n    }\n\n    return result;\n  }\n}\n\nexport function serializeRequestBody(\n  serviceClient: ServiceClient,\n  httpRequest: WebResourceLike,\n  operationArguments: OperationArguments,\n  operationSpec: OperationSpec\n): void {\n  const serializerOptions = operationArguments.options?.serializerOptions ?? {};\n  const updatedOptions: Required<SerializerOptions> = {\n    rootName: serializerOptions.rootName ?? \"\",\n    includeRoot: serializerOptions.includeRoot ?? false,\n    xmlCharKey: serializerOptions.xmlCharKey ?? XML_CHARKEY,\n  };\n\n  const xmlCharKey = serializerOptions.xmlCharKey;\n  if (operationSpec.requestBody && operationSpec.requestBody.mapper) {\n    httpRequest.body = getOperationArgumentValueFromParameter(\n      serviceClient,\n      operationArguments,\n      operationSpec.requestBody,\n      operationSpec.serializer\n    );\n\n    const bodyMapper = operationSpec.requestBody.mapper;\n    const { required, xmlName, xmlElementName, serializedName, xmlNamespace, xmlNamespacePrefix } =\n      bodyMapper;\n    const typeName = bodyMapper.type.name;\n\n    try {\n      if ((httpRequest.body !== undefined && httpRequest.body !== null) || required) {\n        const requestBodyParameterPathString: string = getPathStringFromParameter(\n          operationSpec.requestBody\n        );\n        httpRequest.body = operationSpec.serializer.serialize(\n          bodyMapper,\n          httpRequest.body,\n          requestBodyParameterPathString,\n          updatedOptions\n        );\n\n        const isStream = typeName === MapperType.Stream;\n\n        if (operationSpec.isXML) {\n          const xmlnsKey = xmlNamespacePrefix ? `xmlns:${xmlNamespacePrefix}` : \"xmlns\";\n          const value = getXmlValueWithNamespace(\n            xmlNamespace,\n            xmlnsKey,\n            typeName,\n            httpRequest.body,\n            updatedOptions\n          );\n          if (typeName === MapperType.Sequence) {\n            httpRequest.body = stringifyXML(\n              utils.prepareXMLRootList(\n                value,\n                xmlElementName || xmlName || serializedName!,\n                xmlnsKey,\n                xmlNamespace\n              ),\n              {\n                rootName: xmlName || serializedName,\n                xmlCharKey,\n              }\n            );\n          } else if (!isStream) {\n            httpRequest.body = stringifyXML(value, {\n              rootName: xmlName || serializedName,\n              xmlCharKey,\n            });\n          }\n        } else if (\n          typeName === MapperType.String &&\n          (operationSpec.contentType?.match(\"text/plain\") || operationSpec.mediaType === \"text\")\n        ) {\n          // the String serializer has validated that request body is a string\n          // so just send the string.\n          return;\n        } else if (!isStream) {\n          httpRequest.body = JSON.stringify(httpRequest.body);\n        }\n      }\n    } catch (error: any) {\n      throw new Error(\n        `Error \"${error.message}\" occurred in serializing the payload - ${JSON.stringify(\n          serializedName,\n          undefined,\n          \"  \"\n        )}.`\n      );\n    }\n  } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {\n    httpRequest.formData = {};\n    for (const formDataParameter of operationSpec.formDataParameters) {\n      const formDataParameterValue: any = getOperationArgumentValueFromParameter(\n        serviceClient,\n        operationArguments,\n        formDataParameter,\n        operationSpec.serializer\n      );\n      if (formDataParameterValue !== undefined && formDataParameterValue !== null) {\n        const formDataParameterPropertyName: string =\n          formDataParameter.mapper.serializedName || getPathStringFromParameter(formDataParameter);\n        httpRequest.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(\n          formDataParameter.mapper,\n          formDataParameterValue,\n          getPathStringFromParameter(formDataParameter),\n          updatedOptions\n        );\n      }\n    }\n  }\n}\n\n/**\n * Adds an xml namespace to the xml serialized object if needed, otherwise it just returns the value itself\n */\nfunction getXmlValueWithNamespace(\n  xmlNamespace: string | undefined,\n  xmlnsKey: string,\n  typeName: string,\n  serializedValue: any,\n  options: Required<SerializerOptions>\n): any {\n  // Composite and Sequence schemas already got their root namespace set during serialization\n  // We just need to add xmlns to the other schema types\n  if (xmlNamespace && ![\"Composite\", \"Sequence\", \"Dictionary\"].includes(typeName)) {\n    const result: any = {};\n    result[options.xmlCharKey] = serializedValue;\n    result[XML_ATTRKEY] = { [xmlnsKey]: xmlNamespace };\n    return result;\n  }\n\n  return serializedValue;\n}\n\nfunction getValueOrFunctionResult(\n  value: undefined | string | ((defaultValue: string) => string),\n  defaultValueCreator: () => string\n): string {\n  let result: string;\n  if (typeof value === \"string\") {\n    result = value;\n  } else {\n    result = defaultValueCreator();\n    if (typeof value === \"function\") {\n      result = value(result);\n    }\n  }\n  return result;\n}\n\nfunction createDefaultRequestPolicyFactories(\n  authPolicyFactory: RequestPolicyFactory | undefined,\n  options: ServiceClientOptions\n): RequestPolicyFactory[] {\n  const factories: RequestPolicyFactory[] = [];\n\n  if (options.generateClientRequestIdHeader) {\n    factories.push(generateClientRequestIdPolicy(options.clientRequestIdHeaderName));\n  }\n\n  if (authPolicyFactory) {\n    factories.push(authPolicyFactory);\n  }\n\n  const userAgentHeaderName: string = getValueOrFunctionResult(\n    options.userAgentHeaderName,\n    getDefaultUserAgentHeaderName\n  );\n  const userAgentHeaderValue: string = getValueOrFunctionResult(\n    options.userAgent,\n    getDefaultUserAgentValue\n  );\n  if (userAgentHeaderName && userAgentHeaderValue) {\n    factories.push(userAgentPolicy({ key: userAgentHeaderName, value: userAgentHeaderValue }));\n  }\n  factories.push(redirectPolicy());\n  factories.push(rpRegistrationPolicy(options.rpRegistrationRetryTimeout));\n\n  if (!options.noRetryPolicy) {\n    factories.push(exponentialRetryPolicy());\n    factories.push(systemErrorRetryPolicy());\n    factories.push(throttlingRetryPolicy());\n  }\n\n  factories.push(deserializationPolicy(options.deserializationContentTypes));\n\n  if (isNode) {\n    factories.push(proxyPolicy(options.proxySettings));\n  }\n\n  factories.push(logPolicy({ logger: logger.info }));\n\n  return factories;\n}\n\n/**\n * Creates an HTTP pipeline based on the given options.\n * @param pipelineOptions - Defines options that are used to configure policies in the HTTP pipeline for an SDK client.\n * @param authPolicyFactory - An optional authentication policy factory to use for signing requests.\n * @returns A set of options that can be passed to create a new {@link ServiceClient}.\n */\nexport function createPipelineFromOptions(\n  pipelineOptions: InternalPipelineOptions,\n  authPolicyFactory?: RequestPolicyFactory\n): ServiceClientOptions {\n  const requestPolicyFactories: RequestPolicyFactory[] = [];\n\n  if (pipelineOptions.sendStreamingJson) {\n    requestPolicyFactories.push(ndJsonPolicy());\n  }\n\n  let userAgentValue = undefined;\n  if (pipelineOptions.userAgentOptions && pipelineOptions.userAgentOptions.userAgentPrefix) {\n    const userAgentInfo: string[] = [];\n    userAgentInfo.push(pipelineOptions.userAgentOptions.userAgentPrefix);\n\n    // Add the default user agent value if it isn't already specified\n    // by the userAgentPrefix option.\n    const defaultUserAgentInfo = getDefaultUserAgentValue();\n    if (userAgentInfo.indexOf(defaultUserAgentInfo) === -1) {\n      userAgentInfo.push(defaultUserAgentInfo);\n    }\n\n    userAgentValue = userAgentInfo.join(\" \");\n  }\n\n  const keepAliveOptions = {\n    ...DefaultKeepAliveOptions,\n    ...pipelineOptions.keepAliveOptions,\n  };\n\n  const retryOptions = {\n    ...DefaultRetryOptions,\n    ...pipelineOptions.retryOptions,\n  };\n\n  const redirectOptions = {\n    ...DefaultRedirectOptions,\n    ...pipelineOptions.redirectOptions,\n  };\n\n  if (isNode) {\n    requestPolicyFactories.push(proxyPolicy(pipelineOptions.proxyOptions));\n  }\n\n  const deserializationOptions = {\n    ...DefaultDeserializationOptions,\n    ...pipelineOptions.deserializationOptions,\n  };\n\n  const loggingOptions: LogPolicyOptions = {\n    ...pipelineOptions.loggingOptions,\n  };\n\n  requestPolicyFactories.push(\n    tracingPolicy({ userAgent: userAgentValue }),\n    keepAlivePolicy(keepAliveOptions),\n    userAgentPolicy({ value: userAgentValue }),\n    generateClientRequestIdPolicy(),\n    deserializationPolicy(deserializationOptions.expectedContentTypes),\n    throttlingRetryPolicy(),\n    systemErrorRetryPolicy(),\n    exponentialRetryPolicy(\n      retryOptions.maxRetries,\n      retryOptions.retryDelayInMs,\n      retryOptions.maxRetryDelayInMs\n    )\n  );\n\n  if (redirectOptions.handleRedirects) {\n    requestPolicyFactories.push(redirectPolicy(redirectOptions.maxRetries));\n  }\n\n  if (authPolicyFactory) {\n    requestPolicyFactories.push(authPolicyFactory);\n  }\n\n  requestPolicyFactories.push(logPolicy(loggingOptions));\n\n  if (isNode && pipelineOptions.decompressResponse === false) {\n    requestPolicyFactories.push(disableResponseDecompressionPolicy());\n  }\n\n  return {\n    httpClient: pipelineOptions.httpClient,\n    requestPolicyFactories,\n  };\n}\n\nexport type PropertyParent = { [propertyName: string]: any };\n\n/**\n * Get the property parent for the property at the provided path when starting with the provided\n * parent object.\n */\nexport function getPropertyParent(parent: PropertyParent, propertyPath: string[]): PropertyParent {\n  if (parent && propertyPath) {\n    const propertyPathLength: number = propertyPath.length;\n    for (let i = 0; i < propertyPathLength - 1; ++i) {\n      const propertyName: string = propertyPath[i];\n      if (!parent[propertyName]) {\n        parent[propertyName] = {};\n      }\n      parent = parent[propertyName];\n    }\n  }\n  return parent;\n}\n\nfunction getOperationArgumentValueFromParameter(\n  serviceClient: ServiceClient,\n  operationArguments: OperationArguments,\n  parameter: OperationParameter,\n  serializer: Serializer\n): any {\n  return getOperationArgumentValueFromParameterPath(\n    serviceClient,\n    operationArguments,\n    parameter.parameterPath,\n    parameter.mapper,\n    serializer\n  );\n}\n\nexport function getOperationArgumentValueFromParameterPath(\n  serviceClient: ServiceClient,\n  operationArguments: OperationArguments,\n  parameterPath: ParameterPath,\n  parameterMapper: Mapper,\n  serializer: Serializer\n): any {\n  let value: any;\n  if (typeof parameterPath === \"string\") {\n    parameterPath = [parameterPath];\n  }\n  const serializerOptions = operationArguments.options?.serializerOptions;\n  if (Array.isArray(parameterPath)) {\n    if (parameterPath.length > 0) {\n      if (parameterMapper.isConstant) {\n        value = parameterMapper.defaultValue;\n      } else {\n        let propertySearchResult: PropertySearchResult = getPropertyFromParameterPath(\n          operationArguments,\n          parameterPath\n        );\n        if (!propertySearchResult.propertyFound) {\n          propertySearchResult = getPropertyFromParameterPath(serviceClient, parameterPath);\n        }\n\n        let useDefaultValue = false;\n        if (!propertySearchResult.propertyFound) {\n          useDefaultValue =\n            parameterMapper.required ||\n            (parameterPath[0] === \"options\" && parameterPath.length === 2);\n        }\n        value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;\n      }\n\n      // Serialize just for validation purposes.\n      const parameterPathString: string = getPathStringFromParameterPath(\n        parameterPath,\n        parameterMapper\n      );\n      serializer.serialize(parameterMapper, value, parameterPathString, serializerOptions);\n    }\n  } else {\n    if (parameterMapper.required) {\n      value = {};\n    }\n\n    for (const propertyName in parameterPath) {\n      const propertyMapper: Mapper = (parameterMapper as CompositeMapper).type.modelProperties![\n        propertyName\n      ];\n      const propertyPath: ParameterPath = parameterPath[propertyName];\n      const propertyValue: any = getOperationArgumentValueFromParameterPath(\n        serviceClient,\n        operationArguments,\n        propertyPath,\n        propertyMapper,\n        serializer\n      );\n      // Serialize just for validation purposes.\n      const propertyPathString: string = getPathStringFromParameterPath(\n        propertyPath,\n        propertyMapper\n      );\n      serializer.serialize(propertyMapper, propertyValue, propertyPathString, serializerOptions);\n      if (propertyValue !== undefined && propertyValue !== null) {\n        if (!value) {\n          value = {};\n        }\n        value[propertyName] = propertyValue;\n      }\n    }\n  }\n  return value;\n}\n\ninterface PropertySearchResult {\n  propertyValue?: any;\n  propertyFound: boolean;\n}\n\nfunction getPropertyFromParameterPath(\n  parent: { [parameterName: string]: any },\n  parameterPath: string[]\n): PropertySearchResult {\n  const result: PropertySearchResult = { propertyFound: false };\n  let i = 0;\n  for (; i < parameterPath.length; ++i) {\n    const parameterPathPart: string = parameterPath[i];\n    // Make sure to check inherited properties too, so don't use hasOwnProperty().\n    if (parent !== undefined && parent !== null && parameterPathPart in parent) {\n      parent = parent[parameterPathPart];\n    } else {\n      break;\n    }\n  }\n  if (i === parameterPath.length) {\n    result.propertyValue = parent;\n    result.propertyFound = true;\n  }\n  return result;\n}\n\n/**\n * Parses an {@link HttpOperationResponse} into a normalized HTTP response object ({@link RestResponse}).\n * @param _response - Wrapper object for http response.\n * @param responseSpec - Mappers for how to parse the response properties.\n * @returns - A normalized response object.\n */\nexport function flattenResponse(\n  _response: HttpOperationResponse,\n  responseSpec: OperationResponse | undefined\n): RestResponse {\n  const parsedHeaders = _response.parsedHeaders;\n  const bodyMapper = responseSpec && responseSpec.bodyMapper;\n\n  const addOperationResponse = <T extends Record<string, unknown>>(\n    obj: T\n  ): T & {\n    _response: HttpOperationResponse;\n  } => {\n    return Object.defineProperty(obj, \"_response\", {\n      value: _response,\n    }) as T & {\n      _response: HttpOperationResponse;\n    };\n  };\n\n  if (bodyMapper) {\n    const typeName = bodyMapper.type.name;\n    if (typeName === \"Stream\") {\n      return addOperationResponse({\n        ...parsedHeaders,\n        blobBody: _response.blobBody,\n        readableStreamBody: _response.readableStreamBody,\n      });\n    }\n\n    const modelProperties =\n      (typeName === \"Composite\" && (bodyMapper as CompositeMapper).type.modelProperties) || {};\n    const isPageableResponse = Object.keys(modelProperties).some(\n      (k) => modelProperties[k].serializedName === \"\"\n    );\n    if (typeName === \"Sequence\" || isPageableResponse) {\n      const arrayResponse = [...(_response.parsedBody || [])] as RestResponse & any[];\n\n      for (const key of Object.keys(modelProperties)) {\n        if (modelProperties[key].serializedName) {\n          arrayResponse[key] = _response.parsedBody[key];\n        }\n      }\n\n      if (parsedHeaders) {\n        for (const key of Object.keys(parsedHeaders)) {\n          arrayResponse[key] = parsedHeaders[key];\n        }\n      }\n      addOperationResponse(arrayResponse);\n      return arrayResponse;\n    }\n\n    if (typeName === \"Composite\" || typeName === \"Dictionary\") {\n      return addOperationResponse({\n        ...parsedHeaders,\n        ..._response.parsedBody,\n      });\n    }\n  }\n\n  if (\n    bodyMapper ||\n    _response.request.method === \"HEAD\" ||\n    utils.isPrimitiveType(_response.parsedBody)\n  ) {\n    // primitive body types and HEAD booleans\n    return addOperationResponse({\n      ...parsedHeaders,\n      body: _response.parsedBody,\n    });\n  }\n\n  return addOperationResponse({\n    ...parsedHeaders,\n    ..._response.parsedBody,\n  });\n}\n\nfunction getCredentialScopes(\n  options?: ServiceClientOptions,\n  baseUri?: string\n): string | string[] | undefined {\n  if (options?.credentialScopes) {\n    const scopes = options.credentialScopes;\n    return Array.isArray(scopes)\n      ? scopes.map((scope) => new URL(scope).toString())\n      : new URL(scopes).toString();\n  }\n\n  if (baseUri) {\n    return `${baseUri}/.default`;\n  }\n  return undefined;\n}\n"]},"metadata":{},"sourceType":"module"}