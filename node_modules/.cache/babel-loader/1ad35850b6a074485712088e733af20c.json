{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { logger } from \"../logger\";\nimport { terminalStates } from \"./constants\";\n/**\n * Deserializes the state\n */\nexport function deserializeState(serializedState) {\n  try {\n    return JSON.parse(serializedState).state;\n  } catch (e) {\n    throw new Error(`Unable to deserialize input state: ${serializedState}`);\n  }\n}\nfunction setStateError(inputs) {\n  const {\n    state,\n    stateProxy\n  } = inputs;\n  return error => {\n    stateProxy.setError(state, error);\n    stateProxy.setFailed(state);\n    throw error;\n  };\n}\nfunction processOperationStatus(result) {\n  const {\n    state,\n    stateProxy,\n    status,\n    isDone,\n    processResult,\n    response,\n    setErrorAsResult\n  } = result;\n  switch (status) {\n    case \"succeeded\":\n      {\n        stateProxy.setSucceeded(state);\n        break;\n      }\n    case \"failed\":\n      {\n        stateProxy.setError(state, new Error(`The long-running operation has failed`));\n        stateProxy.setFailed(state);\n        break;\n      }\n    case \"canceled\":\n      {\n        stateProxy.setCanceled(state);\n        break;\n      }\n  }\n  if ((isDone === null || isDone === void 0 ? void 0 : isDone(response, state)) || isDone === undefined && [\"succeeded\", \"canceled\"].concat(setErrorAsResult ? [] : [\"failed\"]).includes(status)) {\n    stateProxy.setResult(state, buildResult({\n      response,\n      state,\n      processResult\n    }));\n  }\n}\nfunction buildResult(inputs) {\n  const {\n    processResult,\n    response,\n    state\n  } = inputs;\n  return processResult ? processResult(response, state) : response;\n}\n/**\n * Initiates the long-running operation.\n */\nexport async function initOperation(inputs) {\n  const {\n    init,\n    stateProxy,\n    processResult,\n    getOperationStatus,\n    withOperationLocation,\n    setErrorAsResult\n  } = inputs;\n  const {\n    operationLocation,\n    resourceLocation,\n    metadata,\n    response\n  } = await init();\n  if (operationLocation) withOperationLocation === null || withOperationLocation === void 0 ? void 0 : withOperationLocation(operationLocation, false);\n  const config = {\n    metadata,\n    operationLocation,\n    resourceLocation\n  };\n  logger.verbose(`LRO: Operation description:`, config);\n  const state = stateProxy.initState(config);\n  const status = getOperationStatus({\n    response,\n    state,\n    operationLocation\n  });\n  processOperationStatus({\n    state,\n    status,\n    stateProxy,\n    response,\n    setErrorAsResult,\n    processResult\n  });\n  return state;\n}\nasync function pollOperationHelper(inputs) {\n  const {\n    poll,\n    state,\n    stateProxy,\n    operationLocation,\n    getOperationStatus,\n    getResourceLocation,\n    options\n  } = inputs;\n  const response = await poll(operationLocation, options).catch(setStateError({\n    state,\n    stateProxy\n  }));\n  const status = getOperationStatus(response, state);\n  logger.verbose(`LRO: Status:\\n\\tPolling from: ${state.config.operationLocation}\\n\\tOperation status: ${status}\\n\\tPolling status: ${terminalStates.includes(status) ? \"Stopped\" : \"Running\"}`);\n  if (status === \"succeeded\") {\n    const resourceLocation = getResourceLocation(response, state);\n    if (resourceLocation !== undefined) {\n      return {\n        response: await poll(resourceLocation).catch(setStateError({\n          state,\n          stateProxy\n        })),\n        status\n      };\n    }\n  }\n  return {\n    response,\n    status\n  };\n}\n/** Polls the long-running operation. */\nexport async function pollOperation(inputs) {\n  const {\n    poll,\n    state,\n    stateProxy,\n    options,\n    getOperationStatus,\n    getResourceLocation,\n    getOperationLocation,\n    withOperationLocation,\n    getPollingInterval,\n    processResult,\n    updateState,\n    setDelay,\n    isDone,\n    setErrorAsResult\n  } = inputs;\n  const {\n    operationLocation\n  } = state.config;\n  if (operationLocation !== undefined) {\n    const {\n      response,\n      status\n    } = await pollOperationHelper({\n      poll,\n      getOperationStatus,\n      state,\n      stateProxy,\n      operationLocation,\n      getResourceLocation,\n      options\n    });\n    processOperationStatus({\n      status,\n      response,\n      state,\n      stateProxy,\n      isDone,\n      processResult,\n      setErrorAsResult\n    });\n    if (!terminalStates.includes(status)) {\n      const intervalInMs = getPollingInterval === null || getPollingInterval === void 0 ? void 0 : getPollingInterval(response);\n      if (intervalInMs) setDelay(intervalInMs);\n      const location = getOperationLocation === null || getOperationLocation === void 0 ? void 0 : getOperationLocation(response, state);\n      if (location !== undefined) {\n        const isUpdated = operationLocation !== location;\n        state.config.operationLocation = location;\n        withOperationLocation === null || withOperationLocation === void 0 ? void 0 : withOperationLocation(location, isUpdated);\n      } else withOperationLocation === null || withOperationLocation === void 0 ? void 0 : withOperationLocation(operationLocation, false);\n    }\n    updateState === null || updateState === void 0 ? void 0 : updateState(state, response);\n  }\n}","map":{"version":3,"mappings":"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","names":["logger","terminalStates","deserializeState","serializedState","JSON","parse","state","e","Error","setStateError","inputs","stateProxy","error","setError","setFailed","processOperationStatus","result","status","isDone","processResult","response","setErrorAsResult","setSucceeded","setCanceled","undefined","concat","includes","setResult","buildResult","initOperation","init","getOperationStatus","withOperationLocation","operationLocation","resourceLocation","metadata","config","verbose","initState","pollOperationHelper","poll","getResourceLocation","options","catch","pollOperation","getOperationLocation","getPollingInterval","updateState","setDelay","intervalInMs","location","isUpdated"],"sourceRoot":"","sources":["../../../src/poller/operation.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { Operation, OperationStatus, RestorableOperationState, StateProxy } from \"./models\";\nimport { logger } from \"../logger\";\nimport { terminalStates } from \"./constants\";\n\n/**\n * Deserializes the state\n */\nexport function deserializeState<TState>(\n  serializedState: string\n): RestorableOperationState<TState> {\n  try {\n    return JSON.parse(serializedState).state;\n  } catch (e) {\n    throw new Error(`Unable to deserialize input state: ${serializedState}`);\n  }\n}\n\nfunction setStateError<TState, TResult>(inputs: {\n  state: TState;\n  stateProxy: StateProxy<TState, TResult>;\n}): (error: Error) => never {\n  const { state, stateProxy } = inputs;\n  return (error: Error) => {\n    stateProxy.setError(state, error);\n    stateProxy.setFailed(state);\n    throw error;\n  };\n}\n\nfunction processOperationStatus<TState, TResult, TResponse>(result: {\n  status: OperationStatus;\n  response: TResponse;\n  state: RestorableOperationState<TState>;\n  stateProxy: StateProxy<TState, TResult>;\n  processResult?: (result: TResponse, state: TState) => TResult;\n  isDone?: (lastResponse: TResponse, state: TState) => boolean;\n  setErrorAsResult: boolean;\n}): void {\n  const { state, stateProxy, status, isDone, processResult, response, setErrorAsResult } = result;\n  switch (status) {\n    case \"succeeded\": {\n      stateProxy.setSucceeded(state);\n      break;\n    }\n    case \"failed\": {\n      stateProxy.setError(state, new Error(`The long-running operation has failed`));\n      stateProxy.setFailed(state);\n      break;\n    }\n    case \"canceled\": {\n      stateProxy.setCanceled(state);\n      break;\n    }\n  }\n  if (\n    isDone?.(response, state) ||\n    (isDone === undefined &&\n      [\"succeeded\", \"canceled\"].concat(setErrorAsResult ? [] : [\"failed\"]).includes(status))\n  ) {\n    stateProxy.setResult(\n      state,\n      buildResult({\n        response,\n        state,\n        processResult,\n      })\n    );\n  }\n}\n\nfunction buildResult<TResponse, TResult, TState>(inputs: {\n  response: TResponse;\n  state: TState;\n  processResult?: (result: TResponse, state: TState) => TResult;\n}): TResult {\n  const { processResult, response, state } = inputs;\n  return processResult ? processResult(response, state) : (response as unknown as TResult);\n}\n\n/**\n * Initiates the long-running operation.\n */\nexport async function initOperation<TResponse, TResult, TState>(inputs: {\n  init: Operation<TResponse, unknown>[\"init\"];\n  stateProxy: StateProxy<TState, TResult>;\n  getOperationStatus: (inputs: {\n    response: TResponse;\n    state: RestorableOperationState<TState>;\n    operationLocation?: string;\n  }) => OperationStatus;\n  processResult?: (result: TResponse, state: TState) => TResult;\n  withOperationLocation?: (operationLocation: string, isUpdated: boolean) => void;\n  setErrorAsResult: boolean;\n}): Promise<RestorableOperationState<TState>> {\n  const {\n    init,\n    stateProxy,\n    processResult,\n    getOperationStatus,\n    withOperationLocation,\n    setErrorAsResult,\n  } = inputs;\n  const { operationLocation, resourceLocation, metadata, response } = await init();\n  if (operationLocation) withOperationLocation?.(operationLocation, false);\n  const config = {\n    metadata,\n    operationLocation,\n    resourceLocation,\n  };\n  logger.verbose(`LRO: Operation description:`, config);\n  const state = stateProxy.initState(config);\n  const status = getOperationStatus({ response, state, operationLocation });\n  processOperationStatus({ state, status, stateProxy, response, setErrorAsResult, processResult });\n  return state;\n}\n\nasync function pollOperationHelper<TResponse, TState, TResult, TOptions>(inputs: {\n  poll: Operation<TResponse, TOptions>[\"poll\"];\n  stateProxy: StateProxy<TState, TResult>;\n  state: RestorableOperationState<TState>;\n  operationLocation: string;\n  getOperationStatus: (\n    response: TResponse,\n    state: RestorableOperationState<TState>\n  ) => OperationStatus;\n  getResourceLocation: (\n    response: TResponse,\n    state: RestorableOperationState<TState>\n  ) => string | undefined;\n  options?: TOptions;\n}): Promise<{\n  status: OperationStatus;\n  response: TResponse;\n}> {\n  const {\n    poll,\n    state,\n    stateProxy,\n    operationLocation,\n    getOperationStatus,\n    getResourceLocation,\n    options,\n  } = inputs;\n  const response = await poll(operationLocation, options).catch(\n    setStateError({\n      state,\n      stateProxy,\n    })\n  );\n  const status = getOperationStatus(response, state);\n  logger.verbose(\n    `LRO: Status:\\n\\tPolling from: ${\n      state.config.operationLocation\n    }\\n\\tOperation status: ${status}\\n\\tPolling status: ${\n      terminalStates.includes(status) ? \"Stopped\" : \"Running\"\n    }`\n  );\n  if (status === \"succeeded\") {\n    const resourceLocation = getResourceLocation(response, state);\n    if (resourceLocation !== undefined) {\n      return {\n        response: await poll(resourceLocation).catch(setStateError({ state, stateProxy })),\n        status,\n      };\n    }\n  }\n  return { response, status };\n}\n\n/** Polls the long-running operation. */\nexport async function pollOperation<TResponse, TState, TResult, TOptions>(inputs: {\n  poll: Operation<TResponse, TOptions>[\"poll\"];\n  stateProxy: StateProxy<TState, TResult>;\n  state: RestorableOperationState<TState>;\n  getOperationStatus: (\n    response: TResponse,\n    state: RestorableOperationState<TState>\n  ) => OperationStatus;\n  getResourceLocation: (\n    response: TResponse,\n    state: RestorableOperationState<TState>\n  ) => string | undefined;\n  getPollingInterval?: (response: TResponse) => number | undefined;\n  setDelay: (intervalInMs: number) => void;\n  getOperationLocation?: (\n    response: TResponse,\n    state: RestorableOperationState<TState>\n  ) => string | undefined;\n  withOperationLocation?: (operationLocation: string, isUpdated: boolean) => void;\n  processResult?: (result: TResponse, state: TState) => TResult;\n  updateState?: (state: TState, lastResponse: TResponse) => void;\n  isDone?: (lastResponse: TResponse, state: TState) => boolean;\n  setErrorAsResult: boolean;\n  options?: TOptions;\n}): Promise<void> {\n  const {\n    poll,\n    state,\n    stateProxy,\n    options,\n    getOperationStatus,\n    getResourceLocation,\n    getOperationLocation,\n    withOperationLocation,\n    getPollingInterval,\n    processResult,\n    updateState,\n    setDelay,\n    isDone,\n    setErrorAsResult,\n  } = inputs;\n  const { operationLocation } = state.config;\n  if (operationLocation !== undefined) {\n    const { response, status } = await pollOperationHelper({\n      poll,\n      getOperationStatus,\n      state,\n      stateProxy,\n      operationLocation,\n      getResourceLocation,\n      options,\n    });\n    processOperationStatus({\n      status,\n      response,\n      state,\n      stateProxy,\n      isDone,\n      processResult,\n      setErrorAsResult,\n    });\n\n    if (!terminalStates.includes(status)) {\n      const intervalInMs = getPollingInterval?.(response);\n      if (intervalInMs) setDelay(intervalInMs);\n      const location = getOperationLocation?.(response, state);\n      if (location !== undefined) {\n        const isUpdated = operationLocation !== location;\n        state.config.operationLocation = location;\n        withOperationLocation?.(location, isUpdated);\n      } else withOperationLocation?.(operationLocation, false);\n    }\n    updateState?.(state, response);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}