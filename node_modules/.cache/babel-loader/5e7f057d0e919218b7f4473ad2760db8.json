{"ast":null,"code":"import _defineProperty from \"/Users/tbeckett/Documents/Azure dev/Azure Test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _createForOfIteratorHelper from \"/Users/tbeckett/Documents/Azure dev/Azure Test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _asyncToGenerator from \"/Users/tbeckett/Documents/Azure dev/Azure Test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/tbeckett/Documents/Azure dev/Azure Test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/tbeckett/Documents/Azure dev/Azure Test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/tbeckett/Documents/Azure dev/Azure Test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/tbeckett/Documents/Azure dev/Azure Test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nimport { __asyncDelegator, __asyncGenerator, __asyncValues, __await } from \"tslib\";\nimport { getDefaultProxySettings, isNode, isTokenCredential, URLBuilder } from \"@azure/core-http\";\nimport { SpanStatusCode } from \"@azure/core-tracing\";\nimport { AnonymousCredential } from \"./credentials/AnonymousCredential\";\nimport { StorageSharedKeyCredential } from \"./credentials/StorageSharedKeyCredential\";\nimport { Container } from \"./generated/src/operations\";\nimport { newPipeline, isPipelineLike } from \"./Pipeline\";\nimport { StorageClient } from \"./StorageClient\";\nimport { convertTracingToRequestOptionsBase, createSpan } from \"./utils/tracing\";\nimport { appendToURLPath, appendToURLQuery, BlobNameToString, ConvertInternalResponseOfListBlobFlat, ConvertInternalResponseOfListBlobHierarchy, EscapePath, extractConnectionStringParts, isIpEndpointStyle, parseObjectReplicationRecord, ProcessBlobItems, ProcessBlobPrefixes, toTags, truncatedISO8061Date } from \"./utils/utils.common\";\nimport { generateBlobSASQueryParameters } from \"./sas/BlobSASSignatureValues\";\nimport { BlobLeaseClient } from \"./BlobLeaseClient\";\nimport { AppendBlobClient, BlobClient, BlockBlobClient, PageBlobClient } from \"./Clients\";\nimport { BlobBatchClient } from \"./BlobBatchClient\";\n/**\n * A ContainerClient represents a URL to the Azure Storage container allowing you to manipulate its blobs.\n */\nexport var ContainerClient = /*#__PURE__*/function (_StorageClient) {\n  _inherits(ContainerClient, _StorageClient);\n  var _super = _createSuper(ContainerClient);\n  function ContainerClient(urlOrConnectionString, credentialOrPipelineOrContainerName,\n  // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n  /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n  options) {\n    var _this;\n    _classCallCheck(this, ContainerClient);\n    var pipeline;\n    var url;\n    options = options || {};\n    if (isPipelineLike(credentialOrPipelineOrContainerName)) {\n      // (url: string, pipeline: Pipeline)\n      url = urlOrConnectionString;\n      pipeline = credentialOrPipelineOrContainerName;\n    } else if (isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential || isTokenCredential(credentialOrPipelineOrContainerName)) {\n      // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n      url = urlOrConnectionString;\n      pipeline = newPipeline(credentialOrPipelineOrContainerName, options);\n    } else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== \"string\") {\n      // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n      // The second parameter is undefined. Use anonymous credential.\n      url = urlOrConnectionString;\n      pipeline = newPipeline(new AnonymousCredential(), options);\n    } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === \"string\") {\n      // (connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions)\n      var containerName = credentialOrPipelineOrContainerName;\n      var extractedCreds = extractConnectionStringParts(urlOrConnectionString);\n      if (extractedCreds.kind === \"AccountConnString\") {\n        if (isNode) {\n          var sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);\n          url = appendToURLPath(extractedCreds.url, encodeURIComponent(containerName));\n          if (!options.proxyOptions) {\n            options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);\n          }\n          pipeline = newPipeline(sharedKeyCredential, options);\n        } else {\n          throw new Error(\"Account connection string is only supported in Node.js environment\");\n        }\n      } else if (extractedCreds.kind === \"SASConnString\") {\n        url = appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)) + \"?\" + extractedCreds.accountSas;\n        pipeline = newPipeline(new AnonymousCredential(), options);\n      } else {\n        throw new Error(\"Connection string must be either an Account connection string or a SAS connection string\");\n      }\n    } else {\n      throw new Error(\"Expecting non-empty strings for containerName parameter\");\n    }\n    _this = _super.call(this, url, pipeline);\n    _this._containerName = _this.getContainerNameFromUrl();\n    _this.containerContext = new Container(_this.storageClientContext);\n    return _this;\n  }\n  /**\n   * The name of the container.\n   */\n  _createClass(ContainerClient, [{\n    key: \"containerName\",\n    get: function get() {\n      return this._containerName;\n    }\n    /**\n     * Creates a new container under the specified account. If the container with\n     * the same name already exists, the operation fails.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-container\n     *\n     * @param options - Options to Container Create operation.\n     *\n     *\n     * Example usage:\n     *\n     * ```js\n     * const containerClient = blobServiceClient.getContainerClient(\"<container name>\");\n     * const createContainerResponse = await containerClient.create();\n     * console.log(\"Container was created successfully\", createContainerResponse.requestId);\n     * ```\n     */\n  }, {\n    key: \"create\",\n    value: function () {\n      var _create = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var options,\n          _createSpan,\n          span,\n          updatedOptions,\n          _args = arguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                options = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};\n                _createSpan = createSpan(\"ContainerClient-create\", options), span = _createSpan.span, updatedOptions = _createSpan.updatedOptions;\n                _context.prev = 2;\n                _context.next = 5;\n                return this.containerContext.create(Object.assign(Object.assign({}, options), convertTracingToRequestOptionsBase(updatedOptions)));\n              case 5:\n                return _context.abrupt(\"return\", _context.sent);\n              case 8:\n                _context.prev = 8;\n                _context.t0 = _context[\"catch\"](2);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context.t0.message\n                });\n                throw _context.t0;\n              case 12:\n                _context.prev = 12;\n                span.end();\n                return _context.finish(12);\n              case 15:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[2, 8, 12, 15]]);\n      }));\n      function create() {\n        return _create.apply(this, arguments);\n      }\n      return create;\n    }()\n    /**\n     * Creates a new container under the specified account. If the container with\n     * the same name already exists, it is not changed.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-container\n     *\n     * @param options -\n     */\n  }, {\n    key: \"createIfNotExists\",\n    value: function () {\n      var _createIfNotExists = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var options,\n          _a,\n          _b,\n          _createSpan2,\n          span,\n          updatedOptions,\n          res,\n          _args2 = arguments;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                options = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};\n                _createSpan2 = createSpan(\"ContainerClient-createIfNotExists\", options), span = _createSpan2.span, updatedOptions = _createSpan2.updatedOptions;\n                _context2.prev = 2;\n                _context2.next = 5;\n                return this.create(updatedOptions);\n              case 5:\n                res = _context2.sent;\n                return _context2.abrupt(\"return\", Object.assign(Object.assign({\n                  succeeded: true\n                }, res), {\n                  _response: res._response\n                }));\n              case 9:\n                _context2.prev = 9;\n                _context2.t0 = _context2[\"catch\"](2);\n                if (!(((_a = _context2.t0.details) === null || _a === void 0 ? void 0 : _a.errorCode) === \"ContainerAlreadyExists\")) {\n                  _context2.next = 14;\n                  break;\n                }\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: \"Expected exception when creating a container only if it does not already exist.\"\n                });\n                return _context2.abrupt(\"return\", Object.assign(Object.assign({\n                  succeeded: false\n                }, (_b = _context2.t0.response) === null || _b === void 0 ? void 0 : _b.parsedHeaders), {\n                  _response: _context2.t0.response\n                }));\n              case 14:\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context2.t0.message\n                });\n                throw _context2.t0;\n              case 16:\n                _context2.prev = 16;\n                span.end();\n                return _context2.finish(16);\n              case 19:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[2, 9, 16, 19]]);\n      }));\n      function createIfNotExists() {\n        return _createIfNotExists.apply(this, arguments);\n      }\n      return createIfNotExists;\n    }()\n    /**\n     * Returns true if the Azure container resource represented by this client exists; false otherwise.\n     *\n     * NOTE: use this function with care since an existing container might be deleted by other clients or\n     * applications. Vice versa new containers with the same name might be added by other clients or\n     * applications after this function completes.\n     *\n     * @param options -\n     */\n  }, {\n    key: \"exists\",\n    value: function () {\n      var _exists = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var options,\n          _createSpan3,\n          span,\n          updatedOptions,\n          _args3 = arguments;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                options = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : {};\n                _createSpan3 = createSpan(\"ContainerClient-exists\", options), span = _createSpan3.span, updatedOptions = _createSpan3.updatedOptions;\n                _context3.prev = 2;\n                _context3.next = 5;\n                return this.getProperties({\n                  abortSignal: options.abortSignal,\n                  tracingOptions: updatedOptions.tracingOptions\n                });\n              case 5:\n                return _context3.abrupt(\"return\", true);\n              case 8:\n                _context3.prev = 8;\n                _context3.t0 = _context3[\"catch\"](2);\n                if (!(_context3.t0.statusCode === 404)) {\n                  _context3.next = 13;\n                  break;\n                }\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: \"Expected exception when checking container existence\"\n                });\n                return _context3.abrupt(\"return\", false);\n              case 13:\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context3.t0.message\n                });\n                throw _context3.t0;\n              case 15:\n                _context3.prev = 15;\n                span.end();\n                return _context3.finish(15);\n              case 18:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[2, 8, 15, 18]]);\n      }));\n      function exists() {\n        return _exists.apply(this, arguments);\n      }\n      return exists;\n    }()\n    /**\n     * Creates a {@link BlobClient}\n     *\n     * @param blobName - A blob name\n     * @returns A new BlobClient object for the given blob name.\n     */\n  }, {\n    key: \"getBlobClient\",\n    value: function getBlobClient(blobName) {\n      return new BlobClient(appendToURLPath(this.url, EscapePath(blobName)), this.pipeline);\n    }\n    /**\n     * Creates an {@link AppendBlobClient}\n     *\n     * @param blobName - An append blob name\n     */\n  }, {\n    key: \"getAppendBlobClient\",\n    value: function getAppendBlobClient(blobName) {\n      return new AppendBlobClient(appendToURLPath(this.url, EscapePath(blobName)), this.pipeline);\n    }\n    /**\n     * Creates a {@link BlockBlobClient}\n     *\n     * @param blobName - A block blob name\n     *\n     *\n     * Example usage:\n     *\n     * ```js\n     * const content = \"Hello world!\";\n     *\n     * const blockBlobClient = containerClient.getBlockBlobClient(\"<blob name>\");\n     * const uploadBlobResponse = await blockBlobClient.upload(content, content.length);\n     * ```\n     */\n  }, {\n    key: \"getBlockBlobClient\",\n    value: function getBlockBlobClient(blobName) {\n      return new BlockBlobClient(appendToURLPath(this.url, EscapePath(blobName)), this.pipeline);\n    }\n    /**\n     * Creates a {@link PageBlobClient}\n     *\n     * @param blobName - A page blob name\n     */\n  }, {\n    key: \"getPageBlobClient\",\n    value: function getPageBlobClient(blobName) {\n      return new PageBlobClient(appendToURLPath(this.url, EscapePath(blobName)), this.pipeline);\n    }\n    /**\n     * Returns all user-defined metadata and system properties for the specified\n     * container. The data returned does not include the container's list of blobs.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-container-properties\n     *\n     * WARNING: The `metadata` object returned in the response will have its keys in lowercase, even if\n     * they originally contained uppercase characters. This differs from the metadata keys returned by\n     * the `listContainers` method of {@link BlobServiceClient} using the `includeMetadata` option, which\n     * will retain their original casing.\n     *\n     * @param options - Options to Container Get Properties operation.\n     */\n  }, {\n    key: \"getProperties\",\n    value: function () {\n      var _getProperties = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var options,\n          _createSpan4,\n          span,\n          updatedOptions,\n          _args4 = arguments;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                options = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : {};\n                if (!options.conditions) {\n                  options.conditions = {};\n                }\n                _createSpan4 = createSpan(\"ContainerClient-getProperties\", options), span = _createSpan4.span, updatedOptions = _createSpan4.updatedOptions;\n                _context4.prev = 3;\n                _context4.next = 6;\n                return this.containerContext.getProperties(Object.assign(Object.assign({\n                  abortSignal: options.abortSignal\n                }, options.conditions), convertTracingToRequestOptionsBase(updatedOptions)));\n              case 6:\n                return _context4.abrupt(\"return\", _context4.sent);\n              case 9:\n                _context4.prev = 9;\n                _context4.t0 = _context4[\"catch\"](3);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context4.t0.message\n                });\n                throw _context4.t0;\n              case 13:\n                _context4.prev = 13;\n                span.end();\n                return _context4.finish(13);\n              case 16:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[3, 9, 13, 16]]);\n      }));\n      function getProperties() {\n        return _getProperties.apply(this, arguments);\n      }\n      return getProperties;\n    }()\n    /**\n     * Marks the specified container for deletion. The container and any blobs\n     * contained within it are later deleted during garbage collection.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-container\n     *\n     * @param options - Options to Container Delete operation.\n     */\n  }, {\n    key: \"delete\",\n    value: function () {\n      var _delete2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var options,\n          _createSpan5,\n          span,\n          updatedOptions,\n          _args5 = arguments;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                options = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : {};\n                if (!options.conditions) {\n                  options.conditions = {};\n                }\n                _createSpan5 = createSpan(\"ContainerClient-delete\", options), span = _createSpan5.span, updatedOptions = _createSpan5.updatedOptions;\n                _context5.prev = 3;\n                _context5.next = 6;\n                return this.containerContext.delete(Object.assign({\n                  abortSignal: options.abortSignal,\n                  leaseAccessConditions: options.conditions,\n                  modifiedAccessConditions: options.conditions\n                }, convertTracingToRequestOptionsBase(updatedOptions)));\n              case 6:\n                return _context5.abrupt(\"return\", _context5.sent);\n              case 9:\n                _context5.prev = 9;\n                _context5.t0 = _context5[\"catch\"](3);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context5.t0.message\n                });\n                throw _context5.t0;\n              case 13:\n                _context5.prev = 13;\n                span.end();\n                return _context5.finish(13);\n              case 16:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[3, 9, 13, 16]]);\n      }));\n      function _delete() {\n        return _delete2.apply(this, arguments);\n      }\n      return _delete;\n    }()\n    /**\n     * Marks the specified container for deletion if it exists. The container and any blobs\n     * contained within it are later deleted during garbage collection.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-container\n     *\n     * @param options - Options to Container Delete operation.\n     */\n  }, {\n    key: \"deleteIfExists\",\n    value: function () {\n      var _deleteIfExists = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        var options,\n          _a,\n          _b,\n          _createSpan6,\n          span,\n          updatedOptions,\n          res,\n          _args6 = arguments;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                options = _args6.length > 0 && _args6[0] !== undefined ? _args6[0] : {};\n                _createSpan6 = createSpan(\"ContainerClient-deleteIfExists\", options), span = _createSpan6.span, updatedOptions = _createSpan6.updatedOptions;\n                _context6.prev = 2;\n                _context6.next = 5;\n                return this.delete(updatedOptions);\n              case 5:\n                res = _context6.sent;\n                return _context6.abrupt(\"return\", Object.assign(Object.assign({\n                  succeeded: true\n                }, res), {\n                  _response: res._response\n                }));\n              case 9:\n                _context6.prev = 9;\n                _context6.t0 = _context6[\"catch\"](2);\n                if (!(((_a = _context6.t0.details) === null || _a === void 0 ? void 0 : _a.errorCode) === \"ContainerNotFound\")) {\n                  _context6.next = 14;\n                  break;\n                }\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: \"Expected exception when deleting a container only if it exists.\"\n                });\n                return _context6.abrupt(\"return\", Object.assign(Object.assign({\n                  succeeded: false\n                }, (_b = _context6.t0.response) === null || _b === void 0 ? void 0 : _b.parsedHeaders), {\n                  _response: _context6.t0.response\n                }));\n              case 14:\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context6.t0.message\n                });\n                throw _context6.t0;\n              case 16:\n                _context6.prev = 16;\n                span.end();\n                return _context6.finish(16);\n              case 19:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this, [[2, 9, 16, 19]]);\n      }));\n      function deleteIfExists() {\n        return _deleteIfExists.apply(this, arguments);\n      }\n      return deleteIfExists;\n    }()\n    /**\n     * Sets one or more user-defined name-value pairs for the specified container.\n     *\n     * If no option provided, or no metadata defined in the parameter, the container\n     * metadata will be removed.\n     *\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-container-metadata\n     *\n     * @param metadata - Replace existing metadata with this value.\n     *                            If no value provided the existing metadata will be removed.\n     * @param options - Options to Container Set Metadata operation.\n     */\n  }, {\n    key: \"setMetadata\",\n    value: function () {\n      var _setMetadata = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(metadata) {\n        var options,\n          _createSpan7,\n          span,\n          updatedOptions,\n          _args7 = arguments;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                options = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : {};\n                if (!options.conditions) {\n                  options.conditions = {};\n                }\n                if (!options.conditions.ifUnmodifiedSince) {\n                  _context7.next = 4;\n                  break;\n                }\n                throw new RangeError(\"the IfUnmodifiedSince must have their default values because they are ignored by the blob service\");\n              case 4:\n                _createSpan7 = createSpan(\"ContainerClient-setMetadata\", options), span = _createSpan7.span, updatedOptions = _createSpan7.updatedOptions;\n                _context7.prev = 5;\n                _context7.next = 8;\n                return this.containerContext.setMetadata(Object.assign({\n                  abortSignal: options.abortSignal,\n                  leaseAccessConditions: options.conditions,\n                  metadata: metadata,\n                  modifiedAccessConditions: options.conditions\n                }, convertTracingToRequestOptionsBase(updatedOptions)));\n              case 8:\n                return _context7.abrupt(\"return\", _context7.sent);\n              case 11:\n                _context7.prev = 11;\n                _context7.t0 = _context7[\"catch\"](5);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context7.t0.message\n                });\n                throw _context7.t0;\n              case 15:\n                _context7.prev = 15;\n                span.end();\n                return _context7.finish(15);\n              case 18:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[5, 11, 15, 18]]);\n      }));\n      function setMetadata(_x) {\n        return _setMetadata.apply(this, arguments);\n      }\n      return setMetadata;\n    }()\n    /**\n     * Gets the permissions for the specified container. The permissions indicate\n     * whether container data may be accessed publicly.\n     *\n     * WARNING: JavaScript Date will potentially lose precision when parsing startsOn and expiresOn strings.\n     * For example, new Date(\"2018-12-31T03:44:23.8827891Z\").toISOString() will get \"2018-12-31T03:44:23.882Z\".\n     *\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-container-acl\n     *\n     * @param options - Options to Container Get Access Policy operation.\n     */\n  }, {\n    key: \"getAccessPolicy\",\n    value: function () {\n      var _getAccessPolicy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n        var options,\n          _createSpan8,\n          span,\n          updatedOptions,\n          response,\n          res,\n          _iterator,\n          _step,\n          identifier,\n          accessPolicy,\n          _args8 = arguments;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                options = _args8.length > 0 && _args8[0] !== undefined ? _args8[0] : {};\n                if (!options.conditions) {\n                  options.conditions = {};\n                }\n                _createSpan8 = createSpan(\"ContainerClient-getAccessPolicy\", options), span = _createSpan8.span, updatedOptions = _createSpan8.updatedOptions;\n                _context8.prev = 3;\n                _context8.next = 6;\n                return this.containerContext.getAccessPolicy(Object.assign({\n                  abortSignal: options.abortSignal,\n                  leaseAccessConditions: options.conditions\n                }, convertTracingToRequestOptionsBase(updatedOptions)));\n              case 6:\n                response = _context8.sent;\n                res = {\n                  _response: response._response,\n                  blobPublicAccess: response.blobPublicAccess,\n                  date: response.date,\n                  etag: response.etag,\n                  errorCode: response.errorCode,\n                  lastModified: response.lastModified,\n                  requestId: response.requestId,\n                  clientRequestId: response.clientRequestId,\n                  signedIdentifiers: [],\n                  version: response.version\n                };\n                _iterator = _createForOfIteratorHelper(response);\n                try {\n                  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                    identifier = _step.value;\n                    accessPolicy = undefined;\n                    if (identifier.accessPolicy) {\n                      accessPolicy = {\n                        permissions: identifier.accessPolicy.permissions\n                      };\n                      if (identifier.accessPolicy.expiresOn) {\n                        accessPolicy.expiresOn = new Date(identifier.accessPolicy.expiresOn);\n                      }\n                      if (identifier.accessPolicy.startsOn) {\n                        accessPolicy.startsOn = new Date(identifier.accessPolicy.startsOn);\n                      }\n                    }\n                    res.signedIdentifiers.push({\n                      accessPolicy: accessPolicy,\n                      id: identifier.id\n                    });\n                  }\n                } catch (err) {\n                  _iterator.e(err);\n                } finally {\n                  _iterator.f();\n                }\n                return _context8.abrupt(\"return\", res);\n              case 13:\n                _context8.prev = 13;\n                _context8.t0 = _context8[\"catch\"](3);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context8.t0.message\n                });\n                throw _context8.t0;\n              case 17:\n                _context8.prev = 17;\n                span.end();\n                return _context8.finish(17);\n              case 20:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this, [[3, 13, 17, 20]]);\n      }));\n      function getAccessPolicy() {\n        return _getAccessPolicy.apply(this, arguments);\n      }\n      return getAccessPolicy;\n    }()\n    /**\n     * Sets the permissions for the specified container. The permissions indicate\n     * whether blobs in a container may be accessed publicly.\n     *\n     * When you set permissions for a container, the existing permissions are replaced.\n     * If no access or containerAcl provided, the existing container ACL will be\n     * removed.\n     *\n     * When you establish a stored access policy on a container, it may take up to 30 seconds to take effect.\n     * During this interval, a shared access signature that is associated with the stored access policy will\n     * fail with status code 403 (Forbidden), until the access policy becomes active.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-container-acl\n     *\n     * @param access - The level of public access to data in the container.\n     * @param containerAcl - Array of elements each having a unique Id and details of the access policy.\n     * @param options - Options to Container Set Access Policy operation.\n     */\n  }, {\n    key: \"setAccessPolicy\",\n    value: function () {\n      var _setAccessPolicy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(access, containerAcl) {\n        var options,\n          _createSpan9,\n          span,\n          updatedOptions,\n          acl,\n          _iterator2,\n          _step2,\n          identifier,\n          _args9 = arguments;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                options = _args9.length > 2 && _args9[2] !== undefined ? _args9[2] : {};\n                options.conditions = options.conditions || {};\n                _createSpan9 = createSpan(\"ContainerClient-setAccessPolicy\", options), span = _createSpan9.span, updatedOptions = _createSpan9.updatedOptions;\n                _context9.prev = 3;\n                acl = [];\n                _iterator2 = _createForOfIteratorHelper(containerAcl || []);\n                try {\n                  for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                    identifier = _step2.value;\n                    acl.push({\n                      accessPolicy: {\n                        expiresOn: identifier.accessPolicy.expiresOn ? truncatedISO8061Date(identifier.accessPolicy.expiresOn) : \"\",\n                        permissions: identifier.accessPolicy.permissions,\n                        startsOn: identifier.accessPolicy.startsOn ? truncatedISO8061Date(identifier.accessPolicy.startsOn) : \"\"\n                      },\n                      id: identifier.id\n                    });\n                  }\n                } catch (err) {\n                  _iterator2.e(err);\n                } finally {\n                  _iterator2.f();\n                }\n                _context9.next = 9;\n                return this.containerContext.setAccessPolicy(Object.assign({\n                  abortSignal: options.abortSignal,\n                  access: access,\n                  containerAcl: acl,\n                  leaseAccessConditions: options.conditions,\n                  modifiedAccessConditions: options.conditions\n                }, convertTracingToRequestOptionsBase(updatedOptions)));\n              case 9:\n                return _context9.abrupt(\"return\", _context9.sent);\n              case 12:\n                _context9.prev = 12;\n                _context9.t0 = _context9[\"catch\"](3);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context9.t0.message\n                });\n                throw _context9.t0;\n              case 16:\n                _context9.prev = 16;\n                span.end();\n                return _context9.finish(16);\n              case 19:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this, [[3, 12, 16, 19]]);\n      }));\n      function setAccessPolicy(_x2, _x3) {\n        return _setAccessPolicy.apply(this, arguments);\n      }\n      return setAccessPolicy;\n    }()\n    /**\n     * Get a {@link BlobLeaseClient} that manages leases on the container.\n     *\n     * @param proposeLeaseId - Initial proposed lease Id.\n     * @returns A new BlobLeaseClient object for managing leases on the container.\n     */\n  }, {\n    key: \"getBlobLeaseClient\",\n    value: function getBlobLeaseClient(proposeLeaseId) {\n      return new BlobLeaseClient(this, proposeLeaseId);\n    }\n    /**\n     * Creates a new block blob, or updates the content of an existing block blob.\n     *\n     * Updating an existing block blob overwrites any existing metadata on the blob.\n     * Partial updates are not supported; the content of the existing blob is\n     * overwritten with the new content. To perform a partial update of a block blob's,\n     * use {@link BlockBlobClient.stageBlock} and {@link BlockBlobClient.commitBlockList}.\n     *\n     * This is a non-parallel uploading method, please use {@link BlockBlobClient.uploadFile},\n     * {@link BlockBlobClient.uploadStream} or {@link BlockBlobClient.uploadBrowserData} for better\n     * performance with concurrency uploading.\n     *\n     * @see https://docs.microsoft.com/rest/api/storageservices/put-blob\n     *\n     * @param blobName - Name of the block blob to create or update.\n     * @param body - Blob, string, ArrayBuffer, ArrayBufferView or a function\n     *                               which returns a new Readable stream whose offset is from data source beginning.\n     * @param contentLength - Length of body in bytes. Use Buffer.byteLength() to calculate body length for a\n     *                               string including non non-Base64/Hex-encoded characters.\n     * @param options - Options to configure the Block Blob Upload operation.\n     * @returns Block Blob upload response data and the corresponding BlockBlobClient instance.\n     */\n  }, {\n    key: \"uploadBlockBlob\",\n    value: function () {\n      var _uploadBlockBlob = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(blobName, body, contentLength) {\n        var options,\n          _createSpan10,\n          span,\n          updatedOptions,\n          blockBlobClient,\n          response,\n          _args10 = arguments;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                options = _args10.length > 3 && _args10[3] !== undefined ? _args10[3] : {};\n                _createSpan10 = createSpan(\"ContainerClient-uploadBlockBlob\", options), span = _createSpan10.span, updatedOptions = _createSpan10.updatedOptions;\n                _context10.prev = 2;\n                blockBlobClient = this.getBlockBlobClient(blobName);\n                _context10.next = 6;\n                return blockBlobClient.upload(body, contentLength, updatedOptions);\n              case 6:\n                response = _context10.sent;\n                return _context10.abrupt(\"return\", {\n                  blockBlobClient: blockBlobClient,\n                  response: response\n                });\n              case 10:\n                _context10.prev = 10;\n                _context10.t0 = _context10[\"catch\"](2);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context10.t0.message\n                });\n                throw _context10.t0;\n              case 14:\n                _context10.prev = 14;\n                span.end();\n                return _context10.finish(14);\n              case 17:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this, [[2, 10, 14, 17]]);\n      }));\n      function uploadBlockBlob(_x4, _x5, _x6) {\n        return _uploadBlockBlob.apply(this, arguments);\n      }\n      return uploadBlockBlob;\n    }()\n    /**\n     * Marks the specified blob or snapshot for deletion. The blob is later deleted\n     * during garbage collection. Note that in order to delete a blob, you must delete\n     * all of its snapshots. You can delete both at the same time with the Delete\n     * Blob operation.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-blob\n     *\n     * @param blobName -\n     * @param options - Options to Blob Delete operation.\n     * @returns Block blob deletion response data.\n     */\n  }, {\n    key: \"deleteBlob\",\n    value: function () {\n      var _deleteBlob = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(blobName) {\n        var options,\n          _createSpan11,\n          span,\n          updatedOptions,\n          blobClient,\n          _args11 = arguments;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                options = _args11.length > 1 && _args11[1] !== undefined ? _args11[1] : {};\n                _createSpan11 = createSpan(\"ContainerClient-deleteBlob\", options), span = _createSpan11.span, updatedOptions = _createSpan11.updatedOptions;\n                _context11.prev = 2;\n                blobClient = this.getBlobClient(blobName);\n                if (options.versionId) {\n                  blobClient = blobClient.withVersion(options.versionId);\n                }\n                _context11.next = 7;\n                return blobClient.delete(updatedOptions);\n              case 7:\n                return _context11.abrupt(\"return\", _context11.sent);\n              case 10:\n                _context11.prev = 10;\n                _context11.t0 = _context11[\"catch\"](2);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context11.t0.message\n                });\n                throw _context11.t0;\n              case 14:\n                _context11.prev = 14;\n                span.end();\n                return _context11.finish(14);\n              case 17:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this, [[2, 10, 14, 17]]);\n      }));\n      function deleteBlob(_x7) {\n        return _deleteBlob.apply(this, arguments);\n      }\n      return deleteBlob;\n    }()\n    /**\n     * listBlobFlatSegment returns a single segment of blobs starting from the\n     * specified Marker. Use an empty Marker to start enumeration from the beginning.\n     * After getting a segment, process it, and then call listBlobsFlatSegment again\n     * (passing the the previously-returned Marker) to get the next segment.\n     * @see https://docs.microsoft.com/rest/api/storageservices/list-blobs\n     *\n     * @param marker - A string value that identifies the portion of the list to be returned with the next list operation.\n     * @param options - Options to Container List Blob Flat Segment operation.\n     */\n  }, {\n    key: \"listBlobFlatSegment\",\n    value: function () {\n      var _listBlobFlatSegment = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(marker) {\n        var options,\n          _createSpan12,\n          span,\n          updatedOptions,\n          response,\n          wrappedResponse,\n          _args12 = arguments;\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                options = _args12.length > 1 && _args12[1] !== undefined ? _args12[1] : {};\n                _createSpan12 = createSpan(\"ContainerClient-listBlobFlatSegment\", options), span = _createSpan12.span, updatedOptions = _createSpan12.updatedOptions;\n                _context12.prev = 2;\n                _context12.next = 5;\n                return this.containerContext.listBlobFlatSegment(Object.assign(Object.assign({\n                  marker: marker\n                }, options), convertTracingToRequestOptionsBase(updatedOptions)));\n              case 5:\n                response = _context12.sent;\n                response.segment.blobItems = [];\n                if (response.segment[\"Blob\"] !== undefined) {\n                  response.segment.blobItems = ProcessBlobItems(response.segment[\"Blob\"]);\n                }\n                wrappedResponse = Object.assign(Object.assign({}, response), {\n                  _response: Object.assign(Object.assign({}, response._response), {\n                    parsedBody: ConvertInternalResponseOfListBlobFlat(response._response.parsedBody)\n                  }),\n                  segment: Object.assign(Object.assign({}, response.segment), {\n                    blobItems: response.segment.blobItems.map(function (blobItemInteral) {\n                      var blobItem = Object.assign(Object.assign({}, blobItemInteral), {\n                        name: BlobNameToString(blobItemInteral.name),\n                        tags: toTags(blobItemInteral.blobTags),\n                        objectReplicationSourceProperties: parseObjectReplicationRecord(blobItemInteral.objectReplicationMetadata)\n                      });\n                      return blobItem;\n                    })\n                  })\n                });\n                return _context12.abrupt(\"return\", wrappedResponse);\n              case 12:\n                _context12.prev = 12;\n                _context12.t0 = _context12[\"catch\"](2);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context12.t0.message\n                });\n                throw _context12.t0;\n              case 16:\n                _context12.prev = 16;\n                span.end();\n                return _context12.finish(16);\n              case 19:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this, [[2, 12, 16, 19]]);\n      }));\n      function listBlobFlatSegment(_x8) {\n        return _listBlobFlatSegment.apply(this, arguments);\n      }\n      return listBlobFlatSegment;\n    }()\n    /**\n     * listBlobHierarchySegment returns a single segment of blobs starting from\n     * the specified Marker. Use an empty Marker to start enumeration from the\n     * beginning. After getting a segment, process it, and then call listBlobsHierarchicalSegment\n     * again (passing the the previously-returned Marker) to get the next segment.\n     * @see https://docs.microsoft.com/rest/api/storageservices/list-blobs\n     *\n     * @param delimiter - The character or string used to define the virtual hierarchy\n     * @param marker - A string value that identifies the portion of the list to be returned with the next list operation.\n     * @param options - Options to Container List Blob Hierarchy Segment operation.\n     */\n  }, {\n    key: \"listBlobHierarchySegment\",\n    value: function () {\n      var _listBlobHierarchySegment = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(delimiter, marker) {\n        var options,\n          _a,\n          _createSpan13,\n          span,\n          updatedOptions,\n          response,\n          wrappedResponse,\n          _args13 = arguments;\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                options = _args13.length > 2 && _args13[2] !== undefined ? _args13[2] : {};\n                _createSpan13 = createSpan(\"ContainerClient-listBlobHierarchySegment\", options), span = _createSpan13.span, updatedOptions = _createSpan13.updatedOptions;\n                _context13.prev = 2;\n                _context13.next = 5;\n                return this.containerContext.listBlobHierarchySegment(delimiter, Object.assign(Object.assign({\n                  marker: marker\n                }, options), convertTracingToRequestOptionsBase(updatedOptions)));\n              case 5:\n                response = _context13.sent;\n                response.segment.blobItems = [];\n                if (response.segment[\"Blob\"] !== undefined) {\n                  response.segment.blobItems = ProcessBlobItems(response.segment[\"Blob\"]);\n                }\n                response.segment.blobPrefixes = [];\n                if (response.segment[\"BlobPrefix\"] !== undefined) {\n                  response.segment.blobPrefixes = ProcessBlobPrefixes(response.segment[\"BlobPrefix\"]);\n                }\n                wrappedResponse = Object.assign(Object.assign({}, response), {\n                  _response: Object.assign(Object.assign({}, response._response), {\n                    parsedBody: ConvertInternalResponseOfListBlobHierarchy(response._response.parsedBody)\n                  }),\n                  segment: Object.assign(Object.assign({}, response.segment), {\n                    blobItems: response.segment.blobItems.map(function (blobItemInteral) {\n                      var blobItem = Object.assign(Object.assign({}, blobItemInteral), {\n                        name: BlobNameToString(blobItemInteral.name),\n                        tags: toTags(blobItemInteral.blobTags),\n                        objectReplicationSourceProperties: parseObjectReplicationRecord(blobItemInteral.objectReplicationMetadata)\n                      });\n                      return blobItem;\n                    }),\n                    blobPrefixes: (_a = response.segment.blobPrefixes) === null || _a === void 0 ? void 0 : _a.map(function (blobPrefixInternal) {\n                      var blobPrefix = {\n                        name: BlobNameToString(blobPrefixInternal.name)\n                      };\n                      return blobPrefix;\n                    })\n                  })\n                });\n                return _context13.abrupt(\"return\", wrappedResponse);\n              case 14:\n                _context13.prev = 14;\n                _context13.t0 = _context13[\"catch\"](2);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context13.t0.message\n                });\n                throw _context13.t0;\n              case 18:\n                _context13.prev = 18;\n                span.end();\n                return _context13.finish(18);\n              case 21:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this, [[2, 14, 18, 21]]);\n      }));\n      function listBlobHierarchySegment(_x9, _x10) {\n        return _listBlobHierarchySegment.apply(this, arguments);\n      }\n      return listBlobHierarchySegment;\n    }()\n    /**\n     * Returns an AsyncIterableIterator for ContainerListBlobFlatSegmentResponse\n     *\n     * @param marker - A string value that identifies the portion of\n     *                          the list of blobs to be returned with the next listing operation. The\n     *                          operation returns the ContinuationToken value within the response body if the\n     *                          listing operation did not return all blobs remaining to be listed\n     *                          with the current page. The ContinuationToken value can be used as the value for\n     *                          the marker parameter in a subsequent call to request the next page of list\n     *                          items. The marker value is opaque to the client.\n     * @param options - Options to list blobs operation.\n     */\n  }, {\n    key: \"listSegments\",\n    value: function listSegments(marker) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return __asyncGenerator(this, arguments, /*#__PURE__*/_regeneratorRuntime().mark(function listSegments_1() {\n        var listBlobsFlatSegmentResponse;\n        return _regeneratorRuntime().wrap(function listSegments_1$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                if (!(!!marker || marker === undefined)) {\n                  _context14.next = 14;\n                  break;\n                }\n              case 1:\n                _context14.next = 3;\n                return __await(this.listBlobFlatSegment(marker, options));\n              case 3:\n                listBlobsFlatSegmentResponse = _context14.sent;\n                marker = listBlobsFlatSegmentResponse.continuationToken;\n                _context14.t0 = __await;\n                _context14.next = 8;\n                return __await(listBlobsFlatSegmentResponse);\n              case 8:\n                _context14.t1 = _context14.sent;\n                _context14.next = 11;\n                return (0, _context14.t0)(_context14.t1);\n              case 11:\n                _context14.next = 13;\n                return _context14.sent;\n              case 13:\n                if (marker) {\n                  _context14.next = 1;\n                  break;\n                }\n              case 14:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, listSegments_1, this);\n      }));\n    }\n    /**\n     * Returns an AsyncIterableIterator of {@link BlobItem} objects\n     *\n     * @param options - Options to list blobs operation.\n     */\n  }, {\n    key: \"listItems\",\n    value: function listItems() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return __asyncGenerator(this, arguments, /*#__PURE__*/_regeneratorRuntime().mark(function listItems_1() {\n        var e_1, _a, marker, _b, _c, listBlobsFlatSegmentResponse;\n        return _regeneratorRuntime().wrap(function listItems_1$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                _context15.prev = 0;\n                _b = __asyncValues(this.listSegments(marker, options));\n              case 2:\n                _context15.next = 4;\n                return __await(_b.next());\n              case 4:\n                _c = _context15.sent;\n                if (_c.done) {\n                  _context15.next = 14;\n                  break;\n                }\n                listBlobsFlatSegmentResponse = _c.value;\n                _context15.t0 = __await;\n                return _context15.delegateYield(__asyncDelegator(__asyncValues(listBlobsFlatSegmentResponse.segment.blobItems)), \"t1\", 9);\n              case 9:\n                _context15.t2 = _context15.t1;\n                _context15.next = 12;\n                return (0, _context15.t0)(_context15.t2);\n              case 12:\n                _context15.next = 2;\n                break;\n              case 14:\n                _context15.next = 19;\n                break;\n              case 16:\n                _context15.prev = 16;\n                _context15.t3 = _context15[\"catch\"](0);\n                e_1 = {\n                  error: _context15.t3\n                };\n              case 19:\n                _context15.prev = 19;\n                _context15.prev = 20;\n                if (!(_c && !_c.done && (_a = _b.return))) {\n                  _context15.next = 24;\n                  break;\n                }\n                _context15.next = 24;\n                return __await(_a.call(_b));\n              case 24:\n                _context15.prev = 24;\n                if (!e_1) {\n                  _context15.next = 27;\n                  break;\n                }\n                throw e_1.error;\n              case 27:\n                return _context15.finish(24);\n              case 28:\n                return _context15.finish(19);\n              case 29:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, listItems_1, this, [[0, 16, 19, 29], [20,, 24, 28]]);\n      }));\n    }\n    /**\n     * Returns an async iterable iterator to list all the blobs\n     * under the specified account.\n     *\n     * .byPage() returns an async iterable iterator to list the blobs in pages.\n     *\n     * Example using `for await` syntax:\n     *\n     * ```js\n     * // Get the containerClient before you run these snippets,\n     * // Can be obtained from `blobServiceClient.getContainerClient(\"<your-container-name>\");`\n     * let i = 1;\n     * for await (const blob of containerClient.listBlobsFlat()) {\n     *   console.log(`Blob ${i++}: ${blob.name}`);\n     * }\n     * ```\n     *\n     * Example using `iter.next()`:\n     *\n     * ```js\n     * let i = 1;\n     * let iter = containerClient.listBlobsFlat();\n     * let blobItem = await iter.next();\n     * while (!blobItem.done) {\n     *   console.log(`Blob ${i++}: ${blobItem.value.name}`);\n     *   blobItem = await iter.next();\n     * }\n     * ```\n     *\n     * Example using `byPage()`:\n     *\n     * ```js\n     * // passing optional maxPageSize in the page settings\n     * let i = 1;\n     * for await (const response of containerClient.listBlobsFlat().byPage({ maxPageSize: 20 })) {\n     *   for (const blob of response.segment.blobItems) {\n     *     console.log(`Blob ${i++}: ${blob.name}`);\n     *   }\n     * }\n     * ```\n     *\n     * Example using paging with a marker:\n     *\n     * ```js\n     * let i = 1;\n     * let iterator = containerClient.listBlobsFlat().byPage({ maxPageSize: 2 });\n     * let response = (await iterator.next()).value;\n     *\n     * // Prints 2 blob names\n     * for (const blob of response.segment.blobItems) {\n     *   console.log(`Blob ${i++}: ${blob.name}`);\n     * }\n     *\n     * // Gets next marker\n     * let marker = response.continuationToken;\n     *\n     * // Passing next marker as continuationToken\n     *\n     * iterator = containerClient.listBlobsFlat().byPage({ continuationToken: marker, maxPageSize: 10 });\n     * response = (await iterator.next()).value;\n     *\n     * // Prints 10 blob names\n     * for (const blob of response.segment.blobItems) {\n     *   console.log(`Blob ${i++}: ${blob.name}`);\n     * }\n     * ```\n     *\n     * @param options - Options to list blobs.\n     * @returns An asyncIterableIterator that supports paging.\n     */\n  }, {\n    key: \"listBlobsFlat\",\n    value: function listBlobsFlat() {\n      var _this2 = this,\n        _ref;\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var include = [];\n      if (options.includeCopy) {\n        include.push(\"copy\");\n      }\n      if (options.includeDeleted) {\n        include.push(\"deleted\");\n      }\n      if (options.includeMetadata) {\n        include.push(\"metadata\");\n      }\n      if (options.includeSnapshots) {\n        include.push(\"snapshots\");\n      }\n      if (options.includeVersions) {\n        include.push(\"versions\");\n      }\n      if (options.includeUncommitedBlobs) {\n        include.push(\"uncommittedblobs\");\n      }\n      if (options.includeTags) {\n        include.push(\"tags\");\n      }\n      if (options.includeDeletedWithVersions) {\n        include.push(\"deletedwithversions\");\n      }\n      if (options.includeImmutabilityPolicy) {\n        include.push(\"immutabilitypolicy\");\n      }\n      if (options.includeLegalHold) {\n        include.push(\"legalhold\");\n      }\n      if (options.prefix === \"\") {\n        options.prefix = undefined;\n      }\n      var updatedOptions = Object.assign(Object.assign({}, options), include.length > 0 ? {\n        include: include\n      } : {});\n      // AsyncIterableIterator to iterate over blobs\n      var iter = this.listItems(updatedOptions);\n      return _ref = {\n        /**\n         * The next method, part of the iteration protocol\n         */\n        next: function next() {\n          return iter.next();\n        }\n      }, _defineProperty(_ref, Symbol.asyncIterator, function () {\n        return this;\n      }), _defineProperty(_ref, \"byPage\", function byPage() {\n        var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        return _this2.listSegments(settings.continuationToken, Object.assign({\n          maxPageSize: settings.maxPageSize\n        }, updatedOptions));\n      }), _ref;\n    }\n    /**\n     * Returns an AsyncIterableIterator for ContainerListBlobHierarchySegmentResponse\n     *\n     * @param delimiter - The character or string used to define the virtual hierarchy\n     * @param marker - A string value that identifies the portion of\n     *                          the list of blobs to be returned with the next listing operation. The\n     *                          operation returns the ContinuationToken value within the response body if the\n     *                          listing operation did not return all blobs remaining to be listed\n     *                          with the current page. The ContinuationToken value can be used as the value for\n     *                          the marker parameter in a subsequent call to request the next page of list\n     *                          items. The marker value is opaque to the client.\n     * @param options - Options to list blobs operation.\n     */\n  }, {\n    key: \"listHierarchySegments\",\n    value: function listHierarchySegments(delimiter, marker) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return __asyncGenerator(this, arguments, /*#__PURE__*/_regeneratorRuntime().mark(function listHierarchySegments_1() {\n        var listBlobsHierarchySegmentResponse;\n        return _regeneratorRuntime().wrap(function listHierarchySegments_1$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                if (!(!!marker || marker === undefined)) {\n                  _context16.next = 14;\n                  break;\n                }\n              case 1:\n                _context16.next = 3;\n                return __await(this.listBlobHierarchySegment(delimiter, marker, options));\n              case 3:\n                listBlobsHierarchySegmentResponse = _context16.sent;\n                marker = listBlobsHierarchySegmentResponse.continuationToken;\n                _context16.t0 = __await;\n                _context16.next = 8;\n                return __await(listBlobsHierarchySegmentResponse);\n              case 8:\n                _context16.t1 = _context16.sent;\n                _context16.next = 11;\n                return (0, _context16.t0)(_context16.t1);\n              case 11:\n                _context16.next = 13;\n                return _context16.sent;\n              case 13:\n                if (marker) {\n                  _context16.next = 1;\n                  break;\n                }\n              case 14:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, listHierarchySegments_1, this);\n      }));\n    }\n    /**\n     * Returns an AsyncIterableIterator for {@link BlobPrefix} and {@link BlobItem} objects.\n     *\n     * @param delimiter - The character or string used to define the virtual hierarchy\n     * @param options - Options to list blobs operation.\n     */\n  }, {\n    key: \"listItemsByHierarchy\",\n    value: function listItemsByHierarchy(delimiter) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return __asyncGenerator(this, arguments, /*#__PURE__*/_regeneratorRuntime().mark(function listItemsByHierarchy_1() {\n        var e_2, _a, marker, _b, _c, listBlobsHierarchySegmentResponse, segment, _iterator3, _step3, prefix, _iterator4, _step4, blob;\n        return _regeneratorRuntime().wrap(function listItemsByHierarchy_1$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                _context17.prev = 0;\n                _b = __asyncValues(this.listHierarchySegments(delimiter, marker, options));\n              case 2:\n                _context17.next = 4;\n                return __await(_b.next());\n              case 4:\n                _c = _context17.sent;\n                if (_c.done) {\n                  _context17.next = 49;\n                  break;\n                }\n                listBlobsHierarchySegmentResponse = _c.value;\n                segment = listBlobsHierarchySegmentResponse.segment;\n                if (!segment.blobPrefixes) {\n                  _context17.next = 28;\n                  break;\n                }\n                _iterator3 = _createForOfIteratorHelper(segment.blobPrefixes);\n                _context17.prev = 10;\n                _iterator3.s();\n              case 12:\n                if ((_step3 = _iterator3.n()).done) {\n                  _context17.next = 20;\n                  break;\n                }\n                prefix = _step3.value;\n                _context17.next = 16;\n                return __await(Object.assign({\n                  kind: \"prefix\"\n                }, prefix));\n              case 16:\n                _context17.next = 18;\n                return _context17.sent;\n              case 18:\n                _context17.next = 12;\n                break;\n              case 20:\n                _context17.next = 25;\n                break;\n              case 22:\n                _context17.prev = 22;\n                _context17.t0 = _context17[\"catch\"](10);\n                _iterator3.e(_context17.t0);\n              case 25:\n                _context17.prev = 25;\n                _iterator3.f();\n                return _context17.finish(25);\n              case 28:\n                _iterator4 = _createForOfIteratorHelper(segment.blobItems);\n                _context17.prev = 29;\n                _iterator4.s();\n              case 31:\n                if ((_step4 = _iterator4.n()).done) {\n                  _context17.next = 39;\n                  break;\n                }\n                blob = _step4.value;\n                _context17.next = 35;\n                return __await(Object.assign({\n                  kind: \"blob\"\n                }, blob));\n              case 35:\n                _context17.next = 37;\n                return _context17.sent;\n              case 37:\n                _context17.next = 31;\n                break;\n              case 39:\n                _context17.next = 44;\n                break;\n              case 41:\n                _context17.prev = 41;\n                _context17.t1 = _context17[\"catch\"](29);\n                _iterator4.e(_context17.t1);\n              case 44:\n                _context17.prev = 44;\n                _iterator4.f();\n                return _context17.finish(44);\n              case 47:\n                _context17.next = 2;\n                break;\n              case 49:\n                _context17.next = 54;\n                break;\n              case 51:\n                _context17.prev = 51;\n                _context17.t2 = _context17[\"catch\"](0);\n                e_2 = {\n                  error: _context17.t2\n                };\n              case 54:\n                _context17.prev = 54;\n                _context17.prev = 55;\n                if (!(_c && !_c.done && (_a = _b.return))) {\n                  _context17.next = 59;\n                  break;\n                }\n                _context17.next = 59;\n                return __await(_a.call(_b));\n              case 59:\n                _context17.prev = 59;\n                if (!e_2) {\n                  _context17.next = 62;\n                  break;\n                }\n                throw e_2.error;\n              case 62:\n                return _context17.finish(59);\n              case 63:\n                return _context17.finish(54);\n              case 64:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, listItemsByHierarchy_1, this, [[0, 51, 54, 64], [10, 22, 25, 28], [29, 41, 44, 47], [55,, 59, 63]]);\n      }));\n    }\n    /**\n     * Returns an async iterable iterator to list all the blobs by hierarchy.\n     * under the specified account.\n     *\n     * .byPage() returns an async iterable iterator to list the blobs by hierarchy in pages.\n     *\n     * Example using `for await` syntax:\n     *\n     * ```js\n     * for await (const item of containerClient.listBlobsByHierarchy(\"/\")) {\n     *   if (item.kind === \"prefix\") {\n     *     console.log(`\\tBlobPrefix: ${item.name}`);\n     *   } else {\n     *     console.log(`\\tBlobItem: name - ${item.name}`);\n     *   }\n     * }\n     * ```\n     *\n     * Example using `iter.next()`:\n     *\n     * ```js\n     * let iter = containerClient.listBlobsByHierarchy(\"/\", { prefix: \"prefix1/\" });\n     * let entity = await iter.next();\n     * while (!entity.done) {\n     *   let item = entity.value;\n     *   if (item.kind === \"prefix\") {\n     *     console.log(`\\tBlobPrefix: ${item.name}`);\n     *   } else {\n     *     console.log(`\\tBlobItem: name - ${item.name}`);\n     *   }\n     *   entity = await iter.next();\n     * }\n     * ```\n     *\n     * Example using `byPage()`:\n     *\n     * ```js\n     * console.log(\"Listing blobs by hierarchy by page\");\n     * for await (const response of containerClient.listBlobsByHierarchy(\"/\").byPage()) {\n     *   const segment = response.segment;\n     *   if (segment.blobPrefixes) {\n     *     for (const prefix of segment.blobPrefixes) {\n     *       console.log(`\\tBlobPrefix: ${prefix.name}`);\n     *     }\n     *   }\n     *   for (const blob of response.segment.blobItems) {\n     *     console.log(`\\tBlobItem: name - ${blob.name}`);\n     *   }\n     * }\n     * ```\n     *\n     * Example using paging with a max page size:\n     *\n     * ```js\n     * console.log(\"Listing blobs by hierarchy by page, specifying a prefix and a max page size\");\n     *\n     * let i = 1;\n     * for await (const response of containerClient\n     *   .listBlobsByHierarchy(\"/\", { prefix: \"prefix2/sub1/\" })\n     *   .byPage({ maxPageSize: 2 })) {\n     *   console.log(`Page ${i++}`);\n     *   const segment = response.segment;\n     *\n     *   if (segment.blobPrefixes) {\n     *     for (const prefix of segment.blobPrefixes) {\n     *       console.log(`\\tBlobPrefix: ${prefix.name}`);\n     *     }\n     *   }\n     *\n     *   for (const blob of response.segment.blobItems) {\n     *     console.log(`\\tBlobItem: name - ${blob.name}`);\n     *   }\n     * }\n     * ```\n     *\n     * @param delimiter - The character or string used to define the virtual hierarchy\n     * @param options - Options to list blobs operation.\n     */\n  }, {\n    key: \"listBlobsByHierarchy\",\n    value: function listBlobsByHierarchy(delimiter) {\n      var _this3 = this,\n        _ref2;\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (delimiter === \"\") {\n        throw new RangeError(\"delimiter should contain one or more characters\");\n      }\n      var include = [];\n      if (options.includeCopy) {\n        include.push(\"copy\");\n      }\n      if (options.includeDeleted) {\n        include.push(\"deleted\");\n      }\n      if (options.includeMetadata) {\n        include.push(\"metadata\");\n      }\n      if (options.includeSnapshots) {\n        include.push(\"snapshots\");\n      }\n      if (options.includeVersions) {\n        include.push(\"versions\");\n      }\n      if (options.includeUncommitedBlobs) {\n        include.push(\"uncommittedblobs\");\n      }\n      if (options.includeTags) {\n        include.push(\"tags\");\n      }\n      if (options.includeDeletedWithVersions) {\n        include.push(\"deletedwithversions\");\n      }\n      if (options.includeImmutabilityPolicy) {\n        include.push(\"immutabilitypolicy\");\n      }\n      if (options.includeLegalHold) {\n        include.push(\"legalhold\");\n      }\n      if (options.prefix === \"\") {\n        options.prefix = undefined;\n      }\n      var updatedOptions = Object.assign(Object.assign({}, options), include.length > 0 ? {\n        include: include\n      } : {});\n      // AsyncIterableIterator to iterate over blob prefixes and blobs\n      var iter = this.listItemsByHierarchy(delimiter, updatedOptions);\n      return _ref2 = {\n        /**\n         * The next method, part of the iteration protocol\n         */\n        next: function next() {\n          return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {\n            return _regeneratorRuntime().wrap(function _callee14$(_context18) {\n              while (1) {\n                switch (_context18.prev = _context18.next) {\n                  case 0:\n                    return _context18.abrupt(\"return\", iter.next());\n                  case 1:\n                  case \"end\":\n                    return _context18.stop();\n                }\n              }\n            }, _callee14);\n          }))();\n        }\n      }, _defineProperty(_ref2, Symbol.asyncIterator, function () {\n        return this;\n      }), _defineProperty(_ref2, \"byPage\", function byPage() {\n        var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        return _this3.listHierarchySegments(delimiter, settings.continuationToken, Object.assign({\n          maxPageSize: settings.maxPageSize\n        }, updatedOptions));\n      }), _ref2;\n    }\n    /**\n     * The Filter Blobs operation enables callers to list blobs in the container whose tags\n     * match a given search expression.\n     *\n     * @param tagFilterSqlExpression - The where parameter enables the caller to query blobs whose tags match a given expression.\n     *                                        The given expression must evaluate to true for a blob to be returned in the results.\n     *                                        The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;\n     *                                        however, only a subset of the OData filter syntax is supported in the Blob service.\n     * @param marker - A string value that identifies the portion of\n     *                          the list of blobs to be returned with the next listing operation. The\n     *                          operation returns the continuationToken value within the response body if the\n     *                          listing operation did not return all blobs remaining to be listed\n     *                          with the current page. The continuationToken value can be used as the value for\n     *                          the marker parameter in a subsequent call to request the next page of list\n     *                          items. The marker value is opaque to the client.\n     * @param options - Options to find blobs by tags.\n     */\n  }, {\n    key: \"findBlobsByTagsSegment\",\n    value: function () {\n      var _findBlobsByTagsSegment = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(tagFilterSqlExpression, marker) {\n        var options,\n          _createSpan14,\n          span,\n          updatedOptions,\n          response,\n          wrappedResponse,\n          _args19 = arguments;\n        return _regeneratorRuntime().wrap(function _callee15$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                options = _args19.length > 2 && _args19[2] !== undefined ? _args19[2] : {};\n                _createSpan14 = createSpan(\"ContainerClient-findBlobsByTagsSegment\", options), span = _createSpan14.span, updatedOptions = _createSpan14.updatedOptions;\n                _context19.prev = 2;\n                _context19.next = 5;\n                return this.containerContext.filterBlobs(Object.assign({\n                  abortSignal: options.abortSignal,\n                  where: tagFilterSqlExpression,\n                  marker: marker,\n                  maxPageSize: options.maxPageSize\n                }, convertTracingToRequestOptionsBase(updatedOptions)));\n              case 5:\n                response = _context19.sent;\n                wrappedResponse = Object.assign(Object.assign({}, response), {\n                  _response: response._response,\n                  blobs: response.blobs.map(function (blob) {\n                    var _a;\n                    var tagValue = \"\";\n                    if (((_a = blob.tags) === null || _a === void 0 ? void 0 : _a.blobTagSet.length) === 1) {\n                      tagValue = blob.tags.blobTagSet[0].value;\n                    }\n                    return Object.assign(Object.assign({}, blob), {\n                      tags: toTags(blob.tags),\n                      tagValue: tagValue\n                    });\n                  })\n                });\n                return _context19.abrupt(\"return\", wrappedResponse);\n              case 10:\n                _context19.prev = 10;\n                _context19.t0 = _context19[\"catch\"](2);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context19.t0.message\n                });\n                throw _context19.t0;\n              case 14:\n                _context19.prev = 14;\n                span.end();\n                return _context19.finish(14);\n              case 17:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n        }, _callee15, this, [[2, 10, 14, 17]]);\n      }));\n      function findBlobsByTagsSegment(_x11, _x12) {\n        return _findBlobsByTagsSegment.apply(this, arguments);\n      }\n      return findBlobsByTagsSegment;\n    }()\n    /**\n     * Returns an AsyncIterableIterator for ContainerFindBlobsByTagsSegmentResponse.\n     *\n     * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.\n     *                                         The given expression must evaluate to true for a blob to be returned in the results.\n     *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;\n     *                                         however, only a subset of the OData filter syntax is supported in the Blob service.\n     * @param marker - A string value that identifies the portion of\n     *                          the list of blobs to be returned with the next listing operation. The\n     *                          operation returns the continuationToken value within the response body if the\n     *                          listing operation did not return all blobs remaining to be listed\n     *                          with the current page. The continuationToken value can be used as the value for\n     *                          the marker parameter in a subsequent call to request the next page of list\n     *                          items. The marker value is opaque to the client.\n     * @param options - Options to find blobs by tags.\n     */\n  }, {\n    key: \"findBlobsByTagsSegments\",\n    value: function findBlobsByTagsSegments(tagFilterSqlExpression, marker) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return __asyncGenerator(this, arguments, /*#__PURE__*/_regeneratorRuntime().mark(function findBlobsByTagsSegments_1() {\n        var response;\n        return _regeneratorRuntime().wrap(function findBlobsByTagsSegments_1$(_context20) {\n          while (1) {\n            switch (_context20.prev = _context20.next) {\n              case 0:\n                if (!(!!marker || marker === undefined)) {\n                  _context20.next = 11;\n                  break;\n                }\n              case 1:\n                _context20.next = 3;\n                return __await(this.findBlobsByTagsSegment(tagFilterSqlExpression, marker, options));\n              case 3:\n                response = _context20.sent;\n                response.blobs = response.blobs || [];\n                marker = response.continuationToken;\n                _context20.next = 8;\n                return __await(response);\n              case 8:\n                _context20.next = 10;\n                return _context20.sent;\n              case 10:\n                if (marker) {\n                  _context20.next = 1;\n                  break;\n                }\n              case 11:\n              case \"end\":\n                return _context20.stop();\n            }\n          }\n        }, findBlobsByTagsSegments_1, this);\n      }));\n    }\n    /**\n     * Returns an AsyncIterableIterator for blobs.\n     *\n     * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.\n     *                                         The given expression must evaluate to true for a blob to be returned in the results.\n     *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;\n     *                                         however, only a subset of the OData filter syntax is supported in the Blob service.\n     * @param options - Options to findBlobsByTagsItems.\n     */\n  }, {\n    key: \"findBlobsByTagsItems\",\n    value: function findBlobsByTagsItems(tagFilterSqlExpression) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return __asyncGenerator(this, arguments, /*#__PURE__*/_regeneratorRuntime().mark(function findBlobsByTagsItems_1() {\n        var e_3, _a, marker, _b, _c, segment;\n        return _regeneratorRuntime().wrap(function findBlobsByTagsItems_1$(_context21) {\n          while (1) {\n            switch (_context21.prev = _context21.next) {\n              case 0:\n                _context21.prev = 0;\n                _b = __asyncValues(this.findBlobsByTagsSegments(tagFilterSqlExpression, marker, options));\n              case 2:\n                _context21.next = 4;\n                return __await(_b.next());\n              case 4:\n                _c = _context21.sent;\n                if (_c.done) {\n                  _context21.next = 14;\n                  break;\n                }\n                segment = _c.value;\n                _context21.t0 = __await;\n                return _context21.delegateYield(__asyncDelegator(__asyncValues(segment.blobs)), \"t1\", 9);\n              case 9:\n                _context21.t2 = _context21.t1;\n                _context21.next = 12;\n                return (0, _context21.t0)(_context21.t2);\n              case 12:\n                _context21.next = 2;\n                break;\n              case 14:\n                _context21.next = 19;\n                break;\n              case 16:\n                _context21.prev = 16;\n                _context21.t3 = _context21[\"catch\"](0);\n                e_3 = {\n                  error: _context21.t3\n                };\n              case 19:\n                _context21.prev = 19;\n                _context21.prev = 20;\n                if (!(_c && !_c.done && (_a = _b.return))) {\n                  _context21.next = 24;\n                  break;\n                }\n                _context21.next = 24;\n                return __await(_a.call(_b));\n              case 24:\n                _context21.prev = 24;\n                if (!e_3) {\n                  _context21.next = 27;\n                  break;\n                }\n                throw e_3.error;\n              case 27:\n                return _context21.finish(24);\n              case 28:\n                return _context21.finish(19);\n              case 29:\n              case \"end\":\n                return _context21.stop();\n            }\n          }\n        }, findBlobsByTagsItems_1, this, [[0, 16, 19, 29], [20,, 24, 28]]);\n      }));\n    }\n    /**\n     * Returns an async iterable iterator to find all blobs with specified tag\n     * under the specified container.\n     *\n     * .byPage() returns an async iterable iterator to list the blobs in pages.\n     *\n     * Example using `for await` syntax:\n     *\n     * ```js\n     * let i = 1;\n     * for await (const blob of containerClient.findBlobsByTags(\"tagkey='tagvalue'\")) {\n     *   console.log(`Blob ${i++}: ${blob.name}`);\n     * }\n     * ```\n     *\n     * Example using `iter.next()`:\n     *\n     * ```js\n     * let i = 1;\n     * const iter = containerClient.findBlobsByTags(\"tagkey='tagvalue'\");\n     * let blobItem = await iter.next();\n     * while (!blobItem.done) {\n     *   console.log(`Blob ${i++}: ${blobItem.value.name}`);\n     *   blobItem = await iter.next();\n     * }\n     * ```\n     *\n     * Example using `byPage()`:\n     *\n     * ```js\n     * // passing optional maxPageSize in the page settings\n     * let i = 1;\n     * for await (const response of containerClient.findBlobsByTags(\"tagkey='tagvalue'\").byPage({ maxPageSize: 20 })) {\n     *   if (response.blobs) {\n     *     for (const blob of response.blobs) {\n     *       console.log(`Blob ${i++}: ${blob.name}`);\n     *     }\n     *   }\n     * }\n     * ```\n     *\n     * Example using paging with a marker:\n     *\n     * ```js\n     * let i = 1;\n     * let iterator = containerClient.findBlobsByTags(\"tagkey='tagvalue'\").byPage({ maxPageSize: 2 });\n     * let response = (await iterator.next()).value;\n     *\n     * // Prints 2 blob names\n     * if (response.blobs) {\n     *   for (const blob of response.blobs) {\n     *     console.log(`Blob ${i++}: ${blob.name}`);\n     *   }\n     * }\n     *\n     * // Gets next marker\n     * let marker = response.continuationToken;\n     * // Passing next marker as continuationToken\n     * iterator = containerClient\n     *   .findBlobsByTags(\"tagkey='tagvalue'\")\n     *   .byPage({ continuationToken: marker, maxPageSize: 10 });\n     * response = (await iterator.next()).value;\n     *\n     * // Prints blob names\n     * if (response.blobs) {\n     *   for (const blob of response.blobs) {\n     *      console.log(`Blob ${i++}: ${blob.name}`);\n     *   }\n     * }\n     * ```\n     *\n     * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.\n     *                                         The given expression must evaluate to true for a blob to be returned in the results.\n     *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;\n     *                                         however, only a subset of the OData filter syntax is supported in the Blob service.\n     * @param options - Options to find blobs by tags.\n     */\n  }, {\n    key: \"findBlobsByTags\",\n    value: function findBlobsByTags(tagFilterSqlExpression) {\n      var _this4 = this,\n        _ref3;\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      // AsyncIterableIterator to iterate over blobs\n      var listSegmentOptions = Object.assign({}, options);\n      var iter = this.findBlobsByTagsItems(tagFilterSqlExpression, listSegmentOptions);\n      return _ref3 = {\n        /**\n         * The next method, part of the iteration protocol\n         */\n        next: function next() {\n          return iter.next();\n        }\n      }, _defineProperty(_ref3, Symbol.asyncIterator, function () {\n        return this;\n      }), _defineProperty(_ref3, \"byPage\", function byPage() {\n        var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        return _this4.findBlobsByTagsSegments(tagFilterSqlExpression, settings.continuationToken, Object.assign({\n          maxPageSize: settings.maxPageSize\n        }, listSegmentOptions));\n      }), _ref3;\n    }\n  }, {\n    key: \"getContainerNameFromUrl\",\n    value: function getContainerNameFromUrl() {\n      var containerName;\n      try {\n        //  URL may look like the following\n        // \"https://myaccount.blob.core.windows.net/mycontainer?sasString\";\n        // \"https://myaccount.blob.core.windows.net/mycontainer\";\n        // IPv4/IPv6 address hosts, Endpoints - `http://127.0.0.1:10000/devstoreaccount1/containername`\n        // http://localhost:10001/devstoreaccount1/containername\n        var parsedUrl = URLBuilder.parse(this.url);\n        if (parsedUrl.getHost().split(\".\")[1] === \"blob\") {\n          // \"https://myaccount.blob.core.windows.net/containername\".\n          // \"https://customdomain.com/containername\".\n          // .getPath() -> /containername\n          containerName = parsedUrl.getPath().split(\"/\")[1];\n        } else if (isIpEndpointStyle(parsedUrl)) {\n          // IPv4/IPv6 address hosts... Example - http://192.0.0.10:10001/devstoreaccount1/containername\n          // Single word domain without a [dot] in the endpoint... Example - http://localhost:10001/devstoreaccount1/containername\n          // .getPath() -> /devstoreaccount1/containername\n          containerName = parsedUrl.getPath().split(\"/\")[2];\n        } else {\n          // \"https://customdomain.com/containername\".\n          // .getPath() -> /containername\n          containerName = parsedUrl.getPath().split(\"/\")[1];\n        }\n        // decode the encoded containerName - to get all the special characters that might be present in it\n        containerName = decodeURIComponent(containerName);\n        if (!containerName) {\n          throw new Error(\"Provided containerName is invalid.\");\n        }\n        return containerName;\n      } catch (error) {\n        throw new Error(\"Unable to extract containerName with provided information.\");\n      }\n    }\n    /**\n     * Only available for ContainerClient constructed with a shared key credential.\n     *\n     * Generates a Blob Container Service Shared Access Signature (SAS) URI based on the client properties\n     * and parameters passed in. The SAS is signed by the shared key credential of the client.\n     *\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas\n     *\n     * @param options - Optional parameters.\n     * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.\n     */\n  }, {\n    key: \"generateSasUrl\",\n    value: function generateSasUrl(options) {\n      var _this5 = this;\n      return new Promise(function (resolve) {\n        if (!(_this5.credential instanceof StorageSharedKeyCredential)) {\n          throw new RangeError(\"Can only generate the SAS when the client is initialized with a shared key credential\");\n        }\n        var sas = generateBlobSASQueryParameters(Object.assign({\n          containerName: _this5._containerName\n        }, options), _this5.credential).toString();\n        resolve(appendToURLQuery(_this5.url, sas));\n      });\n    }\n    /**\n     * Creates a BlobBatchClient object to conduct batch operations.\n     *\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/blob-batch\n     *\n     * @returns A new BlobBatchClient object for this container.\n     */\n  }, {\n    key: \"getBlobBatchClient\",\n    value: function getBlobBatchClient() {\n      return new BlobBatchClient(this.url, this.pipeline);\n    }\n  }]);\n  return ContainerClient;\n}(StorageClient);","map":{"version":3,"mappings":";;;;;;;+CAGA;;AAAA,SACEA,uBAAuB,EAGvBC,MAAM,EACNC,iBAAiB,EAEjBC,UAAU,QACL,kBAAkB;AAEzB,SAASC,cAAc,QAAQ,qBAAqB;AACpD,SAASC,mBAAmB,QAAQ,mCAAmC;AACvE,SAASC,0BAA0B,QAAQ,0CAA0C;AACrF,SAASC,SAAS,QAAQ,4BAA4B;AAgCtD,SAASC,WAAW,EAAgBC,cAAc,QAAgC,YAAY;AAC9F,SAAwBC,aAAa,QAAQ,iBAAiB;AAC9D,SAASC,kCAAkC,EAAEC,UAAU,QAAQ,iBAAiB;AAChF,SACEC,eAAe,EACfC,gBAAgB,EAChBC,gBAAgB,EAChBC,qCAAqC,EACrCC,0CAA0C,EAC1CC,UAAU,EACVC,4BAA4B,EAC5BC,iBAAiB,EACjBC,4BAA4B,EAC5BC,gBAAgB,EAChBC,mBAAmB,EACnBC,MAAM,EACNC,oBAAoB,QACf,sBAAsB;AAE7B,SAASC,8BAA8B,QAAQ,8BAA8B;AAC7E,SAASC,eAAe,QAAQ,mBAAmB;AACnD,SACEC,gBAAgB,EAChBC,UAAU,EAEVC,eAAe,EAGfC,cAAc,QACT,WAAW;AAClB,SAASC,eAAe,QAAQ,mBAAmB;AAyiBnD;;;AAGA,WAAaC,eAAgB;EAAA;EAAA;EAgE3B,yBACEC,qBAA6B,EAC7BC,mCAKgB;EAChB;EACA;EACAC,OAAgC;IAAA;IAAA;IAEhC,IAAIC,QAAsB;IAC1B,IAAIC,GAAW;IACfF,OAAO,GAAGA,OAAO,IAAI,EAAE;IACvB,IAAI3B,cAAc,CAAC0B,mCAAmC,CAAC,EAAE;MACvD;MACAG,GAAG,GAAGJ,qBAAqB;MAC3BG,QAAQ,GAAGF,mCAAmC;KAC/C,MAAM,IACJlC,MAAM,IAAIkC,mCAAmC,YAAY7B,0BAA0B,IACpF6B,mCAAmC,YAAY9B,mBAAmB,IAClEH,iBAAiB,CAACiC,mCAAmC,CAAC,EACtD;MACA;MACAG,GAAG,GAAGJ,qBAAqB;MAC3BG,QAAQ,GAAG7B,WAAW,CAAC2B,mCAAmC,EAAEC,OAAO,CAAC;KACrE,MAAM,IACL,CAACD,mCAAmC,IACpC,OAAOA,mCAAmC,KAAK,QAAQ,EACvD;MACA;MACA;MACAG,GAAG,GAAGJ,qBAAqB;MAC3BG,QAAQ,GAAG7B,WAAW,CAAC,IAAIH,mBAAmB,EAAE,EAAE+B,OAAO,CAAC;KAC3D,MAAM,IACLD,mCAAmC,IACnC,OAAOA,mCAAmC,KAAK,QAAQ,EACvD;MACA;MACA,IAAMI,aAAa,GAAGJ,mCAAmC;MAEzD,IAAMK,cAAc,GAAGrB,4BAA4B,CAACe,qBAAqB,CAAC;MAC1E,IAAIM,cAAc,CAACC,IAAI,KAAK,mBAAmB,EAAE;QAC/C,IAAIxC,MAAM,EAAE;UACV,IAAMyC,mBAAmB,GAAG,IAAIpC,0BAA0B,CACxDkC,cAAc,CAACG,WAAY,EAC3BH,cAAc,CAACI,UAAU,CAC1B;UACDN,GAAG,GAAGzB,eAAe,CAAC2B,cAAc,CAACF,GAAG,EAAEO,kBAAkB,CAACN,aAAa,CAAC,CAAC;UAE5E,IAAI,CAACH,OAAO,CAACU,YAAY,EAAE;YACzBV,OAAO,CAACU,YAAY,GAAG9C,uBAAuB,CAACwC,cAAc,CAACO,QAAQ,CAAC;;UAGzEV,QAAQ,GAAG7B,WAAW,CAACkC,mBAAmB,EAAEN,OAAO,CAAC;SACrD,MAAM;UACL,MAAM,IAAIY,KAAK,CAAC,oEAAoE,CAAC;;OAExF,MAAM,IAAIR,cAAc,CAACC,IAAI,KAAK,eAAe,EAAE;QAClDH,GAAG,GACDzB,eAAe,CAAC2B,cAAc,CAACF,GAAG,EAAEO,kBAAkB,CAACN,aAAa,CAAC,CAAC,GACtE,GAAG,GACHC,cAAc,CAACS,UAAU;QAC3BZ,QAAQ,GAAG7B,WAAW,CAAC,IAAIH,mBAAmB,EAAE,EAAE+B,OAAO,CAAC;OAC3D,MAAM;QACL,MAAM,IAAIY,KAAK,CACb,0FAA0F,CAC3F;;KAEJ,MAAM;MACL,MAAM,IAAIA,KAAK,CAAC,yDAAyD,CAAC;;IAE5E,0BAAMV,GAAG,EAAED,QAAQ;IACnB,MAAKa,cAAc,GAAG,MAAKC,uBAAuB,EAAE;IACpD,MAAKC,gBAAgB,GAAG,IAAI7C,SAAS,CAAC,MAAK8C,oBAAoB,CAAC;IAAC;EACnE;EApIA;;;EAAA;IAAA;IAAA,KAGA,eAAwB;MACtB,OAAO,IAAI,CAACH,cAAc;IAC5B;IAiIA;;;;;;;;;;;;;;;;EAAA;IAAA;IAAA;MAAA,yEAgBO;QAAA;UAAA;UAAA;UAAA;UAAA;QAAA;UAAA;YAAA;cAAA;gBAAad,kEAAkC,EAAE;gBAAA,cACrBxB,UAAU,CAAC,wBAAwB,EAAEwB,OAAO,CAAC,EAAtEkB,IAAI,eAAJA,IAAI,EAAEC,cAAc,eAAdA,cAAc;gBAAA;gBAAA;gBAAA,OAIb,IAAI,CAACH,gBAAgB,CAACI,MAAM,iCACpCpB,OAAO,GACPzB,kCAAkC,CAAC4C,cAAc,CAAC,EACrD;cAAA;gBAAA;cAAA;gBAAA;gBAAA;gBAEFD,IAAI,CAACG,SAAS,CAAC;kBACbC,IAAI,EAAEtD,cAAc,CAACuD,KAAK;kBAC1BC,OAAO,EAAE,YAAEA;iBACZ,CAAC;gBAAC;cAAA;gBAAA;gBAGHN,IAAI,CAACO,GAAG,EAAE;gBAAC;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAEd;MAAA;QAAA;MAAA;MAAA;IAAA;IAED;;;;;;;EAAA;IAAA;IAAA;MAAA,oFAOO;QAAA;UAAA;UAAA;UAAA;UAAA;UAAA;UAAA;UAAA;QAAA;UAAA;YAAA;cAAA;gBACLzB,qEAAkC,EAAE;gBAAA,eAEHxB,UAAU,CAAC,mCAAmC,EAAEwB,OAAO,CAAC,EAAjFkB,IAAI,gBAAJA,IAAI,EAAEC,cAAc,gBAAdA,cAAc;gBAAA;gBAAA;gBAAA,OAER,IAAI,CAACC,MAAM,CAACD,cAAc,CAAC;cAAA;gBAAvCO,GAAG;gBAAA,kCACTC;kBACEC,SAAS,EAAE;gBAAI,GACZF,GAAG;kBACNG,SAAS,EAAEH,GAAG,CAACG;gBAAS;cAAA;gBAAA;gBAAA;gBAAA,MAGtB,oBAAEC,OAAO,0CAAEC,SAAS,MAAK,wBAAwB;kBAAA;kBAAA;gBAAA;gBACnDb,IAAI,CAACG,SAAS,CAAC;kBACbC,IAAI,EAAEtD,cAAc,CAACuD,KAAK;kBAC1BC,OAAO,EACL;iBACH,CAAC;gBAAC,kCACHG;kBACEC,SAAS,EAAE;gBAAK,GACb,mBAAEI,QAAQ,0CAAEC,aAAa;kBAC5BJ,SAAS,EAAE,aAAEG;gBAAQ;cAAA;gBAIzBd,IAAI,CAACG,SAAS,CAAC;kBACbC,IAAI,EAAEtD,cAAc,CAACuD,KAAK;kBAC1BC,OAAO,EAAE,aAAEA;iBACZ,CAAC;gBAAC;cAAA;gBAAA;gBAGHN,IAAI,CAACO,GAAG,EAAE;gBAAC;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAEd;MAAA;QAAA;MAAA;MAAA;IAAA;IAED;;;;;;;;;EAAA;IAAA;IAAA;MAAA,yEASO;QAAA;UAAA;UAAA;UAAA;UAAA;QAAA;UAAA;YAAA;cAAA;gBAAazB,qEAAkC,EAAE;gBAAA,eACrBxB,UAAU,CAAC,wBAAwB,EAAEwB,OAAO,CAAC,EAAtEkB,IAAI,gBAAJA,IAAI,EAAEC,cAAc,gBAAdA,cAAc;gBAAA;gBAAA;gBAAA,OAEpB,IAAI,CAACe,aAAa,CAAC;kBACvBC,WAAW,EAAEnC,OAAO,CAACmC,WAAW;kBAChCC,cAAc,EAAEjB,cAAc,CAACiB;iBAChC,CAAC;cAAA;gBAAA,kCACK,IAAI;cAAA;gBAAA;gBAAA;gBAAA,MAEP,aAAEC,UAAU,KAAK,GAAG;kBAAA;kBAAA;gBAAA;gBACtBnB,IAAI,CAACG,SAAS,CAAC;kBACbC,IAAI,EAAEtD,cAAc,CAACuD,KAAK;kBAC1BC,OAAO,EAAE;iBACV,CAAC;gBAAC,kCACI,KAAK;cAAA;gBAEdN,IAAI,CAACG,SAAS,CAAC;kBACbC,IAAI,EAAEtD,cAAc,CAACuD,KAAK;kBAC1BC,OAAO,EAAE,aAAEA;iBACZ,CAAC;gBAAC;cAAA;gBAAA;gBAGHN,IAAI,CAACO,GAAG,EAAE;gBAAC;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAEd;MAAA;QAAA;MAAA;MAAA;IAAA;IAED;;;;;;EAAA;IAAA;IAAA,OAMO,uBAAca,QAAgB;MACnC,OAAO,IAAI7C,UAAU,CAAChB,eAAe,CAAC,IAAI,CAACyB,GAAG,EAAEpB,UAAU,CAACwD,QAAQ,CAAC,CAAC,EAAE,IAAI,CAACrC,QAAQ,CAAC;IACvF;IAEA;;;;;EAAA;IAAA;IAAA,OAKO,6BAAoBqC,QAAgB;MACzC,OAAO,IAAI9C,gBAAgB,CAACf,eAAe,CAAC,IAAI,CAACyB,GAAG,EAAEpB,UAAU,CAACwD,QAAQ,CAAC,CAAC,EAAE,IAAI,CAACrC,QAAQ,CAAC;IAC7F;IAEA;;;;;;;;;;;;;;;EAAA;IAAA;IAAA,OAeO,4BAAmBqC,QAAgB;MACxC,OAAO,IAAI5C,eAAe,CAACjB,eAAe,CAAC,IAAI,CAACyB,GAAG,EAAEpB,UAAU,CAACwD,QAAQ,CAAC,CAAC,EAAE,IAAI,CAACrC,QAAQ,CAAC;IAC5F;IAEA;;;;;EAAA;IAAA;IAAA,OAKO,2BAAkBqC,QAAgB;MACvC,OAAO,IAAI3C,cAAc,CAAClB,eAAe,CAAC,IAAI,CAACyB,GAAG,EAAEpB,UAAU,CAACwD,QAAQ,CAAC,CAAC,EAAE,IAAI,CAACrC,QAAQ,CAAC;IAC3F;IAEA;;;;;;;;;;;;EAAA;IAAA;IAAA;MAAA,gFAYO;QAAA;UAAA;UAAA;UAAA;UAAA;QAAA;UAAA;YAAA;cAAA;gBACLD,qEAAyC,EAAE;gBAE3C,IAAI,CAACA,OAAO,CAACuC,UAAU,EAAE;kBACvBvC,OAAO,CAACuC,UAAU,GAAG,EAAE;;gBACxB,eAEgC/D,UAAU,CAAC,+BAA+B,EAAEwB,OAAO,CAAC,EAA7EkB,IAAI,gBAAJA,IAAI,EAAEC,cAAc,gBAAdA,cAAc;gBAAA;gBAAA;gBAAA,OAEb,IAAI,CAACH,gBAAgB,CAACkB,aAAa;kBAC9CC,WAAW,EAAEnC,OAAO,CAACmC;gBAAW,GAC7BnC,OAAO,CAACuC,UAAU,GAClBhE,kCAAkC,CAAC4C,cAAc,CAAC,EACrD;cAAA;gBAAA;cAAA;gBAAA;gBAAA;gBAEFD,IAAI,CAACG,SAAS,CAAC;kBACbC,IAAI,EAAEtD,cAAc,CAACuD,KAAK;kBAC1BC,OAAO,EAAE,aAAEA;iBACZ,CAAC;gBAAC;cAAA;gBAAA;gBAGHN,IAAI,CAACO,GAAG,EAAE;gBAAC;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAEd;MAAA;QAAA;MAAA;MAAA;IAAA;IAED;;;;;;;EAAA;IAAA;IAAA;MAAA,0EAOO;QAAA;UAAA;UAAA;UAAA;UAAA;QAAA;UAAA;YAAA;cAAA;gBACLzB,qEAAwC,EAAE;gBAE1C,IAAI,CAACA,OAAO,CAACuC,UAAU,EAAE;kBACvBvC,OAAO,CAACuC,UAAU,GAAG,EAAE;;gBACxB,eAEgC/D,UAAU,CAAC,wBAAwB,EAAEwB,OAAO,CAAC,EAAtEkB,IAAI,gBAAJA,IAAI,EAAEC,cAAc,gBAAdA,cAAc;gBAAA;gBAAA;gBAAA,OAEb,IAAI,CAACH,gBAAgB,CAACwB,MAAM;kBACvCL,WAAW,EAAEnC,OAAO,CAACmC,WAAW;kBAChCM,qBAAqB,EAAEzC,OAAO,CAACuC,UAAU;kBACzCG,wBAAwB,EAAE1C,OAAO,CAACuC;gBAAU,GACzChE,kCAAkC,CAAC4C,cAAc,CAAC,EACrD;cAAA;gBAAA;cAAA;gBAAA;gBAAA;gBAEFD,IAAI,CAACG,SAAS,CAAC;kBACbC,IAAI,EAAEtD,cAAc,CAACuD,KAAK;kBAC1BC,OAAO,EAAE,aAAEA;iBACZ,CAAC;gBAAC;cAAA;gBAAA;gBAGHN,IAAI,CAACO,GAAG,EAAE;gBAAC;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAEd;MAAA;QAAA;MAAA;MAAA;IAAA;IAED;;;;;;;EAAA;IAAA;IAAA;MAAA,iFAOO;QAAA;UAAA;UAAA;UAAA;UAAA;UAAA;UAAA;UAAA;QAAA;UAAA;YAAA;cAAA;gBACLzB,qEAAwC,EAAE;gBAAA,eAETxB,UAAU,CAAC,gCAAgC,EAAEwB,OAAO,CAAC,EAA9EkB,IAAI,gBAAJA,IAAI,EAAEC,cAAc,gBAAdA,cAAc;gBAAA;gBAAA;gBAAA,OAGR,IAAI,CAACqB,MAAM,CAACrB,cAAc,CAAC;cAAA;gBAAvCO,GAAG;gBAAA,kCACTC;kBACEC,SAAS,EAAE;gBAAI,GACZF,GAAG;kBACNG,SAAS,EAAEH,GAAG,CAACG;gBAAS;cAAA;gBAAA;gBAAA;gBAAA,MAGtB,oBAAEC,OAAO,0CAAEC,SAAS,MAAK,mBAAmB;kBAAA;kBAAA;gBAAA;gBAC9Cb,IAAI,CAACG,SAAS,CAAC;kBACbC,IAAI,EAAEtD,cAAc,CAACuD,KAAK;kBAC1BC,OAAO,EAAE;iBACV,CAAC;gBAAC,kCACHG;kBACEC,SAAS,EAAE;gBAAK,GACb,mBAAEI,QAAQ,0CAAEC,aAAa;kBAC5BJ,SAAS,EAAE,aAAEG;gBAAQ;cAAA;gBAGzBd,IAAI,CAACG,SAAS,CAAC;kBACbC,IAAI,EAAEtD,cAAc,CAACuD,KAAK;kBAC1BC,OAAO,EAAE,aAAEA;iBACZ,CAAC;gBAAC;cAAA;gBAAA;gBAGHN,IAAI,CAACO,GAAG,EAAE;gBAAC;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAEd;MAAA;QAAA;MAAA;MAAA;IAAA;IAED;;;;;;;;;;;;EAAA;IAAA;IAAA;MAAA,8EAYO,kBACLkB,QAAmB;QAAA;UAAA;UAAA;UAAA;UAAA;QAAA;UAAA;YAAA;cAAA;gBACnB3C,qEAAuC,EAAE;gBAEzC,IAAI,CAACA,OAAO,CAACuC,UAAU,EAAE;kBACvBvC,OAAO,CAACuC,UAAU,GAAG,EAAE;;gBACxB,KAEGvC,OAAO,CAACuC,UAAU,CAACK,iBAAiB;kBAAA;kBAAA;gBAAA;gBAAA,MAChC,IAAIC,UAAU,CAClB,mGAAmG,CACpG;cAAA;gBAAA,eAG8BrE,UAAU,CAAC,6BAA6B,EAAEwB,OAAO,CAAC,EAA3EkB,IAAI,gBAAJA,IAAI,EAAEC,cAAc,gBAAdA,cAAc;gBAAA;gBAAA;gBAAA,OAGb,IAAI,CAACH,gBAAgB,CAAC8B,WAAW;kBAC5CX,WAAW,EAAEnC,OAAO,CAACmC,WAAW;kBAChCM,qBAAqB,EAAEzC,OAAO,CAACuC,UAAU;kBACzCI,QAAQ,EAARA,QAAQ;kBACRD,wBAAwB,EAAE1C,OAAO,CAACuC;gBAAU,GACzChE,kCAAkC,CAAC4C,cAAc,CAAC,EACrD;cAAA;gBAAA;cAAA;gBAAA;gBAAA;gBAEFD,IAAI,CAACG,SAAS,CAAC;kBACbC,IAAI,EAAEtD,cAAc,CAACuD,KAAK;kBAC1BC,OAAO,EAAE,aAAEA;iBACZ,CAAC;gBAAC;cAAA;gBAAA;gBAGHN,IAAI,CAACO,GAAG,EAAE;gBAAC;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAEd;MAAA;QAAA;MAAA;MAAA;IAAA;IAED;;;;;;;;;;;EAAA;IAAA;IAAA;MAAA,kFAWO;QAAA;UAAA;UAAA;UAAA;UAAA;UAAA;UAAA;UAAA;UAAA;UAAA;UAAA;QAAA;UAAA;YAAA;cAAA;gBACLzB,qEAA2C,EAAE;gBAE7C,IAAI,CAACA,OAAO,CAACuC,UAAU,EAAE;kBACvBvC,OAAO,CAACuC,UAAU,GAAG,EAAE;;gBACxB,eAEgC/D,UAAU,CAAC,iCAAiC,EAAEwB,OAAO,CAAC,EAA/EkB,IAAI,gBAAJA,IAAI,EAAEC,cAAc,gBAAdA,cAAc;gBAAA;gBAAA;gBAAA,OAGH,IAAI,CAACH,gBAAgB,CAAC+B,eAAe;kBAC1DZ,WAAW,EAAEnC,OAAO,CAACmC,WAAW;kBAChCM,qBAAqB,EAAEzC,OAAO,CAACuC;gBAAU,GACtChE,kCAAkC,CAAC4C,cAAc,CAAC,EACrD;cAAA;gBAJIa,QAAQ;gBAMRN,GAAG,GAAqC;kBAC5CG,SAAS,EAAEG,QAAQ,CAACH,SAAS;kBAC7BmB,gBAAgB,EAAEhB,QAAQ,CAACgB,gBAAgB;kBAC3CC,IAAI,EAAEjB,QAAQ,CAACiB,IAAI;kBACnBC,IAAI,EAAElB,QAAQ,CAACkB,IAAI;kBACnBnB,SAAS,EAAEC,QAAQ,CAACD,SAAS;kBAC7BoB,YAAY,EAAEnB,QAAQ,CAACmB,YAAY;kBACnCC,SAAS,EAAEpB,QAAQ,CAACoB,SAAS;kBAC7BC,eAAe,EAAErB,QAAQ,CAACqB,eAAe;kBACzCC,iBAAiB,EAAE,EAAE;kBACrBC,OAAO,EAAEvB,QAAQ,CAACuB;iBACnB;gBAAA,uCAEwBvB,QAAQ;gBAAA;kBAAjC,oDAAmC;oBAAxBwB,UAAU;oBACfC,YAAY,GAAQC,SAAS;oBACjC,IAAIF,UAAU,CAACC,YAAY,EAAE;sBAC3BA,YAAY,GAAG;wBACbE,WAAW,EAAEH,UAAU,CAACC,YAAY,CAACE;uBACtC;sBAED,IAAIH,UAAU,CAACC,YAAY,CAACG,SAAS,EAAE;wBACrCH,YAAY,CAACG,SAAS,GAAG,IAAIC,IAAI,CAACL,UAAU,CAACC,YAAY,CAACG,SAAS,CAAC;;sBAGtE,IAAIJ,UAAU,CAACC,YAAY,CAACK,QAAQ,EAAE;wBACpCL,YAAY,CAACK,QAAQ,GAAG,IAAID,IAAI,CAACL,UAAU,CAACC,YAAY,CAACK,QAAQ,CAAC;;;oBAItEpC,GAAG,CAAC4B,iBAAiB,CAACS,IAAI,CAAC;sBACzBN,YAAY,EAAZA,YAAY;sBACZO,EAAE,EAAER,UAAU,CAACQ;qBAChB,CAAC;;gBACH;kBAAA;gBAAA;kBAAA;gBAAA;gBAAA,kCAEMtC,GAAG;cAAA;gBAAA;gBAAA;gBAEVR,IAAI,CAACG,SAAS,CAAC;kBACbC,IAAI,EAAEtD,cAAc,CAACuD,KAAK;kBAC1BC,OAAO,EAAE,aAAEA;iBACZ,CAAC;gBAAC;cAAA;gBAAA;gBAGHN,IAAI,CAACO,GAAG,EAAE;gBAAC;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAEd;MAAA;QAAA;MAAA;MAAA;IAAA;IAED;;;;;;;;;;;;;;;;;EAAA;IAAA;IAAA;MAAA,kFAiBO,kBACLwC,MAAyB,EACzBC,YAAiC;QAAA;UAAA;UAAA;UAAA;UAAA;UAAA;UAAA;UAAA;UAAA;QAAA;UAAA;YAAA;cAAA;gBACjClE,qEAA2C,EAAE;gBAE7CA,OAAO,CAACuC,UAAU,GAAGvC,OAAO,CAACuC,UAAU,IAAI,EAAE;gBAAC,eACb/D,UAAU,CAAC,iCAAiC,EAAEwB,OAAO,CAAC,EAA/EkB,IAAI,gBAAJA,IAAI,EAAEC,cAAc,gBAAdA,cAAc;gBAAA;gBAEpBgD,GAAG,GAA4B,EAAE;gBAAA,wCACdD,YAAY,IAAI,EAAE;gBAAA;kBAA3C,uDAA6C;oBAAlCV,UAAU;oBACnBW,GAAG,CAACJ,IAAI,CAAC;sBACPN,YAAY,EAAE;wBACZG,SAAS,EAAEJ,UAAU,CAACC,YAAY,CAACG,SAAS,GACxCvE,oBAAoB,CAACmE,UAAU,CAACC,YAAY,CAACG,SAAS,CAAC,GACvD,EAAE;wBACND,WAAW,EAAEH,UAAU,CAACC,YAAY,CAACE,WAAW;wBAChDG,QAAQ,EAAEN,UAAU,CAACC,YAAY,CAACK,QAAQ,GACtCzE,oBAAoB,CAACmE,UAAU,CAACC,YAAY,CAACK,QAAQ,CAAC,GACtD;uBACL;sBACDE,EAAE,EAAER,UAAU,CAACQ;qBAChB,CAAC;;gBACH;kBAAA;gBAAA;kBAAA;gBAAA;gBAAA;gBAAA,OAEY,IAAI,CAAChD,gBAAgB,CAACoD,eAAe;kBAChDjC,WAAW,EAAEnC,OAAO,CAACmC,WAAW;kBAChC8B,MAAM,EAANA,MAAM;kBACNC,YAAY,EAAEC,GAAG;kBACjB1B,qBAAqB,EAAEzC,OAAO,CAACuC,UAAU;kBACzCG,wBAAwB,EAAE1C,OAAO,CAACuC;gBAAU,GACzChE,kCAAkC,CAAC4C,cAAc,CAAC,EACrD;cAAA;gBAAA;cAAA;gBAAA;gBAAA;gBAEFD,IAAI,CAACG,SAAS,CAAC;kBACbC,IAAI,EAAEtD,cAAc,CAACuD,KAAK;kBAC1BC,OAAO,EAAE,aAAEA;iBACZ,CAAC;gBAAC;cAAA;gBAAA;gBAGHN,IAAI,CAACO,GAAG,EAAE;gBAAC;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAEd;MAAA;QAAA;MAAA;MAAA;IAAA;IAED;;;;;;EAAA;IAAA;IAAA,OAMO,4BAAmB4C,cAAuB;MAC/C,OAAO,IAAI9E,eAAe,CAAC,IAAI,EAAE8E,cAAc,CAAC;IAClD;IAEA;;;;;;;;;;;;;;;;;;;;;;EAAA;IAAA;IAAA;MAAA,kFAsBO,mBACL/B,QAAgB,EAChBgC,IAAqB,EACrBC,aAAqB;QAAA;UAAA;UAAA;UAAA;UAAA;UAAA;UAAA;QAAA;UAAA;YAAA;cAAA;gBACrBvE,wEAAkC,EAAE;gBAAA,gBAEHxB,UAAU,CAAC,iCAAiC,EAAEwB,OAAO,CAAC,EAA/EkB,IAAI,iBAAJA,IAAI,EAAEC,cAAc,iBAAdA,cAAc;gBAAA;gBAEpBqD,eAAe,GAAG,IAAI,CAACC,kBAAkB,CAACnC,QAAQ,CAAC;gBAAA;gBAAA,OAClCkC,eAAe,CAACE,MAAM,CAACJ,IAAI,EAAEC,aAAa,EAAEpD,cAAc,CAAC;cAAA;gBAA5Ea,QAAQ;gBAAA,mCACP;kBACLwC,eAAe,EAAfA,eAAe;kBACfxC,QAAQ,EAARA;iBACD;cAAA;gBAAA;gBAAA;gBAEDd,IAAI,CAACG,SAAS,CAAC;kBACbC,IAAI,EAAEtD,cAAc,CAACuD,KAAK;kBAC1BC,OAAO,EAAE,cAAEA;iBACZ,CAAC;gBAAC;cAAA;gBAAA;gBAGHN,IAAI,CAACO,GAAG,EAAE;gBAAC;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAEd;MAAA;QAAA;MAAA;MAAA;IAAA;IAED;;;;;;;;;;;EAAA;IAAA;IAAA;MAAA,6EAWO,mBACLa,QAAgB;QAAA;UAAA;UAAA;UAAA;UAAA;UAAA;QAAA;UAAA;YAAA;cAAA;gBAChBtC,wEAAsC,EAAE;gBAAA,gBAEPxB,UAAU,CAAC,4BAA4B,EAAEwB,OAAO,CAAC,EAA1EkB,IAAI,iBAAJA,IAAI,EAAEC,cAAc,iBAAdA,cAAc;gBAAA;gBAEtBwD,UAAU,GAAG,IAAI,CAACC,aAAa,CAACtC,QAAQ,CAAC;gBAC7C,IAAItC,OAAO,CAAC6E,SAAS,EAAE;kBACrBF,UAAU,GAAGA,UAAU,CAACG,WAAW,CAAC9E,OAAO,CAAC6E,SAAS,CAAC;;gBACvD;gBAAA,OACYF,UAAU,CAACnC,MAAM,CAACrB,cAAc,CAAC;cAAA;gBAAA;cAAA;gBAAA;gBAAA;gBAE9CD,IAAI,CAACG,SAAS,CAAC;kBACbC,IAAI,EAAEtD,cAAc,CAACuD,KAAK;kBAC1BC,OAAO,EAAE,cAAEA;iBACZ,CAAC;gBAAC;cAAA;gBAAA;gBAGHN,IAAI,CAACO,GAAG,EAAE;gBAAC;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAEd;MAAA;QAAA;MAAA;MAAA;IAAA;IAED;;;;;;;;;;EAAA;IAAA;IAAA;MAAA,sFAUQ,mBACNsD,MAAe;QAAA;UAAA;UAAA;UAAA;UAAA;UAAA;UAAA;QAAA;UAAA;YAAA;cAAA;gBACf/E,wEAA4C,EAAE;gBAAA,gBAEbxB,UAAU,CAAC,qCAAqC,EAAEwB,OAAO,CAAC,EAAnFkB,IAAI,iBAAJA,IAAI,EAAEC,cAAc,iBAAdA,cAAc;gBAAA;gBAAA;gBAAA,OAEH,IAAI,CAACH,gBAAgB,CAACgE,mBAAmB;kBAC9DD,MAAM,EAANA;gBAAM,GACH/E,OAAO,GACPzB,kCAAkC,CAAC4C,cAAc,CAAC,EACrD;cAAA;gBAJIa,QAAQ;gBAMdA,QAAQ,CAACiD,OAAO,CAACC,SAAS,GAAG,EAAE;gBAC/B,IAAKlD,QAAQ,CAACiD,OAAe,CAAC,MAAM,CAAC,KAAKvB,SAAS,EAAE;kBACnD1B,QAAQ,CAACiD,OAAO,CAACC,SAAS,GAAGhG,gBAAgB,CAAE8C,QAAQ,CAACiD,OAAe,CAAC,MAAM,CAAC,CAAC;;gBAG5EE,eAAe,mCAChBnD,QAAQ;kBACXH,SAAS,kCACJG,QAAQ,CAACH,SAAS;oBACrBuD,UAAU,EAAExG,qCAAqC,CAACoD,QAAQ,CAACH,SAAS,CAACuD,UAAU;kBAAC;kBAElFH,OAAO,kCACFjD,QAAQ,CAACiD,OAAO;oBACnBC,SAAS,EAAElD,QAAQ,CAACiD,OAAO,CAACC,SAAS,CAACG,GAAG,CAAC,UAACC,eAAe,EAAI;sBAC5D,IAAMC,QAAQ,mCACTD,eAAe;wBAClBE,IAAI,EAAE7G,gBAAgB,CAAC2G,eAAe,CAACE,IAAI,CAAC;wBAC5CC,IAAI,EAAErG,MAAM,CAACkG,eAAe,CAACI,QAAQ,CAAC;wBACtCC,iCAAiC,EAAE1G,4BAA4B,CAC7DqG,eAAe,CAACM,yBAAyB;sBAC1C,EACF;sBACD,OAAOL,QAAQ;oBACjB,CAAC;kBAAC;gBAAA,EAEL;gBAAA,mCACMJ,eAAe;cAAA;gBAAA;gBAAA;gBAEtBjE,IAAI,CAACG,SAAS,CAAC;kBACbC,IAAI,EAAEtD,cAAc,CAACuD,KAAK;kBAC1BC,OAAO,EAAE,cAAEA;iBACZ,CAAC;gBAAC;cAAA;gBAAA;gBAGHN,IAAI,CAACO,GAAG,EAAE;gBAAC;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAEd;MAAA;QAAA;MAAA;MAAA;IAAA;IAED;;;;;;;;;;;EAAA;IAAA;IAAA;MAAA,2FAWQ,mBACNoE,SAAiB,EACjBd,MAAe;QAAA;UAAA;UAAA;UAAA;UAAA;UAAA;UAAA;UAAA;QAAA;UAAA;YAAA;cAAA;gBACf/E,wEAA4C,EAAE;gBAAA,gBAEbxB,UAAU,CACzC,0CAA0C,EAC1CwB,OAAO,CACR,EAHOkB,IAAI,iBAAJA,IAAI,EAAEC,cAAc,iBAAdA,cAAc;gBAAA;gBAAA;gBAAA,OAKH,IAAI,CAACH,gBAAgB,CAAC8E,wBAAwB,CAACD,SAAS;kBAC7Ed,MAAM,EAANA;gBAAM,GACH/E,OAAO,GACPzB,kCAAkC,CAAC4C,cAAc,CAAC,EACrD;cAAA;gBAJIa,QAAQ;gBAMdA,QAAQ,CAACiD,OAAO,CAACC,SAAS,GAAG,EAAE;gBAC/B,IAAKlD,QAAQ,CAACiD,OAAe,CAAC,MAAM,CAAC,KAAKvB,SAAS,EAAE;kBACnD1B,QAAQ,CAACiD,OAAO,CAACC,SAAS,GAAGhG,gBAAgB,CAAE8C,QAAQ,CAACiD,OAAe,CAAC,MAAM,CAAC,CAAC;;gBAGlFjD,QAAQ,CAACiD,OAAO,CAACc,YAAY,GAAG,EAAE;gBAClC,IAAK/D,QAAQ,CAACiD,OAAe,CAAC,YAAY,CAAC,KAAKvB,SAAS,EAAE;kBACzD1B,QAAQ,CAACiD,OAAO,CAACc,YAAY,GAAG5G,mBAAmB,CAChD6C,QAAQ,CAACiD,OAAe,CAAC,YAAY,CAAC,CACxC;;gBAGGE,eAAe,mCAChBnD,QAAQ;kBACXH,SAAS,kCACJG,QAAQ,CAACH,SAAS;oBACrBuD,UAAU,EAAEvG,0CAA0C,CAACmD,QAAQ,CAACH,SAAS,CAACuD,UAAU;kBAAC;kBAEvFH,OAAO,kCACFjD,QAAQ,CAACiD,OAAO;oBACnBC,SAAS,EAAElD,QAAQ,CAACiD,OAAO,CAACC,SAAS,CAACG,GAAG,CAAC,UAACC,eAAe,EAAI;sBAC5D,IAAMC,QAAQ,mCACTD,eAAe;wBAClBE,IAAI,EAAE7G,gBAAgB,CAAC2G,eAAe,CAACE,IAAI,CAAC;wBAC5CC,IAAI,EAAErG,MAAM,CAACkG,eAAe,CAACI,QAAQ,CAAC;wBACtCC,iCAAiC,EAAE1G,4BAA4B,CAC7DqG,eAAe,CAACM,yBAAyB;sBAC1C,EACF;sBACD,OAAOL,QAAQ;oBACjB,CAAC,CAAC;oBACFQ,YAAY,EAAE,cAAQ,CAACd,OAAO,CAACc,YAAY,0CAAEV,GAAG,CAAC,UAACW,kBAAkB,EAAI;sBACtE,IAAMC,UAAU,GAAe;wBAC7BT,IAAI,EAAE7G,gBAAgB,CAACqH,kBAAkB,CAACR,IAAI;uBAC/C;sBACD,OAAOS,UAAU;oBACnB,CAAC;kBAAC;gBAAA,EAEL;gBAAA,mCACMd,eAAe;cAAA;gBAAA;gBAAA;gBAEtBjE,IAAI,CAACG,SAAS,CAAC;kBACbC,IAAI,EAAEtD,cAAc,CAACuD,KAAK;kBAC1BC,OAAO,EAAE,cAAEA;iBACZ,CAAC;gBAAC;cAAA;gBAAA;gBAGHN,IAAI,CAACO,GAAG,EAAE;gBAAC;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAEd;MAAA;QAAA;MAAA;MAAA;IAAA;IAED;;;;;;;;;;;;EAAA;IAAA;IAAA,OAYe,sBACbsD,MAAe,EAC+B;MAAA,IAA9C/E,8EAA4C,EAAE;;;;;;;sBAG1C,CAAC,CAAC+E,MAAM,IAAIA,MAAM,KAAKrB,SAAS;kBAAA;kBAAA;gBAAA;cAAA;gBAAA;gBAED,eAAM,IAAI,CAACsB,mBAAmB,CAACD,MAAM,EAAE/E,OAAO,CAAC;cAAA;gBAA9EkG,4BAA4B;gBAC5BnB,MAAM,GAAGmB,4BAA4B,CAACC,iBAAiB;gBAAC,gBACxDC;gBAAA;gBAAM,eAAMF,4BAA4B;cAAA;gBAAA;gBAAA;gBAAxC;cAAwC;gBAAA;gBAAxC;cAAwC;gBAAA,IACjCnB,MAAM;kBAAA;kBAAA;gBAAA;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;OAElB;;IAED;;;;;EAAA;IAAA;IAAA,OAKe,qBACiC;MAAA,IAA9C/E,8EAA4C,EAAE;;;;;;;;gBAGGqG,uBAAI,CAACC,YAAY,CAACvB,MAAM,EAAE/E,OAAO,CAAC;cAAA;gBAAA;gBAAA;cAAA;gBAAAuG;gBAAA;kBAAA;kBAAA;gBAAA;gBAAlEL,4BAA4B;gBAAA,gBAC3CE;gBAAA,gCAAOI,2DAA4B,CAACvB,OAAO,CAACC,SAAS;cAAA;gBAAA;gBAAA;gBAArD;cAAqD;gBAAA;gBAAA;cAAA;gBAAA;gBAAA;cAAA;gBAAA;gBAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OAExD;;IAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA;IAAA;IAAA,OAsEO,yBACkC;MAAA;QAAA;MAAA,IAAvClF,8EAAqC,EAAE;MAEvC,IAAMyG,OAAO,GAA2B,EAAE;MAC1C,IAAIzG,OAAO,CAAC0G,WAAW,EAAE;QACvBD,OAAO,CAAC1C,IAAI,CAAC,MAAM,CAAC;;MAEtB,IAAI/D,OAAO,CAAC2G,cAAc,EAAE;QAC1BF,OAAO,CAAC1C,IAAI,CAAC,SAAS,CAAC;;MAEzB,IAAI/D,OAAO,CAAC4G,eAAe,EAAE;QAC3BH,OAAO,CAAC1C,IAAI,CAAC,UAAU,CAAC;;MAE1B,IAAI/D,OAAO,CAAC6G,gBAAgB,EAAE;QAC5BJ,OAAO,CAAC1C,IAAI,CAAC,WAAW,CAAC;;MAE3B,IAAI/D,OAAO,CAAC8G,eAAe,EAAE;QAC3BL,OAAO,CAAC1C,IAAI,CAAC,UAAU,CAAC;;MAE1B,IAAI/D,OAAO,CAAC+G,sBAAsB,EAAE;QAClCN,OAAO,CAAC1C,IAAI,CAAC,kBAAkB,CAAC;;MAElC,IAAI/D,OAAO,CAACgH,WAAW,EAAE;QACvBP,OAAO,CAAC1C,IAAI,CAAC,MAAM,CAAC;;MAEtB,IAAI/D,OAAO,CAACiH,0BAA0B,EAAE;QACtCR,OAAO,CAAC1C,IAAI,CAAC,qBAAqB,CAAC;;MAErC,IAAI/D,OAAO,CAACkH,yBAAyB,EAAE;QACrCT,OAAO,CAAC1C,IAAI,CAAC,oBAAoB,CAAC;;MAEpC,IAAI/D,OAAO,CAACmH,gBAAgB,EAAE;QAC5BV,OAAO,CAAC1C,IAAI,CAAC,WAAW,CAAC;;MAE3B,IAAI/D,OAAO,CAACoH,MAAM,KAAK,EAAE,EAAE;QACzBpH,OAAO,CAACoH,MAAM,GAAG1D,SAAS;;MAG5B,IAAMvC,cAAc,mCACfnB,OAAO,GACNyG,OAAO,CAACY,MAAM,GAAG,CAAC,GAAG;QAAEZ,OAAO,EAAEA;MAAO,CAAE,GAAG,EAAE,CACnD;MAED;MACA,IAAMa,IAAI,GAAG,IAAI,CAACC,SAAS,CAACpG,cAAc,CAAC;MAC3C;QACE;;;QAGAqG,IAAI;UACF,OAAOF,IAAI,CAACE,IAAI,EAAE;QACpB;MAAC,yBAIAC,MAAM,CAACC,aAAa,cAAC;QACpB,OAAO,IAAI;MACb,CAAC,mCAIO,kBAAgC;QAAA,IAA/BC,+EAAyB,EAAE;QAClC,OAAO,MAAI,CAACrB,YAAY,CAACqB,QAAQ,CAACxB,iBAAiB;UACjDyB,WAAW,EAAED,QAAQ,CAACC;QAAW,GAC9BzG,cAAc,EACjB;MACJ,CAAC;IAEL;IAEA;;;;;;;;;;;;;EAAA;IAAA;IAAA,OAae,+BACb0E,SAAiB,EACjBd,MAAe,EAC+B;MAAA,IAA9C/E,8EAA4C,EAAE;;;;;;;sBAG1C,CAAC,CAAC+E,MAAM,IAAIA,MAAM,KAAKrB,SAAS;kBAAA;kBAAA;gBAAA;cAAA;gBAAA;gBAEI,eAAM,IAAI,CAACoC,wBAAwB,CACrED,SAAS,EACTd,MAAM,EACN/E,OAAO,CACR;cAAA;gBAJD6H,iCAAiC;gBAKjC9C,MAAM,GAAG8C,iCAAiC,CAAC1B,iBAAiB;gBAAC,gBAC7DC;gBAAA;gBAAM,eAAMyB,iCAAiC;cAAA;gBAAA;gBAAA;gBAA7C;cAA6C;gBAAA;gBAA7C;cAA6C;gBAAA,IACtC9C,MAAM;kBAAA;kBAAA;gBAAA;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;OAElB;;IAED;;;;;;EAAA;IAAA;IAAA,OAMe,8BACbc,SAAiB,EAC6B;MAAA,IAA9C7F,8EAA4C,EAAE;;;;;;;;gBAGQqG,uBAAI,CAACyB,qBAAqB,CAC9EjC,SAAS,EACTd,MAAM,EACN/E,OAAO,CACR;cAAA;gBAAA;gBAAA;cAAA;gBAAAuG;gBAAA;kBAAA;kBAAA;gBAAA;gBAJgBsB,iCAAiC;gBAK1C5C,OAAO,GAAG4C,iCAAiC,CAAC5C,OAAO;gBAAA,KACrDA,OAAO,CAACc,YAAY;kBAAA;kBAAA;gBAAA;gBAAA,wCACDd,OAAO,CAACc,YAAY;gBAAA;gBAAA;cAAA;gBAAA;kBAAA;kBAAA;gBAAA;gBAA9BqB,MAAM;gBAAA;gBACf;kBACE/G,IAAI,EAAE;gBAAQ,GACX+G,MAAM,EACV;cAAA;gBAAA;gBAHD;cAGC;gBAAA;gBAAA;cAAA;gBAAA;gBAAA;cAAA;gBAAA;gBAAA;gBAAA;cAAA;gBAAA;gBAAA;gBAAA;cAAA;gBAAA,wCAGcnC,OAAO,CAACC,SAAS;gBAAA;gBAAA;cAAA;gBAAA;kBAAA;kBAAA;gBAAA;gBAAzB6C,IAAI;gBAAA;gBACb;kBAAQ1H,IAAI,EAAE;gBAAM,GAAK0H,IAAI,EAAE;cAAA;gBAAA;gBAA/B;cAA+B;gBAAA;gBAAA;cAAA;gBAAA;gBAAA;cAAA;gBAAA;gBAAA;gBAAA;cAAA;gBAAA;gBAAA;gBAAA;cAAA;gBAAA;gBAAA;cAAA;gBAAA;gBAAA;cAAA;gBAAA;gBAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OAGpC;;IAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA;IAAA;IAAA,OA8EO,8BACLlC,SAAiB,EACsB;MAAA;QAAA;MAAA,IAAvC7F,8EAAqC,EAAE;MAKvC,IAAI6F,SAAS,KAAK,EAAE,EAAE;QACpB,MAAM,IAAIhD,UAAU,CAAC,iDAAiD,CAAC;;MAGzE,IAAM4D,OAAO,GAA2B,EAAE;MAC1C,IAAIzG,OAAO,CAAC0G,WAAW,EAAE;QACvBD,OAAO,CAAC1C,IAAI,CAAC,MAAM,CAAC;;MAEtB,IAAI/D,OAAO,CAAC2G,cAAc,EAAE;QAC1BF,OAAO,CAAC1C,IAAI,CAAC,SAAS,CAAC;;MAEzB,IAAI/D,OAAO,CAAC4G,eAAe,EAAE;QAC3BH,OAAO,CAAC1C,IAAI,CAAC,UAAU,CAAC;;MAE1B,IAAI/D,OAAO,CAAC6G,gBAAgB,EAAE;QAC5BJ,OAAO,CAAC1C,IAAI,CAAC,WAAW,CAAC;;MAE3B,IAAI/D,OAAO,CAAC8G,eAAe,EAAE;QAC3BL,OAAO,CAAC1C,IAAI,CAAC,UAAU,CAAC;;MAE1B,IAAI/D,OAAO,CAAC+G,sBAAsB,EAAE;QAClCN,OAAO,CAAC1C,IAAI,CAAC,kBAAkB,CAAC;;MAElC,IAAI/D,OAAO,CAACgH,WAAW,EAAE;QACvBP,OAAO,CAAC1C,IAAI,CAAC,MAAM,CAAC;;MAEtB,IAAI/D,OAAO,CAACiH,0BAA0B,EAAE;QACtCR,OAAO,CAAC1C,IAAI,CAAC,qBAAqB,CAAC;;MAErC,IAAI/D,OAAO,CAACkH,yBAAyB,EAAE;QACrCT,OAAO,CAAC1C,IAAI,CAAC,oBAAoB,CAAC;;MAEpC,IAAI/D,OAAO,CAACmH,gBAAgB,EAAE;QAC5BV,OAAO,CAAC1C,IAAI,CAAC,WAAW,CAAC;;MAE3B,IAAI/D,OAAO,CAACoH,MAAM,KAAK,EAAE,EAAE;QACzBpH,OAAO,CAACoH,MAAM,GAAG1D,SAAS;;MAG5B,IAAMvC,cAAc,mCACfnB,OAAO,GACNyG,OAAO,CAACY,MAAM,GAAG,CAAC,GAAG;QAAEZ,OAAO,EAAEA;MAAO,CAAE,GAAG,EAAE,CACnD;MACD;MACA,IAAMa,IAAI,GAAG,IAAI,CAACU,oBAAoB,CAACnC,SAAS,EAAE1E,cAAc,CAAC;MACjE;QACE;;;QAGMqG,IAAI;UAAA;YAAA;cAAA;gBAAA;kBAAA;oBAAA,mCACDF,IAAI,CAACE,IAAI,EAAE;kBAAA;kBAAA;oBAAA;gBAAA;cAAA;YAAA;UAAA;QACpB;MAAC,0BAIAC,MAAM,CAACC,aAAa,cAAC;QACpB,OAAO,IAAI;MACb,CAAC,oCAIO,kBAAgC;QAAA,IAA/BC,+EAAyB,EAAE;QAClC,OAAO,MAAI,CAACG,qBAAqB,CAACjC,SAAS,EAAE8B,QAAQ,CAACxB,iBAAiB;UACrEyB,WAAW,EAAED,QAAQ,CAACC;QAAW,GAC9BzG,cAAc,EACjB;MACJ,CAAC;IAEL;IAEA;;;;;;;;;;;;;;;;;EAAA;IAAA;IAAA;MAAA,yFAiBQ,mBACN8G,sBAA8B,EAC9BlD,MAAe;QAAA;UAAA;UAAA;UAAA;UAAA;UAAA;UAAA;QAAA;UAAA;YAAA;cAAA;gBACf/E,wEAAkD,EAAE;gBAAA,gBAEnBxB,UAAU,CAAC,wCAAwC,EAAEwB,OAAO,CAAC,EAAtFkB,IAAI,iBAAJA,IAAI,EAAEC,cAAc,iBAAdA,cAAc;gBAAA;gBAAA;gBAAA,OAGH,IAAI,CAACH,gBAAgB,CAACkH,WAAW;kBACtD/F,WAAW,EAAEnC,OAAO,CAACmC,WAAW;kBAChCgG,KAAK,EAAEF,sBAAsB;kBAC7BlD,MAAM,EAANA,MAAM;kBACN6C,WAAW,EAAE5H,OAAO,CAAC4H;gBAAW,GAC7BrJ,kCAAkC,CAAC4C,cAAc,CAAC,EACrD;cAAA;gBANIa,QAAQ;gBAQRmD,eAAe,mCAChBnD,QAAQ;kBACXH,SAAS,EAAEG,QAAQ,CAACH,SAAS;kBAC7BuG,KAAK,EAAEpG,QAAQ,CAACoG,KAAK,CAAC/C,GAAG,CAAC,UAAC0C,IAAI,EAAI;;oBACjC,IAAIM,QAAQ,GAAG,EAAE;oBACjB,IAAI,WAAI,CAAC5C,IAAI,0CAAE6C,UAAU,CAACjB,MAAM,MAAK,CAAC,EAAE;sBACtCgB,QAAQ,GAAGN,IAAI,CAACtC,IAAI,CAAC6C,UAAU,CAAC,CAAC,CAAC,CAACC,KAAK;;oBAE1C,uCAAYR,IAAI;sBAAEtC,IAAI,EAAErG,MAAM,CAAC2I,IAAI,CAACtC,IAAI,CAAC;sBAAE4C,QAAQ,EAARA;oBAAQ;kBACrD,CAAC;gBAAC,EACH;gBAAA,mCACMlD,eAAe;cAAA;gBAAA;gBAAA;gBAEtBjE,IAAI,CAACG,SAAS,CAAC;kBACbC,IAAI,EAAEtD,cAAc,CAACuD,KAAK;kBAC1BC,OAAO,EAAE,cAAEA;iBACZ,CAAC;gBAAC;cAAA;gBAAA;gBAGHN,IAAI,CAACO,GAAG,EAAE;gBAAC;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAEd;MAAA;QAAA;MAAA;MAAA;IAAA;IAED;;;;;;;;;;;;;;;;EAAA;IAAA;IAAA,OAgBe,iCACbwG,sBAA8B,EAC9BlD,MAAe,EACqC;MAAA,IAApD/E,8EAAkD,EAAE;;;;;;;sBAGhD,CAAC,CAAC+E,MAAM,IAAIA,MAAM,KAAKrB,SAAS;kBAAA;kBAAA;gBAAA;cAAA;gBAAA;gBAErB,eAAM,IAAI,CAAC8E,sBAAsB,CAACP,sBAAsB,EAAElD,MAAM,EAAE/E,OAAO,CAAC;cAAA;gBAArFgC,QAAQ;gBACRA,QAAQ,CAACoG,KAAK,GAAGpG,QAAQ,CAACoG,KAAK,IAAI,EAAE;gBACrCrD,MAAM,GAAG/C,QAAQ,CAACmE,iBAAiB;gBAAC;gBACpC,eAAMnE,QAAQ;cAAA;gBAAA;gBAAd;cAAc;gBAAA,IACP+C,MAAM;kBAAA;kBAAA;gBAAA;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;OAElB;;IAED;;;;;;;;;EAAA;IAAA;IAAA,OASe,8BACbkD,sBAA8B,EACsB;MAAA,IAApDjI,8EAAkD,EAAE;;;;;;;;gBAGxBqG,uBAAI,CAACoC,uBAAuB,CACtDR,sBAAsB,EACtBlD,MAAM,EACN/E,OAAO,CACR;cAAA;gBAAA;gBAAA;cAAA;gBAAAuG;gBAAA;kBAAA;kBAAA;gBAAA;gBAJgBtB,OAAO;gBAAA,gBAKtBmB;gBAAA,gCAAOI,sCAAO,CAAC4B,KAAK;cAAA;gBAAA;gBAAA;gBAApB;cAAoB;gBAAA;gBAAA;cAAA;gBAAA;gBAAA;cAAA;gBAAA;gBAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OAEvB;;IAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA;IAAA;IAAA,OA6EO,yBACLH,sBAA8B,EACc;MAAA;QAAA;MAAA,IAA5CjI,8EAA0C,EAAE;MAE5C;MACA,IAAM0I,kBAAkB,qBACnB1I,OAAO,CACX;MAED,IAAMsH,IAAI,GAAG,IAAI,CAACqB,oBAAoB,CAACV,sBAAsB,EAAES,kBAAkB,CAAC;MAClF;QACE;;;QAGAlB,IAAI;UACF,OAAOF,IAAI,CAACE,IAAI,EAAE;QACpB;MAAC,0BAIAC,MAAM,CAACC,aAAa,cAAC;QACpB,OAAO,IAAI;MACb,CAAC,oCAIO,kBAAgC;QAAA,IAA/BC,+EAAyB,EAAE;QAClC,OAAO,MAAI,CAACc,uBAAuB,CAACR,sBAAsB,EAAEN,QAAQ,CAACxB,iBAAiB;UACpFyB,WAAW,EAAED,QAAQ,CAACC;QAAW,GAC9Bc,kBAAkB,EACrB;MACJ,CAAC;IAEL;EAAC;IAAA;IAAA,OAEO,mCAAuB;MAC7B,IAAIvI,aAAa;MACjB,IAAI;QACF;QACA;QACA;QACA;QACA;QAEA,IAAMyI,SAAS,GAAG7K,UAAU,CAAC8K,KAAK,CAAC,IAAI,CAAC3I,GAAG,CAAC;QAE5C,IAAI0I,SAAS,CAACE,OAAO,EAAG,CAACC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,KAAK,MAAM,EAAE;UACjD;UACA;UACA;UACA5I,aAAa,GAAGyI,SAAS,CAACI,OAAO,EAAG,CAACD,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;SACnD,MAAM,IAAI/J,iBAAiB,CAAC4J,SAAS,CAAC,EAAE;UACvC;UACA;UACA;UACAzI,aAAa,GAAGyI,SAAS,CAACI,OAAO,EAAG,CAACD,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;SACnD,MAAM;UACL;UACA;UACA5I,aAAa,GAAGyI,SAAS,CAACI,OAAO,EAAG,CAACD,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;;QAGpD;QACA5I,aAAa,GAAG8I,kBAAkB,CAAC9I,aAAa,CAAC;QAEjD,IAAI,CAACA,aAAa,EAAE;UAClB,MAAM,IAAIS,KAAK,CAAC,oCAAoC,CAAC;;QAGvD,OAAOT,aAAa;OACrB,CAAC,OAAO+I,KAAU,EAAE;QACnB,MAAM,IAAItI,KAAK,CAAC,4DAA4D,CAAC;;IAEjF;IAEA;;;;;;;;;;;EAAA;IAAA;IAAA,OAWO,wBAAeZ,OAAuC;MAAA;MAC3D,OAAO,IAAImJ,OAAO,CAAC,UAACC,OAAO,EAAI;QAC7B,IAAI,EAAE,MAAI,CAACC,UAAU,YAAYnL,0BAA0B,CAAC,EAAE;UAC5D,MAAM,IAAI2E,UAAU,CAClB,uFAAuF,CACxF;;QAGH,IAAMyG,GAAG,GAAGhK,8BAA8B;UAEtCa,aAAa,EAAE,MAAI,CAACW;QAAc,GAC/Bd,OAAO,GAEZ,MAAI,CAACqJ,UAAU,CAChB,CAACE,QAAQ,EAAE;QAEZH,OAAO,CAAC1K,gBAAgB,CAAC,MAAI,CAACwB,GAAG,EAAEoJ,GAAG,CAAC,CAAC;MAC1C,CAAC,CAAC;IACJ;IAEA;;;;;;;EAAA;IAAA;IAAA,OAOO,8BAAkB;MACvB,OAAO,IAAI1J,eAAe,CAAC,IAAI,CAACM,GAAG,EAAE,IAAI,CAACD,QAAQ,CAAC;IACrD;EAAC;EAAA;AAAA,EAn/CkC3B,aAAa","names":["getDefaultProxySettings","isNode","isTokenCredential","URLBuilder","SpanStatusCode","AnonymousCredential","StorageSharedKeyCredential","Container","newPipeline","isPipelineLike","StorageClient","convertTracingToRequestOptionsBase","createSpan","appendToURLPath","appendToURLQuery","BlobNameToString","ConvertInternalResponseOfListBlobFlat","ConvertInternalResponseOfListBlobHierarchy","EscapePath","extractConnectionStringParts","isIpEndpointStyle","parseObjectReplicationRecord","ProcessBlobItems","ProcessBlobPrefixes","toTags","truncatedISO8061Date","generateBlobSASQueryParameters","BlobLeaseClient","AppendBlobClient","BlobClient","BlockBlobClient","PageBlobClient","BlobBatchClient","ContainerClient","urlOrConnectionString","credentialOrPipelineOrContainerName","options","pipeline","url","containerName","extractedCreds","kind","sharedKeyCredential","accountName","accountKey","encodeURIComponent","proxyOptions","proxyUri","Error","accountSas","_containerName","getContainerNameFromUrl","containerContext","storageClientContext","span","updatedOptions","create","setStatus","code","ERROR","message","end","res","Object","succeeded","_response","details","errorCode","response","parsedHeaders","getProperties","abortSignal","tracingOptions","statusCode","blobName","conditions","delete","leaseAccessConditions","modifiedAccessConditions","metadata","ifUnmodifiedSince","RangeError","setMetadata","getAccessPolicy","blobPublicAccess","date","etag","lastModified","requestId","clientRequestId","signedIdentifiers","version","identifier","accessPolicy","undefined","permissions","expiresOn","Date","startsOn","push","id","access","containerAcl","acl","setAccessPolicy","proposeLeaseId","body","contentLength","blockBlobClient","getBlockBlobClient","upload","blobClient","getBlobClient","versionId","withVersion","marker","listBlobFlatSegment","segment","blobItems","wrappedResponse","parsedBody","map","blobItemInteral","blobItem","name","tags","blobTags","objectReplicationSourceProperties","objectReplicationMetadata","delimiter","listBlobHierarchySegment","blobPrefixes","blobPrefixInternal","blobPrefix","listBlobsFlatSegmentResponse","continuationToken","__await","_b","listSegments","_c","__asyncDelegator","include","includeCopy","includeDeleted","includeMetadata","includeSnapshots","includeVersions","includeUncommitedBlobs","includeTags","includeDeletedWithVersions","includeImmutabilityPolicy","includeLegalHold","prefix","length","iter","listItems","next","Symbol","asyncIterator","settings","maxPageSize","listBlobsHierarchySegmentResponse","listHierarchySegments","blob","listItemsByHierarchy","tagFilterSqlExpression","filterBlobs","where","blobs","tagValue","blobTagSet","value","findBlobsByTagsSegment","findBlobsByTagsSegments","listSegmentOptions","findBlobsByTagsItems","parsedUrl","parse","getHost","split","getPath","decodeURIComponent","error","Promise","resolve","credential","sas","toString"],"sourceRoot":"","sources":["../../../src/ContainerClient.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport {\n  getDefaultProxySettings,\n  HttpRequestBody,\n  HttpResponse,\n  isNode,\n  isTokenCredential,\n  TokenCredential,\n  URLBuilder,\n} from \"@azure/core-http\";\nimport { PagedAsyncIterableIterator, PageSettings } from \"@azure/core-paging\";\nimport { SpanStatusCode } from \"@azure/core-tracing\";\nimport { AnonymousCredential } from \"./credentials/AnonymousCredential\";\nimport { StorageSharedKeyCredential } from \"./credentials/StorageSharedKeyCredential\";\nimport { Container } from \"./generated/src/operations\";\nimport {\n  BlobDeleteResponse,\n  BlobPrefix,\n  BlobProperties,\n  BlockBlobUploadResponse,\n  ContainerCreateResponse,\n  ContainerDeleteResponse,\n  ContainerEncryptionScope,\n  ContainerFilterBlobsHeaders,\n  ContainerGetAccessPolicyHeaders,\n  ContainerGetPropertiesResponse,\n  ContainerListBlobFlatSegmentHeaders,\n  ContainerListBlobHierarchySegmentHeaders,\n  ContainerSetAccessPolicyResponse,\n  ContainerSetMetadataResponse,\n  FilterBlobItem,\n  FilterBlobSegment,\n  FilterBlobSegmentModel,\n  LeaseAccessConditions,\n  ListBlobsFlatSegmentResponseModel,\n  ListBlobsHierarchySegmentResponseModel,\n  PublicAccessType,\n  SignedIdentifierModel,\n} from \"./generatedModels\";\nimport {\n  Metadata,\n  ObjectReplicationPolicy,\n  Tags,\n  ContainerRequestConditions,\n  ModifiedAccessConditions,\n} from \"./models\";\nimport { newPipeline, PipelineLike, isPipelineLike, StoragePipelineOptions } from \"./Pipeline\";\nimport { CommonOptions, StorageClient } from \"./StorageClient\";\nimport { convertTracingToRequestOptionsBase, createSpan } from \"./utils/tracing\";\nimport {\n  appendToURLPath,\n  appendToURLQuery,\n  BlobNameToString,\n  ConvertInternalResponseOfListBlobFlat,\n  ConvertInternalResponseOfListBlobHierarchy,\n  EscapePath,\n  extractConnectionStringParts,\n  isIpEndpointStyle,\n  parseObjectReplicationRecord,\n  ProcessBlobItems,\n  ProcessBlobPrefixes,\n  toTags,\n  truncatedISO8061Date,\n} from \"./utils/utils.common\";\nimport { ContainerSASPermissions } from \"./sas/ContainerSASPermissions\";\nimport { generateBlobSASQueryParameters } from \"./sas/BlobSASSignatureValues\";\nimport { BlobLeaseClient } from \"./BlobLeaseClient\";\nimport {\n  AppendBlobClient,\n  BlobClient,\n  BlobDeleteOptions,\n  BlockBlobClient,\n  BlockBlobUploadOptions,\n  CommonGenerateSasUrlOptions,\n  PageBlobClient,\n} from \"./Clients\";\nimport { BlobBatchClient } from \"./BlobBatchClient\";\nimport { ListBlobsIncludeItem } from \"./generated/src\";\n\n/**\n * Options to configure {@link ContainerClient.create} operation.\n */\nexport interface ContainerCreateOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * A collection of key-value string pair to associate with the container.\n   */\n  metadata?: Metadata;\n  /**\n   * Specifies whether data in the container may be accessed publicly and the level of access. Possible values include:\n   * - `container`: Specifies full public read access for container and blob data. Clients can enumerate blobs within the container via anonymous request, but cannot enumerate containers within the storage account.\n   * - `blob`: Specifies public read access for blobs. Blob data within this container can be read via anonymous request, but container data is not available. Clients cannot enumerate blobs within the container via anonymous request.\n   */\n  access?: PublicAccessType;\n  /**\n   * Container encryption scope info.\n   */\n  containerEncryptionScope?: ContainerEncryptionScope;\n}\n\n/**\n * Options to configure {@link ContainerClient.getProperties} operation.\n */\nexport interface ContainerGetPropertiesOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * If specified, contains the lease id that must be matched and lease with this id\n   * must be active in order for the operation to succeed.\n   */\n  conditions?: LeaseAccessConditions;\n}\n\n/**\n * Options to configure {@link ContainerClient.delete} operation.\n */\nexport interface ContainerDeleteMethodOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Conditions to meet when deleting the container.\n   */\n  conditions?: ContainerRequestConditions;\n}\n\n/**\n * Options to configure {@link ContainerClient.exists} operation.\n */\nexport interface ContainerExistsOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * Options to configure {@link ContainerClient.setMetadata} operation.\n */\nexport interface ContainerSetMetadataOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * If specified, contains the lease id that must be matched and lease with this id\n   * must be active in order for the operation to succeed.\n   */\n  conditions?: ContainerRequestConditions;\n}\n\n/**\n * Options to configure {@link ContainerClient.getAccessPolicy} operation.\n */\nexport interface ContainerGetAccessPolicyOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * If specified, contains the lease id that must be matched and lease with this id\n   * must be active in order for the operation to succeed.\n   */\n  conditions?: LeaseAccessConditions;\n}\n\n/**\n * Signed identifier.\n */\nexport interface SignedIdentifier {\n  /**\n   * a unique id\n   */\n  id: string;\n  /**\n   * Access Policy\n   */\n  accessPolicy: {\n    /**\n     * Optional. The date-time the policy is active\n     */\n    startsOn?: Date;\n    /**\n     * Optional. The date-time the policy expires\n     */\n    expiresOn?: Date;\n    /**\n     * The permissions for the acl policy\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-container-acl\n     */\n    permissions?: string;\n  };\n}\n\n/**\n * Contains response data for the {@link ContainerClient.getAccessPolicy} operation.\n */\nexport declare type ContainerGetAccessPolicyResponse = {\n  signedIdentifiers: SignedIdentifier[];\n} & ContainerGetAccessPolicyHeaders & {\n    /**\n     * The underlying HTTP response.\n     */\n    _response: HttpResponse & {\n      /**\n       * The parsed HTTP response headers.\n       */\n      parsedHeaders: ContainerGetAccessPolicyHeaders;\n      /**\n       * The response body as text (string format)\n       */\n      bodyAsText: string;\n      /**\n       * The response body as parsed JSON or XML\n       */\n      parsedBody: SignedIdentifierModel[];\n    };\n  };\n\n/**\n * Options to configure {@link ContainerClient.setAccessPolicy} operation.\n */\nexport interface ContainerSetAccessPolicyOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Conditions to meet when setting the access policy.\n   */\n  conditions?: ContainerRequestConditions;\n}\n\n/**\n * Options to configure Container - Acquire Lease operation.\n */\nexport interface ContainerAcquireLeaseOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Conditions to meet when acquiring the lease.\n   */\n  conditions?: ModifiedAccessConditions;\n}\n\n/**\n * Options to configure Container - Release Lease operation.\n */\nexport interface ContainerReleaseLeaseOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Conditions to meet when releasing the lease.\n   */\n  conditions?: ModifiedAccessConditions;\n}\n\n/**\n * Options to configure Container - Renew Lease operation.\n */\nexport interface ContainerRenewLeaseOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Conditions to meet when renewing the lease.\n   */\n  conditions?: ModifiedAccessConditions;\n}\n\n/**\n * Options to configure Container - Break Lease operation.\n */\nexport interface ContainerBreakLeaseOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Conditions to meet when breaking the lease.\n   */\n  conditions?: ModifiedAccessConditions;\n}\n\n/**\n * Options to configure Container - Change Lease operation.\n */\nexport interface ContainerChangeLeaseOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Conditions to meet when changing the lease.\n   */\n  conditions?: ModifiedAccessConditions;\n}\n\n/**\n * Options to configure the {@link ContainerClient.deleteBlob} operation.\n */\nexport interface ContainerDeleteBlobOptions extends BlobDeleteOptions {\n  /**\n   * An opaque DateTime value that, when present, specifies the version\n   * of the blob to delete. It's for service version 2019-10-10 and newer.\n   */\n  versionId?: string;\n}\n\n/**\n * Options to configure Container - List Segment operations.\n *\n * See:\n * - {@link ContainerClient.listSegments}\n * - {@link ContainerClient.listBlobFlatSegment}\n * - {@link ContainerClient.listBlobHierarchySegment}\n * - {@link ContainerClient.listHierarchySegments}\n * - {@link ContainerClient.listItemsByHierarchy}\n */\ninterface ContainerListBlobsSegmentOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Filters the results to return only containers\n   * whose name begins with the specified prefix.\n   */\n  prefix?: string;\n  /**\n   * Specifies the maximum number of containers\n   * to return. If the request does not specify maxPageSize, or specifies a\n   * value greater than 5000, the server will return up to 5000 items. Note\n   * that if the listing operation crosses a partition boundary, then the\n   * service will return a continuation token for retrieving the remainder of\n   * the results. For this reason, it is possible that the service will return\n   * fewer results than specified by maxPageSize, or than the default of 5000.\n   */\n  maxPageSize?: number;\n  /**\n   * Include this parameter to\n   * specify one or more datasets to include in the response.\n   */\n  include?: ListBlobsIncludeItem[];\n}\n\n/**\n * An interface representing BlobHierarchyListSegment.\n */\nexport interface BlobHierarchyListSegment {\n  blobPrefixes?: BlobPrefix[];\n  blobItems: BlobItem[];\n}\n\n/**\n * An enumeration of blobs\n */\nexport interface ListBlobsHierarchySegmentResponse {\n  serviceEndpoint: string;\n  containerName: string;\n  prefix?: string;\n  marker?: string;\n  maxPageSize?: number;\n  delimiter?: string;\n  segment: BlobHierarchyListSegment;\n  continuationToken?: string;\n}\n\n/**\n * Contains response data for the listBlobHierarchySegment operation.\n */\nexport type ContainerListBlobHierarchySegmentResponse = ListBlobsHierarchySegmentResponse &\n  ContainerListBlobHierarchySegmentHeaders & {\n    /**\n     * The underlying HTTP response.\n     */\n    _response: HttpResponse & {\n      /**\n       * The parsed HTTP response headers.\n       */\n      parsedHeaders: ContainerListBlobHierarchySegmentHeaders;\n\n      /**\n       * The response body as text (string format)\n       */\n      bodyAsText: string;\n\n      /**\n       * The response body as parsed JSON or XML\n       */\n      parsedBody: ListBlobsHierarchySegmentResponseModel;\n    };\n  };\n\n/**\n * An Azure Storage blob\n */\nexport interface BlobItem {\n  name: string;\n  deleted: boolean;\n  snapshot: string;\n  versionId?: string;\n  isCurrentVersion?: boolean;\n  properties: BlobProperties;\n  metadata?: { [propertyName: string]: string };\n  tags?: Tags;\n  objectReplicationSourceProperties?: ObjectReplicationPolicy[];\n  hasVersionsOnly?: boolean;\n}\n\n/**\n * An interface representing BlobFlatListSegment.\n */\nexport interface BlobFlatListSegment {\n  blobItems: BlobItem[];\n}\n\n/**\n * An enumeration of blobs\n */\nexport interface ListBlobsFlatSegmentResponse {\n  serviceEndpoint: string;\n  containerName: string;\n  prefix?: string;\n  marker?: string;\n  maxPageSize?: number;\n  segment: BlobFlatListSegment;\n  continuationToken?: string;\n}\n\n/**\n * Contains response data for the listBlobFlatSegment operation.\n */\nexport type ContainerListBlobFlatSegmentResponse = ListBlobsFlatSegmentResponse &\n  ContainerListBlobFlatSegmentHeaders & {\n    /**\n     * The underlying HTTP response.\n     */\n    _response: HttpResponse & {\n      /**\n       * The parsed HTTP response headers.\n       */\n      parsedHeaders: ContainerListBlobFlatSegmentHeaders;\n\n      /**\n       * The response body as text (string format)\n       */\n      bodyAsText: string;\n\n      /**\n       * The response body as parsed JSON or XML\n       */\n      parsedBody: ListBlobsFlatSegmentResponseModel;\n    };\n  };\n\n/**\n * Options to configure Container - List Blobs operations.\n *\n * See:\n * - {@link ContainerClient.listBlobsFlat}\n * - {@link ContainerClient.listBlobsByHierarchy}\n */\nexport interface ContainerListBlobsOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Filters the results to return only containers\n   * whose name begins with the specified prefix.\n   */\n  prefix?: string;\n\n  /**\n   * Specifies whether metadata related to any current or previous Copy Blob operation should be included in the response.\n   */\n  includeCopy?: boolean;\n  /**\n   * Specifies whether soft deleted blobs should be included in the response.\n   */\n  includeDeleted?: boolean;\n  /**\n   * Specifies whether blob metadata be returned in the response.\n   */\n  includeMetadata?: boolean;\n  /**\n   * Specifies whether snapshots should be included in the enumeration. Snapshots are listed from oldest to newest in the response.\n   */\n  includeSnapshots?: boolean;\n  /**\n   * Specifies whether versions should be included in the enumeration. Versions are listed from oldest to newest in the response.\n   */\n  includeVersions?: boolean;\n  /**\n   * Specifies whether blobs for which blocks have been uploaded, but which have not been committed using Put Block List, be included in the response.\n   */\n  includeUncommitedBlobs?: boolean;\n  /**\n   * Specifies whether blob tags be returned in the response.\n   */\n  includeTags?: boolean;\n  /**\n   * Specifies whether deleted blob with versions be returned in the response.\n   */\n  includeDeletedWithVersions?: boolean;\n  /**\n   * Specifies whether blob immutability policy be returned in the response.\n   */\n  includeImmutabilityPolicy?: boolean;\n  /**\n   * Specifies whether blob legal hold be returned in the response.\n   */\n  includeLegalHold?: boolean;\n}\n\n/**\n * Contains response data for the {@link ContainerClient.createIfNotExists} operation.\n */\nexport interface ContainerCreateIfNotExistsResponse extends ContainerCreateResponse {\n  /**\n   * Indicate whether the container is successfully created. Is false when the container is not changed as it already exists.\n   */\n  succeeded: boolean;\n}\n\n/**\n * Contains response data for the {@link ContainerClient.deleteIfExists} operation.\n */\nexport interface ContainerDeleteIfExistsResponse extends ContainerDeleteResponse {\n  /**\n   * Indicate whether the container is successfully deleted. Is false if the container does not exist in the first place.\n   */\n  succeeded: boolean;\n}\n\n/**\n * Options to configure {@link ContainerClient.generateSasUrl} operation.\n */\nexport interface ContainerGenerateSasUrlOptions extends CommonGenerateSasUrlOptions {\n  /**\n   * Optional only when identifier is provided. Specifies the list of permissions to be associated with the SAS.\n   */\n  permissions?: ContainerSASPermissions;\n}\n\n/**\n * Options to configure the {@link ContainerClient.findBlobsByTagsSegment} operation.\n */\ninterface ContainerFindBlobsByTagsSegmentOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Specifies the maximum number of blobs\n   * to return. If the request does not specify maxPageSize, or specifies a\n   * value greater than 5000, the server will return up to 5000 items. Note\n   * that if the listing operation crosses a partition boundary, then the\n   * service will return a continuation token for retrieving the remainder of\n   * the results. For this reason, it is possible that the service will return\n   * fewer results than specified by maxPageSize, or than the default of 5000.\n   */\n  maxPageSize?: number;\n}\n\n/**\n * Options to configure the {@link BlobServiceClient.findBlobsByTags} operation.\n */\nexport interface ContainerFindBlobByTagsOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * The response of {@link BlobServiceClient.findBlobsByTags} operation.\n */\nexport type ContainerFindBlobsByTagsSegmentResponse = FilterBlobSegment &\n  ContainerFilterBlobsHeaders & {\n    /**\n     * The underlying HTTP response.\n     */\n    _response: HttpResponse & {\n      /**\n       * The parsed HTTP response headers.\n       */\n      parsedHeaders: ContainerFilterBlobsHeaders;\n\n      /**\n       * The response body as text (string format)\n       */\n      bodyAsText: string;\n\n      /**\n       * The response body as parsed JSON or XML\n       */\n      parsedBody: FilterBlobSegmentModel;\n    };\n  };\n\n/**\n * A ContainerClient represents a URL to the Azure Storage container allowing you to manipulate its blobs.\n */\nexport class ContainerClient extends StorageClient {\n  /**\n   * containerContext provided by protocol layer.\n   */\n  private containerContext: Container;\n\n  private _containerName: string;\n\n  /**\n   * The name of the container.\n   */\n  public get containerName(): string {\n    return this._containerName;\n  }\n  /**\n   *\n   * Creates an instance of ContainerClient.\n   *\n   * @param connectionString - Account connection string or a SAS connection string of an Azure storage account.\n   *                                  [ Note - Account connection string can only be used in NODE.JS runtime. ]\n   *                                  Account connection string example -\n   *                                  `DefaultEndpointsProtocol=https;AccountName=myaccount;AccountKey=accountKey;EndpointSuffix=core.windows.net`\n   *                                  SAS connection string example -\n   *                                  `BlobEndpoint=https://myaccount.blob.core.windows.net/;QueueEndpoint=https://myaccount.queue.core.windows.net/;FileEndpoint=https://myaccount.file.core.windows.net/;TableEndpoint=https://myaccount.table.core.windows.net/;SharedAccessSignature=sasString`\n   * @param containerName - Container name.\n   * @param options - Optional. Options to configure the HTTP pipeline.\n   */\n  // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n  /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n  constructor(connectionString: string, containerName: string, options?: StoragePipelineOptions);\n  /**\n   * Creates an instance of ContainerClient.\n   * This method accepts an URL pointing to a container.\n   * Encoded URL string will NOT be escaped twice, only special characters in URL path will be escaped.\n   * If a blob name includes ? or %, blob name must be encoded in the URL.\n   *\n   * @param url - A URL string pointing to Azure Storage container, such as\n   *                     \"https://myaccount.blob.core.windows.net/mycontainer\". You can\n   *                     append a SAS if using AnonymousCredential, such as\n   *                     \"https://myaccount.blob.core.windows.net/mycontainer?sasString\".\n   * @param credential -  Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.\n   * @param options - Optional. Options to configure the HTTP pipeline.\n   */\n  constructor(\n    url: string,\n    credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential,\n    // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n    options?: StoragePipelineOptions\n  );\n  /**\n   * Creates an instance of ContainerClient.\n   * This method accepts an URL pointing to a container.\n   * Encoded URL string will NOT be escaped twice, only special characters in URL path will be escaped.\n   * If a blob name includes ? or %, blob name must be encoded in the URL.\n   *\n   * @param url - A URL string pointing to Azure Storage container, such as\n   *                     \"https://myaccount.blob.core.windows.net/mycontainer\". You can\n   *                     append a SAS if using AnonymousCredential, such as\n   *                     \"https://myaccount.blob.core.windows.net/mycontainer?sasString\".\n   * @param pipeline - Call newPipeline() to create a default\n   *                            pipeline, or provide a customized pipeline.\n   */\n  constructor(url: string, pipeline: PipelineLike);\n  constructor(\n    urlOrConnectionString: string,\n    credentialOrPipelineOrContainerName?:\n      | string\n      | StorageSharedKeyCredential\n      | AnonymousCredential\n      | TokenCredential\n      | PipelineLike,\n    // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n    options?: StoragePipelineOptions\n  ) {\n    let pipeline: PipelineLike;\n    let url: string;\n    options = options || {};\n    if (isPipelineLike(credentialOrPipelineOrContainerName)) {\n      // (url: string, pipeline: Pipeline)\n      url = urlOrConnectionString;\n      pipeline = credentialOrPipelineOrContainerName;\n    } else if (\n      (isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential) ||\n      credentialOrPipelineOrContainerName instanceof AnonymousCredential ||\n      isTokenCredential(credentialOrPipelineOrContainerName)\n    ) {\n      // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n      url = urlOrConnectionString;\n      pipeline = newPipeline(credentialOrPipelineOrContainerName, options);\n    } else if (\n      !credentialOrPipelineOrContainerName &&\n      typeof credentialOrPipelineOrContainerName !== \"string\"\n    ) {\n      // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n      // The second parameter is undefined. Use anonymous credential.\n      url = urlOrConnectionString;\n      pipeline = newPipeline(new AnonymousCredential(), options);\n    } else if (\n      credentialOrPipelineOrContainerName &&\n      typeof credentialOrPipelineOrContainerName === \"string\"\n    ) {\n      // (connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions)\n      const containerName = credentialOrPipelineOrContainerName;\n\n      const extractedCreds = extractConnectionStringParts(urlOrConnectionString);\n      if (extractedCreds.kind === \"AccountConnString\") {\n        if (isNode) {\n          const sharedKeyCredential = new StorageSharedKeyCredential(\n            extractedCreds.accountName!,\n            extractedCreds.accountKey\n          );\n          url = appendToURLPath(extractedCreds.url, encodeURIComponent(containerName));\n\n          if (!options.proxyOptions) {\n            options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);\n          }\n\n          pipeline = newPipeline(sharedKeyCredential, options);\n        } else {\n          throw new Error(\"Account connection string is only supported in Node.js environment\");\n        }\n      } else if (extractedCreds.kind === \"SASConnString\") {\n        url =\n          appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)) +\n          \"?\" +\n          extractedCreds.accountSas;\n        pipeline = newPipeline(new AnonymousCredential(), options);\n      } else {\n        throw new Error(\n          \"Connection string must be either an Account connection string or a SAS connection string\"\n        );\n      }\n    } else {\n      throw new Error(\"Expecting non-empty strings for containerName parameter\");\n    }\n    super(url, pipeline);\n    this._containerName = this.getContainerNameFromUrl();\n    this.containerContext = new Container(this.storageClientContext);\n  }\n\n  /**\n   * Creates a new container under the specified account. If the container with\n   * the same name already exists, the operation fails.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-container\n   *\n   * @param options - Options to Container Create operation.\n   *\n   *\n   * Example usage:\n   *\n   * ```js\n   * const containerClient = blobServiceClient.getContainerClient(\"<container name>\");\n   * const createContainerResponse = await containerClient.create();\n   * console.log(\"Container was created successfully\", createContainerResponse.requestId);\n   * ```\n   */\n  public async create(options: ContainerCreateOptions = {}): Promise<ContainerCreateResponse> {\n    const { span, updatedOptions } = createSpan(\"ContainerClient-create\", options);\n    try {\n      // Spread operator in destructuring assignments,\n      // this will filter out unwanted properties from the response object into result object\n      return await this.containerContext.create({\n        ...options,\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates a new container under the specified account. If the container with\n   * the same name already exists, it is not changed.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-container\n   *\n   * @param options -\n   */\n  public async createIfNotExists(\n    options: ContainerCreateOptions = {}\n  ): Promise<ContainerCreateIfNotExistsResponse> {\n    const { span, updatedOptions } = createSpan(\"ContainerClient-createIfNotExists\", options);\n    try {\n      const res = await this.create(updatedOptions);\n      return {\n        succeeded: true,\n        ...res,\n        _response: res._response, // _response is made non-enumerable\n      };\n    } catch (e: any) {\n      if (e.details?.errorCode === \"ContainerAlreadyExists\") {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message:\n            \"Expected exception when creating a container only if it does not already exist.\",\n        });\n        return {\n          succeeded: false,\n          ...e.response?.parsedHeaders,\n          _response: e.response,\n        };\n      }\n\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Returns true if the Azure container resource represented by this client exists; false otherwise.\n   *\n   * NOTE: use this function with care since an existing container might be deleted by other clients or\n   * applications. Vice versa new containers with the same name might be added by other clients or\n   * applications after this function completes.\n   *\n   * @param options -\n   */\n  public async exists(options: ContainerExistsOptions = {}): Promise<boolean> {\n    const { span, updatedOptions } = createSpan(\"ContainerClient-exists\", options);\n    try {\n      await this.getProperties({\n        abortSignal: options.abortSignal,\n        tracingOptions: updatedOptions.tracingOptions,\n      });\n      return true;\n    } catch (e: any) {\n      if (e.statusCode === 404) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: \"Expected exception when checking container existence\",\n        });\n        return false;\n      }\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates a {@link BlobClient}\n   *\n   * @param blobName - A blob name\n   * @returns A new BlobClient object for the given blob name.\n   */\n  public getBlobClient(blobName: string): BlobClient {\n    return new BlobClient(appendToURLPath(this.url, EscapePath(blobName)), this.pipeline);\n  }\n\n  /**\n   * Creates an {@link AppendBlobClient}\n   *\n   * @param blobName - An append blob name\n   */\n  public getAppendBlobClient(blobName: string): AppendBlobClient {\n    return new AppendBlobClient(appendToURLPath(this.url, EscapePath(blobName)), this.pipeline);\n  }\n\n  /**\n   * Creates a {@link BlockBlobClient}\n   *\n   * @param blobName - A block blob name\n   *\n   *\n   * Example usage:\n   *\n   * ```js\n   * const content = \"Hello world!\";\n   *\n   * const blockBlobClient = containerClient.getBlockBlobClient(\"<blob name>\");\n   * const uploadBlobResponse = await blockBlobClient.upload(content, content.length);\n   * ```\n   */\n  public getBlockBlobClient(blobName: string): BlockBlobClient {\n    return new BlockBlobClient(appendToURLPath(this.url, EscapePath(blobName)), this.pipeline);\n  }\n\n  /**\n   * Creates a {@link PageBlobClient}\n   *\n   * @param blobName - A page blob name\n   */\n  public getPageBlobClient(blobName: string): PageBlobClient {\n    return new PageBlobClient(appendToURLPath(this.url, EscapePath(blobName)), this.pipeline);\n  }\n\n  /**\n   * Returns all user-defined metadata and system properties for the specified\n   * container. The data returned does not include the container's list of blobs.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-container-properties\n   *\n   * WARNING: The `metadata` object returned in the response will have its keys in lowercase, even if\n   * they originally contained uppercase characters. This differs from the metadata keys returned by\n   * the `listContainers` method of {@link BlobServiceClient} using the `includeMetadata` option, which\n   * will retain their original casing.\n   *\n   * @param options - Options to Container Get Properties operation.\n   */\n  public async getProperties(\n    options: ContainerGetPropertiesOptions = {}\n  ): Promise<ContainerGetPropertiesResponse> {\n    if (!options.conditions) {\n      options.conditions = {};\n    }\n\n    const { span, updatedOptions } = createSpan(\"ContainerClient-getProperties\", options);\n    try {\n      return await this.containerContext.getProperties({\n        abortSignal: options.abortSignal,\n        ...options.conditions,\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Marks the specified container for deletion. The container and any blobs\n   * contained within it are later deleted during garbage collection.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-container\n   *\n   * @param options - Options to Container Delete operation.\n   */\n  public async delete(\n    options: ContainerDeleteMethodOptions = {}\n  ): Promise<ContainerDeleteResponse> {\n    if (!options.conditions) {\n      options.conditions = {};\n    }\n\n    const { span, updatedOptions } = createSpan(\"ContainerClient-delete\", options);\n    try {\n      return await this.containerContext.delete({\n        abortSignal: options.abortSignal,\n        leaseAccessConditions: options.conditions,\n        modifiedAccessConditions: options.conditions,\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Marks the specified container for deletion if it exists. The container and any blobs\n   * contained within it are later deleted during garbage collection.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-container\n   *\n   * @param options - Options to Container Delete operation.\n   */\n  public async deleteIfExists(\n    options: ContainerDeleteMethodOptions = {}\n  ): Promise<ContainerDeleteIfExistsResponse> {\n    const { span, updatedOptions } = createSpan(\"ContainerClient-deleteIfExists\", options);\n\n    try {\n      const res = await this.delete(updatedOptions);\n      return {\n        succeeded: true,\n        ...res,\n        _response: res._response, // _response is made non-enumerable\n      };\n    } catch (e: any) {\n      if (e.details?.errorCode === \"ContainerNotFound\") {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: \"Expected exception when deleting a container only if it exists.\",\n        });\n        return {\n          succeeded: false,\n          ...e.response?.parsedHeaders,\n          _response: e.response,\n        };\n      }\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Sets one or more user-defined name-value pairs for the specified container.\n   *\n   * If no option provided, or no metadata defined in the parameter, the container\n   * metadata will be removed.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-container-metadata\n   *\n   * @param metadata - Replace existing metadata with this value.\n   *                            If no value provided the existing metadata will be removed.\n   * @param options - Options to Container Set Metadata operation.\n   */\n  public async setMetadata(\n    metadata?: Metadata,\n    options: ContainerSetMetadataOptions = {}\n  ): Promise<ContainerSetMetadataResponse> {\n    if (!options.conditions) {\n      options.conditions = {};\n    }\n\n    if (options.conditions.ifUnmodifiedSince) {\n      throw new RangeError(\n        \"the IfUnmodifiedSince must have their default values because they are ignored by the blob service\"\n      );\n    }\n\n    const { span, updatedOptions } = createSpan(\"ContainerClient-setMetadata\", options);\n\n    try {\n      return await this.containerContext.setMetadata({\n        abortSignal: options.abortSignal,\n        leaseAccessConditions: options.conditions,\n        metadata,\n        modifiedAccessConditions: options.conditions,\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Gets the permissions for the specified container. The permissions indicate\n   * whether container data may be accessed publicly.\n   *\n   * WARNING: JavaScript Date will potentially lose precision when parsing startsOn and expiresOn strings.\n   * For example, new Date(\"2018-12-31T03:44:23.8827891Z\").toISOString() will get \"2018-12-31T03:44:23.882Z\".\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-container-acl\n   *\n   * @param options - Options to Container Get Access Policy operation.\n   */\n  public async getAccessPolicy(\n    options: ContainerGetAccessPolicyOptions = {}\n  ): Promise<ContainerGetAccessPolicyResponse> {\n    if (!options.conditions) {\n      options.conditions = {};\n    }\n\n    const { span, updatedOptions } = createSpan(\"ContainerClient-getAccessPolicy\", options);\n\n    try {\n      const response = await this.containerContext.getAccessPolicy({\n        abortSignal: options.abortSignal,\n        leaseAccessConditions: options.conditions,\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n\n      const res: ContainerGetAccessPolicyResponse = {\n        _response: response._response,\n        blobPublicAccess: response.blobPublicAccess,\n        date: response.date,\n        etag: response.etag,\n        errorCode: response.errorCode,\n        lastModified: response.lastModified,\n        requestId: response.requestId,\n        clientRequestId: response.clientRequestId,\n        signedIdentifiers: [],\n        version: response.version,\n      };\n\n      for (const identifier of response) {\n        let accessPolicy: any = undefined;\n        if (identifier.accessPolicy) {\n          accessPolicy = {\n            permissions: identifier.accessPolicy.permissions,\n          };\n\n          if (identifier.accessPolicy.expiresOn) {\n            accessPolicy.expiresOn = new Date(identifier.accessPolicy.expiresOn);\n          }\n\n          if (identifier.accessPolicy.startsOn) {\n            accessPolicy.startsOn = new Date(identifier.accessPolicy.startsOn);\n          }\n        }\n\n        res.signedIdentifiers.push({\n          accessPolicy,\n          id: identifier.id,\n        });\n      }\n\n      return res;\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Sets the permissions for the specified container. The permissions indicate\n   * whether blobs in a container may be accessed publicly.\n   *\n   * When you set permissions for a container, the existing permissions are replaced.\n   * If no access or containerAcl provided, the existing container ACL will be\n   * removed.\n   *\n   * When you establish a stored access policy on a container, it may take up to 30 seconds to take effect.\n   * During this interval, a shared access signature that is associated with the stored access policy will\n   * fail with status code 403 (Forbidden), until the access policy becomes active.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-container-acl\n   *\n   * @param access - The level of public access to data in the container.\n   * @param containerAcl - Array of elements each having a unique Id and details of the access policy.\n   * @param options - Options to Container Set Access Policy operation.\n   */\n  public async setAccessPolicy(\n    access?: PublicAccessType,\n    containerAcl?: SignedIdentifier[],\n    options: ContainerSetAccessPolicyOptions = {}\n  ): Promise<ContainerSetAccessPolicyResponse> {\n    options.conditions = options.conditions || {};\n    const { span, updatedOptions } = createSpan(\"ContainerClient-setAccessPolicy\", options);\n    try {\n      const acl: SignedIdentifierModel[] = [];\n      for (const identifier of containerAcl || []) {\n        acl.push({\n          accessPolicy: {\n            expiresOn: identifier.accessPolicy.expiresOn\n              ? truncatedISO8061Date(identifier.accessPolicy.expiresOn)\n              : \"\",\n            permissions: identifier.accessPolicy.permissions,\n            startsOn: identifier.accessPolicy.startsOn\n              ? truncatedISO8061Date(identifier.accessPolicy.startsOn)\n              : \"\",\n          },\n          id: identifier.id,\n        });\n      }\n\n      return await this.containerContext.setAccessPolicy({\n        abortSignal: options.abortSignal,\n        access,\n        containerAcl: acl,\n        leaseAccessConditions: options.conditions,\n        modifiedAccessConditions: options.conditions,\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Get a {@link BlobLeaseClient} that manages leases on the container.\n   *\n   * @param proposeLeaseId - Initial proposed lease Id.\n   * @returns A new BlobLeaseClient object for managing leases on the container.\n   */\n  public getBlobLeaseClient(proposeLeaseId?: string): BlobLeaseClient {\n    return new BlobLeaseClient(this, proposeLeaseId);\n  }\n\n  /**\n   * Creates a new block blob, or updates the content of an existing block blob.\n   *\n   * Updating an existing block blob overwrites any existing metadata on the blob.\n   * Partial updates are not supported; the content of the existing blob is\n   * overwritten with the new content. To perform a partial update of a block blob's,\n   * use {@link BlockBlobClient.stageBlock} and {@link BlockBlobClient.commitBlockList}.\n   *\n   * This is a non-parallel uploading method, please use {@link BlockBlobClient.uploadFile},\n   * {@link BlockBlobClient.uploadStream} or {@link BlockBlobClient.uploadBrowserData} for better\n   * performance with concurrency uploading.\n   *\n   * @see https://docs.microsoft.com/rest/api/storageservices/put-blob\n   *\n   * @param blobName - Name of the block blob to create or update.\n   * @param body - Blob, string, ArrayBuffer, ArrayBufferView or a function\n   *                               which returns a new Readable stream whose offset is from data source beginning.\n   * @param contentLength - Length of body in bytes. Use Buffer.byteLength() to calculate body length for a\n   *                               string including non non-Base64/Hex-encoded characters.\n   * @param options - Options to configure the Block Blob Upload operation.\n   * @returns Block Blob upload response data and the corresponding BlockBlobClient instance.\n   */\n  public async uploadBlockBlob(\n    blobName: string,\n    body: HttpRequestBody,\n    contentLength: number,\n    options: BlockBlobUploadOptions = {}\n  ): Promise<{ blockBlobClient: BlockBlobClient; response: BlockBlobUploadResponse }> {\n    const { span, updatedOptions } = createSpan(\"ContainerClient-uploadBlockBlob\", options);\n    try {\n      const blockBlobClient = this.getBlockBlobClient(blobName);\n      const response = await blockBlobClient.upload(body, contentLength, updatedOptions);\n      return {\n        blockBlobClient,\n        response,\n      };\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Marks the specified blob or snapshot for deletion. The blob is later deleted\n   * during garbage collection. Note that in order to delete a blob, you must delete\n   * all of its snapshots. You can delete both at the same time with the Delete\n   * Blob operation.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-blob\n   *\n   * @param blobName -\n   * @param options - Options to Blob Delete operation.\n   * @returns Block blob deletion response data.\n   */\n  public async deleteBlob(\n    blobName: string,\n    options: ContainerDeleteBlobOptions = {}\n  ): Promise<BlobDeleteResponse> {\n    const { span, updatedOptions } = createSpan(\"ContainerClient-deleteBlob\", options);\n    try {\n      let blobClient = this.getBlobClient(blobName);\n      if (options.versionId) {\n        blobClient = blobClient.withVersion(options.versionId);\n      }\n      return await blobClient.delete(updatedOptions);\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * listBlobFlatSegment returns a single segment of blobs starting from the\n   * specified Marker. Use an empty Marker to start enumeration from the beginning.\n   * After getting a segment, process it, and then call listBlobsFlatSegment again\n   * (passing the the previously-returned Marker) to get the next segment.\n   * @see https://docs.microsoft.com/rest/api/storageservices/list-blobs\n   *\n   * @param marker - A string value that identifies the portion of the list to be returned with the next list operation.\n   * @param options - Options to Container List Blob Flat Segment operation.\n   */\n  private async listBlobFlatSegment(\n    marker?: string,\n    options: ContainerListBlobsSegmentOptions = {}\n  ): Promise<ContainerListBlobFlatSegmentResponse> {\n    const { span, updatedOptions } = createSpan(\"ContainerClient-listBlobFlatSegment\", options);\n    try {\n      const response = await this.containerContext.listBlobFlatSegment({\n        marker,\n        ...options,\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n\n      response.segment.blobItems = [];\n      if ((response.segment as any)[\"Blob\"] !== undefined) {\n        response.segment.blobItems = ProcessBlobItems((response.segment as any)[\"Blob\"]);\n      }\n\n      const wrappedResponse: ContainerListBlobFlatSegmentResponse = {\n        ...response,\n        _response: {\n          ...response._response,\n          parsedBody: ConvertInternalResponseOfListBlobFlat(response._response.parsedBody),\n        }, // _response is made non-enumerable\n        segment: {\n          ...response.segment,\n          blobItems: response.segment.blobItems.map((blobItemInteral) => {\n            const blobItem: BlobItem = {\n              ...blobItemInteral,\n              name: BlobNameToString(blobItemInteral.name),\n              tags: toTags(blobItemInteral.blobTags),\n              objectReplicationSourceProperties: parseObjectReplicationRecord(\n                blobItemInteral.objectReplicationMetadata\n              ),\n            };\n            return blobItem;\n          }),\n        },\n      };\n      return wrappedResponse;\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * listBlobHierarchySegment returns a single segment of blobs starting from\n   * the specified Marker. Use an empty Marker to start enumeration from the\n   * beginning. After getting a segment, process it, and then call listBlobsHierarchicalSegment\n   * again (passing the the previously-returned Marker) to get the next segment.\n   * @see https://docs.microsoft.com/rest/api/storageservices/list-blobs\n   *\n   * @param delimiter - The character or string used to define the virtual hierarchy\n   * @param marker - A string value that identifies the portion of the list to be returned with the next list operation.\n   * @param options - Options to Container List Blob Hierarchy Segment operation.\n   */\n  private async listBlobHierarchySegment(\n    delimiter: string,\n    marker?: string,\n    options: ContainerListBlobsSegmentOptions = {}\n  ): Promise<ContainerListBlobHierarchySegmentResponse> {\n    const { span, updatedOptions } = createSpan(\n      \"ContainerClient-listBlobHierarchySegment\",\n      options\n    );\n    try {\n      const response = await this.containerContext.listBlobHierarchySegment(delimiter, {\n        marker,\n        ...options,\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n\n      response.segment.blobItems = [];\n      if ((response.segment as any)[\"Blob\"] !== undefined) {\n        response.segment.blobItems = ProcessBlobItems((response.segment as any)[\"Blob\"]);\n      }\n\n      response.segment.blobPrefixes = [];\n      if ((response.segment as any)[\"BlobPrefix\"] !== undefined) {\n        response.segment.blobPrefixes = ProcessBlobPrefixes(\n          (response.segment as any)[\"BlobPrefix\"]\n        );\n      }\n\n      const wrappedResponse: ContainerListBlobHierarchySegmentResponse = {\n        ...response,\n        _response: {\n          ...response._response,\n          parsedBody: ConvertInternalResponseOfListBlobHierarchy(response._response.parsedBody),\n        }, // _response is made non-enumerable\n        segment: {\n          ...response.segment,\n          blobItems: response.segment.blobItems.map((blobItemInteral) => {\n            const blobItem: BlobItem = {\n              ...blobItemInteral,\n              name: BlobNameToString(blobItemInteral.name),\n              tags: toTags(blobItemInteral.blobTags),\n              objectReplicationSourceProperties: parseObjectReplicationRecord(\n                blobItemInteral.objectReplicationMetadata\n              ),\n            };\n            return blobItem;\n          }),\n          blobPrefixes: response.segment.blobPrefixes?.map((blobPrefixInternal) => {\n            const blobPrefix: BlobPrefix = {\n              name: BlobNameToString(blobPrefixInternal.name),\n            };\n            return blobPrefix;\n          }),\n        },\n      };\n      return wrappedResponse;\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Returns an AsyncIterableIterator for ContainerListBlobFlatSegmentResponse\n   *\n   * @param marker - A string value that identifies the portion of\n   *                          the list of blobs to be returned with the next listing operation. The\n   *                          operation returns the ContinuationToken value within the response body if the\n   *                          listing operation did not return all blobs remaining to be listed\n   *                          with the current page. The ContinuationToken value can be used as the value for\n   *                          the marker parameter in a subsequent call to request the next page of list\n   *                          items. The marker value is opaque to the client.\n   * @param options - Options to list blobs operation.\n   */\n  private async *listSegments(\n    marker?: string,\n    options: ContainerListBlobsSegmentOptions = {}\n  ): AsyncIterableIterator<ContainerListBlobFlatSegmentResponse> {\n    let listBlobsFlatSegmentResponse;\n    if (!!marker || marker === undefined) {\n      do {\n        listBlobsFlatSegmentResponse = await this.listBlobFlatSegment(marker, options);\n        marker = listBlobsFlatSegmentResponse.continuationToken;\n        yield await listBlobsFlatSegmentResponse;\n      } while (marker);\n    }\n  }\n\n  /**\n   * Returns an AsyncIterableIterator of {@link BlobItem} objects\n   *\n   * @param options - Options to list blobs operation.\n   */\n  private async *listItems(\n    options: ContainerListBlobsSegmentOptions = {}\n  ): AsyncIterableIterator<BlobItem> {\n    let marker: string | undefined;\n    for await (const listBlobsFlatSegmentResponse of this.listSegments(marker, options)) {\n      yield* listBlobsFlatSegmentResponse.segment.blobItems;\n    }\n  }\n\n  /**\n   * Returns an async iterable iterator to list all the blobs\n   * under the specified account.\n   *\n   * .byPage() returns an async iterable iterator to list the blobs in pages.\n   *\n   * Example using `for await` syntax:\n   *\n   * ```js\n   * // Get the containerClient before you run these snippets,\n   * // Can be obtained from `blobServiceClient.getContainerClient(\"<your-container-name>\");`\n   * let i = 1;\n   * for await (const blob of containerClient.listBlobsFlat()) {\n   *   console.log(`Blob ${i++}: ${blob.name}`);\n   * }\n   * ```\n   *\n   * Example using `iter.next()`:\n   *\n   * ```js\n   * let i = 1;\n   * let iter = containerClient.listBlobsFlat();\n   * let blobItem = await iter.next();\n   * while (!blobItem.done) {\n   *   console.log(`Blob ${i++}: ${blobItem.value.name}`);\n   *   blobItem = await iter.next();\n   * }\n   * ```\n   *\n   * Example using `byPage()`:\n   *\n   * ```js\n   * // passing optional maxPageSize in the page settings\n   * let i = 1;\n   * for await (const response of containerClient.listBlobsFlat().byPage({ maxPageSize: 20 })) {\n   *   for (const blob of response.segment.blobItems) {\n   *     console.log(`Blob ${i++}: ${blob.name}`);\n   *   }\n   * }\n   * ```\n   *\n   * Example using paging with a marker:\n   *\n   * ```js\n   * let i = 1;\n   * let iterator = containerClient.listBlobsFlat().byPage({ maxPageSize: 2 });\n   * let response = (await iterator.next()).value;\n   *\n   * // Prints 2 blob names\n   * for (const blob of response.segment.blobItems) {\n   *   console.log(`Blob ${i++}: ${blob.name}`);\n   * }\n   *\n   * // Gets next marker\n   * let marker = response.continuationToken;\n   *\n   * // Passing next marker as continuationToken\n   *\n   * iterator = containerClient.listBlobsFlat().byPage({ continuationToken: marker, maxPageSize: 10 });\n   * response = (await iterator.next()).value;\n   *\n   * // Prints 10 blob names\n   * for (const blob of response.segment.blobItems) {\n   *   console.log(`Blob ${i++}: ${blob.name}`);\n   * }\n   * ```\n   *\n   * @param options - Options to list blobs.\n   * @returns An asyncIterableIterator that supports paging.\n   */\n  public listBlobsFlat(\n    options: ContainerListBlobsOptions = {}\n  ): PagedAsyncIterableIterator<BlobItem, ContainerListBlobFlatSegmentResponse> {\n    const include: ListBlobsIncludeItem[] = [];\n    if (options.includeCopy) {\n      include.push(\"copy\");\n    }\n    if (options.includeDeleted) {\n      include.push(\"deleted\");\n    }\n    if (options.includeMetadata) {\n      include.push(\"metadata\");\n    }\n    if (options.includeSnapshots) {\n      include.push(\"snapshots\");\n    }\n    if (options.includeVersions) {\n      include.push(\"versions\");\n    }\n    if (options.includeUncommitedBlobs) {\n      include.push(\"uncommittedblobs\");\n    }\n    if (options.includeTags) {\n      include.push(\"tags\");\n    }\n    if (options.includeDeletedWithVersions) {\n      include.push(\"deletedwithversions\");\n    }\n    if (options.includeImmutabilityPolicy) {\n      include.push(\"immutabilitypolicy\");\n    }\n    if (options.includeLegalHold) {\n      include.push(\"legalhold\");\n    }\n    if (options.prefix === \"\") {\n      options.prefix = undefined;\n    }\n\n    const updatedOptions: ContainerListBlobsSegmentOptions = {\n      ...options,\n      ...(include.length > 0 ? { include: include } : {}),\n    };\n\n    // AsyncIterableIterator to iterate over blobs\n    const iter = this.listItems(updatedOptions);\n    return {\n      /**\n       * The next method, part of the iteration protocol\n       */\n      next() {\n        return iter.next();\n      },\n      /**\n       * The connection to the async iterator, part of the iteration protocol\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      /**\n       * Return an AsyncIterableIterator that works a page at a time\n       */\n      byPage: (settings: PageSettings = {}) => {\n        return this.listSegments(settings.continuationToken, {\n          maxPageSize: settings.maxPageSize,\n          ...updatedOptions,\n        });\n      },\n    };\n  }\n\n  /**\n   * Returns an AsyncIterableIterator for ContainerListBlobHierarchySegmentResponse\n   *\n   * @param delimiter - The character or string used to define the virtual hierarchy\n   * @param marker - A string value that identifies the portion of\n   *                          the list of blobs to be returned with the next listing operation. The\n   *                          operation returns the ContinuationToken value within the response body if the\n   *                          listing operation did not return all blobs remaining to be listed\n   *                          with the current page. The ContinuationToken value can be used as the value for\n   *                          the marker parameter in a subsequent call to request the next page of list\n   *                          items. The marker value is opaque to the client.\n   * @param options - Options to list blobs operation.\n   */\n  private async *listHierarchySegments(\n    delimiter: string,\n    marker?: string,\n    options: ContainerListBlobsSegmentOptions = {}\n  ): AsyncIterableIterator<ContainerListBlobHierarchySegmentResponse> {\n    let listBlobsHierarchySegmentResponse;\n    if (!!marker || marker === undefined) {\n      do {\n        listBlobsHierarchySegmentResponse = await this.listBlobHierarchySegment(\n          delimiter,\n          marker,\n          options\n        );\n        marker = listBlobsHierarchySegmentResponse.continuationToken;\n        yield await listBlobsHierarchySegmentResponse;\n      } while (marker);\n    }\n  }\n\n  /**\n   * Returns an AsyncIterableIterator for {@link BlobPrefix} and {@link BlobItem} objects.\n   *\n   * @param delimiter - The character or string used to define the virtual hierarchy\n   * @param options - Options to list blobs operation.\n   */\n  private async *listItemsByHierarchy(\n    delimiter: string,\n    options: ContainerListBlobsSegmentOptions = {}\n  ): AsyncIterableIterator<({ kind: \"prefix\" } & BlobPrefix) | ({ kind: \"blob\" } & BlobItem)> {\n    let marker: string | undefined;\n    for await (const listBlobsHierarchySegmentResponse of this.listHierarchySegments(\n      delimiter,\n      marker,\n      options\n    )) {\n      const segment = listBlobsHierarchySegmentResponse.segment;\n      if (segment.blobPrefixes) {\n        for (const prefix of segment.blobPrefixes) {\n          yield {\n            kind: \"prefix\",\n            ...prefix,\n          };\n        }\n      }\n      for (const blob of segment.blobItems) {\n        yield { kind: \"blob\", ...blob };\n      }\n    }\n  }\n\n  /**\n   * Returns an async iterable iterator to list all the blobs by hierarchy.\n   * under the specified account.\n   *\n   * .byPage() returns an async iterable iterator to list the blobs by hierarchy in pages.\n   *\n   * Example using `for await` syntax:\n   *\n   * ```js\n   * for await (const item of containerClient.listBlobsByHierarchy(\"/\")) {\n   *   if (item.kind === \"prefix\") {\n   *     console.log(`\\tBlobPrefix: ${item.name}`);\n   *   } else {\n   *     console.log(`\\tBlobItem: name - ${item.name}`);\n   *   }\n   * }\n   * ```\n   *\n   * Example using `iter.next()`:\n   *\n   * ```js\n   * let iter = containerClient.listBlobsByHierarchy(\"/\", { prefix: \"prefix1/\" });\n   * let entity = await iter.next();\n   * while (!entity.done) {\n   *   let item = entity.value;\n   *   if (item.kind === \"prefix\") {\n   *     console.log(`\\tBlobPrefix: ${item.name}`);\n   *   } else {\n   *     console.log(`\\tBlobItem: name - ${item.name}`);\n   *   }\n   *   entity = await iter.next();\n   * }\n   * ```\n   *\n   * Example using `byPage()`:\n   *\n   * ```js\n   * console.log(\"Listing blobs by hierarchy by page\");\n   * for await (const response of containerClient.listBlobsByHierarchy(\"/\").byPage()) {\n   *   const segment = response.segment;\n   *   if (segment.blobPrefixes) {\n   *     for (const prefix of segment.blobPrefixes) {\n   *       console.log(`\\tBlobPrefix: ${prefix.name}`);\n   *     }\n   *   }\n   *   for (const blob of response.segment.blobItems) {\n   *     console.log(`\\tBlobItem: name - ${blob.name}`);\n   *   }\n   * }\n   * ```\n   *\n   * Example using paging with a max page size:\n   *\n   * ```js\n   * console.log(\"Listing blobs by hierarchy by page, specifying a prefix and a max page size\");\n   *\n   * let i = 1;\n   * for await (const response of containerClient\n   *   .listBlobsByHierarchy(\"/\", { prefix: \"prefix2/sub1/\" })\n   *   .byPage({ maxPageSize: 2 })) {\n   *   console.log(`Page ${i++}`);\n   *   const segment = response.segment;\n   *\n   *   if (segment.blobPrefixes) {\n   *     for (const prefix of segment.blobPrefixes) {\n   *       console.log(`\\tBlobPrefix: ${prefix.name}`);\n   *     }\n   *   }\n   *\n   *   for (const blob of response.segment.blobItems) {\n   *     console.log(`\\tBlobItem: name - ${blob.name}`);\n   *   }\n   * }\n   * ```\n   *\n   * @param delimiter - The character or string used to define the virtual hierarchy\n   * @param options - Options to list blobs operation.\n   */\n  public listBlobsByHierarchy(\n    delimiter: string,\n    options: ContainerListBlobsOptions = {}\n  ): PagedAsyncIterableIterator<\n    ({ kind: \"prefix\" } & BlobPrefix) | ({ kind: \"blob\" } & BlobItem),\n    ContainerListBlobHierarchySegmentResponse\n  > {\n    if (delimiter === \"\") {\n      throw new RangeError(\"delimiter should contain one or more characters\");\n    }\n\n    const include: ListBlobsIncludeItem[] = [];\n    if (options.includeCopy) {\n      include.push(\"copy\");\n    }\n    if (options.includeDeleted) {\n      include.push(\"deleted\");\n    }\n    if (options.includeMetadata) {\n      include.push(\"metadata\");\n    }\n    if (options.includeSnapshots) {\n      include.push(\"snapshots\");\n    }\n    if (options.includeVersions) {\n      include.push(\"versions\");\n    }\n    if (options.includeUncommitedBlobs) {\n      include.push(\"uncommittedblobs\");\n    }\n    if (options.includeTags) {\n      include.push(\"tags\");\n    }\n    if (options.includeDeletedWithVersions) {\n      include.push(\"deletedwithversions\");\n    }\n    if (options.includeImmutabilityPolicy) {\n      include.push(\"immutabilitypolicy\");\n    }\n    if (options.includeLegalHold) {\n      include.push(\"legalhold\");\n    }\n    if (options.prefix === \"\") {\n      options.prefix = undefined;\n    }\n\n    const updatedOptions: ContainerListBlobsSegmentOptions = {\n      ...options,\n      ...(include.length > 0 ? { include: include } : {}),\n    };\n    // AsyncIterableIterator to iterate over blob prefixes and blobs\n    const iter = this.listItemsByHierarchy(delimiter, updatedOptions);\n    return {\n      /**\n       * The next method, part of the iteration protocol\n       */\n      async next() {\n        return iter.next();\n      },\n      /**\n       * The connection to the async iterator, part of the iteration protocol\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      /**\n       * Return an AsyncIterableIterator that works a page at a time\n       */\n      byPage: (settings: PageSettings = {}) => {\n        return this.listHierarchySegments(delimiter, settings.continuationToken, {\n          maxPageSize: settings.maxPageSize,\n          ...updatedOptions,\n        });\n      },\n    };\n  }\n\n  /**\n   * The Filter Blobs operation enables callers to list blobs in the container whose tags\n   * match a given search expression.\n   *\n   * @param tagFilterSqlExpression - The where parameter enables the caller to query blobs whose tags match a given expression.\n   *                                        The given expression must evaluate to true for a blob to be returned in the results.\n   *                                        The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;\n   *                                        however, only a subset of the OData filter syntax is supported in the Blob service.\n   * @param marker - A string value that identifies the portion of\n   *                          the list of blobs to be returned with the next listing operation. The\n   *                          operation returns the continuationToken value within the response body if the\n   *                          listing operation did not return all blobs remaining to be listed\n   *                          with the current page. The continuationToken value can be used as the value for\n   *                          the marker parameter in a subsequent call to request the next page of list\n   *                          items. The marker value is opaque to the client.\n   * @param options - Options to find blobs by tags.\n   */\n  private async findBlobsByTagsSegment(\n    tagFilterSqlExpression: string,\n    marker?: string,\n    options: ContainerFindBlobsByTagsSegmentOptions = {}\n  ): Promise<ContainerFindBlobsByTagsSegmentResponse> {\n    const { span, updatedOptions } = createSpan(\"ContainerClient-findBlobsByTagsSegment\", options);\n\n    try {\n      const response = await this.containerContext.filterBlobs({\n        abortSignal: options.abortSignal,\n        where: tagFilterSqlExpression,\n        marker,\n        maxPageSize: options.maxPageSize,\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n\n      const wrappedResponse: ContainerFindBlobsByTagsSegmentResponse = {\n        ...response,\n        _response: response._response, // _response is made non-enumerable\n        blobs: response.blobs.map((blob) => {\n          let tagValue = \"\";\n          if (blob.tags?.blobTagSet.length === 1) {\n            tagValue = blob.tags.blobTagSet[0].value;\n          }\n          return { ...blob, tags: toTags(blob.tags), tagValue };\n        }),\n      };\n      return wrappedResponse;\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Returns an AsyncIterableIterator for ContainerFindBlobsByTagsSegmentResponse.\n   *\n   * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.\n   *                                         The given expression must evaluate to true for a blob to be returned in the results.\n   *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;\n   *                                         however, only a subset of the OData filter syntax is supported in the Blob service.\n   * @param marker - A string value that identifies the portion of\n   *                          the list of blobs to be returned with the next listing operation. The\n   *                          operation returns the continuationToken value within the response body if the\n   *                          listing operation did not return all blobs remaining to be listed\n   *                          with the current page. The continuationToken value can be used as the value for\n   *                          the marker parameter in a subsequent call to request the next page of list\n   *                          items. The marker value is opaque to the client.\n   * @param options - Options to find blobs by tags.\n   */\n  private async *findBlobsByTagsSegments(\n    tagFilterSqlExpression: string,\n    marker?: string,\n    options: ContainerFindBlobsByTagsSegmentOptions = {}\n  ): AsyncIterableIterator<ContainerFindBlobsByTagsSegmentResponse> {\n    let response;\n    if (!!marker || marker === undefined) {\n      do {\n        response = await this.findBlobsByTagsSegment(tagFilterSqlExpression, marker, options);\n        response.blobs = response.blobs || [];\n        marker = response.continuationToken;\n        yield response;\n      } while (marker);\n    }\n  }\n\n  /**\n   * Returns an AsyncIterableIterator for blobs.\n   *\n   * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.\n   *                                         The given expression must evaluate to true for a blob to be returned in the results.\n   *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;\n   *                                         however, only a subset of the OData filter syntax is supported in the Blob service.\n   * @param options - Options to findBlobsByTagsItems.\n   */\n  private async *findBlobsByTagsItems(\n    tagFilterSqlExpression: string,\n    options: ContainerFindBlobsByTagsSegmentOptions = {}\n  ): AsyncIterableIterator<FilterBlobItem> {\n    let marker: string | undefined;\n    for await (const segment of this.findBlobsByTagsSegments(\n      tagFilterSqlExpression,\n      marker,\n      options\n    )) {\n      yield* segment.blobs;\n    }\n  }\n\n  /**\n   * Returns an async iterable iterator to find all blobs with specified tag\n   * under the specified container.\n   *\n   * .byPage() returns an async iterable iterator to list the blobs in pages.\n   *\n   * Example using `for await` syntax:\n   *\n   * ```js\n   * let i = 1;\n   * for await (const blob of containerClient.findBlobsByTags(\"tagkey='tagvalue'\")) {\n   *   console.log(`Blob ${i++}: ${blob.name}`);\n   * }\n   * ```\n   *\n   * Example using `iter.next()`:\n   *\n   * ```js\n   * let i = 1;\n   * const iter = containerClient.findBlobsByTags(\"tagkey='tagvalue'\");\n   * let blobItem = await iter.next();\n   * while (!blobItem.done) {\n   *   console.log(`Blob ${i++}: ${blobItem.value.name}`);\n   *   blobItem = await iter.next();\n   * }\n   * ```\n   *\n   * Example using `byPage()`:\n   *\n   * ```js\n   * // passing optional maxPageSize in the page settings\n   * let i = 1;\n   * for await (const response of containerClient.findBlobsByTags(\"tagkey='tagvalue'\").byPage({ maxPageSize: 20 })) {\n   *   if (response.blobs) {\n   *     for (const blob of response.blobs) {\n   *       console.log(`Blob ${i++}: ${blob.name}`);\n   *     }\n   *   }\n   * }\n   * ```\n   *\n   * Example using paging with a marker:\n   *\n   * ```js\n   * let i = 1;\n   * let iterator = containerClient.findBlobsByTags(\"tagkey='tagvalue'\").byPage({ maxPageSize: 2 });\n   * let response = (await iterator.next()).value;\n   *\n   * // Prints 2 blob names\n   * if (response.blobs) {\n   *   for (const blob of response.blobs) {\n   *     console.log(`Blob ${i++}: ${blob.name}`);\n   *   }\n   * }\n   *\n   * // Gets next marker\n   * let marker = response.continuationToken;\n   * // Passing next marker as continuationToken\n   * iterator = containerClient\n   *   .findBlobsByTags(\"tagkey='tagvalue'\")\n   *   .byPage({ continuationToken: marker, maxPageSize: 10 });\n   * response = (await iterator.next()).value;\n   *\n   * // Prints blob names\n   * if (response.blobs) {\n   *   for (const blob of response.blobs) {\n   *      console.log(`Blob ${i++}: ${blob.name}`);\n   *   }\n   * }\n   * ```\n   *\n   * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.\n   *                                         The given expression must evaluate to true for a blob to be returned in the results.\n   *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;\n   *                                         however, only a subset of the OData filter syntax is supported in the Blob service.\n   * @param options - Options to find blobs by tags.\n   */\n  public findBlobsByTags(\n    tagFilterSqlExpression: string,\n    options: ContainerFindBlobByTagsOptions = {}\n  ): PagedAsyncIterableIterator<FilterBlobItem, ContainerFindBlobsByTagsSegmentResponse> {\n    // AsyncIterableIterator to iterate over blobs\n    const listSegmentOptions: ContainerFindBlobsByTagsSegmentOptions = {\n      ...options,\n    };\n\n    const iter = this.findBlobsByTagsItems(tagFilterSqlExpression, listSegmentOptions);\n    return {\n      /**\n       * The next method, part of the iteration protocol\n       */\n      next() {\n        return iter.next();\n      },\n      /**\n       * The connection to the async iterator, part of the iteration protocol\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      /**\n       * Return an AsyncIterableIterator that works a page at a time\n       */\n      byPage: (settings: PageSettings = {}) => {\n        return this.findBlobsByTagsSegments(tagFilterSqlExpression, settings.continuationToken, {\n          maxPageSize: settings.maxPageSize,\n          ...listSegmentOptions,\n        });\n      },\n    };\n  }\n\n  private getContainerNameFromUrl(): string {\n    let containerName;\n    try {\n      //  URL may look like the following\n      // \"https://myaccount.blob.core.windows.net/mycontainer?sasString\";\n      // \"https://myaccount.blob.core.windows.net/mycontainer\";\n      // IPv4/IPv6 address hosts, Endpoints - `http://127.0.0.1:10000/devstoreaccount1/containername`\n      // http://localhost:10001/devstoreaccount1/containername\n\n      const parsedUrl = URLBuilder.parse(this.url);\n\n      if (parsedUrl.getHost()!.split(\".\")[1] === \"blob\") {\n        // \"https://myaccount.blob.core.windows.net/containername\".\n        // \"https://customdomain.com/containername\".\n        // .getPath() -> /containername\n        containerName = parsedUrl.getPath()!.split(\"/\")[1];\n      } else if (isIpEndpointStyle(parsedUrl)) {\n        // IPv4/IPv6 address hosts... Example - http://192.0.0.10:10001/devstoreaccount1/containername\n        // Single word domain without a [dot] in the endpoint... Example - http://localhost:10001/devstoreaccount1/containername\n        // .getPath() -> /devstoreaccount1/containername\n        containerName = parsedUrl.getPath()!.split(\"/\")[2];\n      } else {\n        // \"https://customdomain.com/containername\".\n        // .getPath() -> /containername\n        containerName = parsedUrl.getPath()!.split(\"/\")[1];\n      }\n\n      // decode the encoded containerName - to get all the special characters that might be present in it\n      containerName = decodeURIComponent(containerName);\n\n      if (!containerName) {\n        throw new Error(\"Provided containerName is invalid.\");\n      }\n\n      return containerName;\n    } catch (error: any) {\n      throw new Error(\"Unable to extract containerName with provided information.\");\n    }\n  }\n\n  /**\n   * Only available for ContainerClient constructed with a shared key credential.\n   *\n   * Generates a Blob Container Service Shared Access Signature (SAS) URI based on the client properties\n   * and parameters passed in. The SAS is signed by the shared key credential of the client.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas\n   *\n   * @param options - Optional parameters.\n   * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.\n   */\n  public generateSasUrl(options: ContainerGenerateSasUrlOptions): Promise<string> {\n    return new Promise((resolve) => {\n      if (!(this.credential instanceof StorageSharedKeyCredential)) {\n        throw new RangeError(\n          \"Can only generate the SAS when the client is initialized with a shared key credential\"\n        );\n      }\n\n      const sas = generateBlobSASQueryParameters(\n        {\n          containerName: this._containerName,\n          ...options,\n        },\n        this.credential\n      ).toString();\n\n      resolve(appendToURLQuery(this.url, sas));\n    });\n  }\n\n  /**\n   * Creates a BlobBatchClient object to conduct batch operations.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/blob-batch\n   *\n   * @returns A new BlobBatchClient object for this container.\n   */\n  public getBlobBatchClient(): BlobBatchClient {\n    return new BlobBatchClient(this.url, this.pipeline);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}