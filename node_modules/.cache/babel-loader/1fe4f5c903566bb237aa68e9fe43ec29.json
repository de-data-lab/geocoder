{"ast":null,"code":"import _asyncToGenerator from \"/Users/tbeckett/Documents/geo-react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _createForOfIteratorHelper from \"/Users/tbeckett/Documents/geo-react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nvar _marked = /*#__PURE__*/_regeneratorRuntime().mark(ExtractPageRangeInfoItems);\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { HttpHeaders, isNode, URLBuilder } from \"@azure/core-http\";\nimport { DevelopmentConnectionString, HeaderConstants, PathStylePorts, URLConstants } from \"./constants\";\n/**\n * Reserved URL characters must be properly escaped for Storage services like Blob or File.\n *\n * ## URL encode and escape strategy for JS SDKs\n *\n * When customers pass a URL string into XxxClient classes constructor, the URL string may already be URL encoded or not.\n * But before sending to Azure Storage server, the URL must be encoded. However, it's hard for a SDK to guess whether the URL\n * string has been encoded or not. We have 2 potential strategies, and chose strategy two for the XxxClient constructors.\n *\n * ### Strategy One: Assume the customer URL string is not encoded, and always encode URL string in SDK.\n *\n * This is what legacy V2 SDK does, simple and works for most of the cases.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b:\",\n *   SDK will encode it to \"http://account.blob.core.windows.net/con/b%3A\" and send to server. A blob named \"b:\" will be created.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b%3A\",\n *   SDK will encode it to \"http://account.blob.core.windows.net/con/b%253A\" and send to server. A blob named \"b%3A\" will be created.\n *\n * But this strategy will make it not possible to create a blob with \"?\" in it's name. Because when customer URL string is\n * \"http://account.blob.core.windows.net/con/blob?name\", the \"?name\" will be treated as URL paramter instead of blob name.\n * If customer URL string is \"http://account.blob.core.windows.net/con/blob%3Fname\", a blob named \"blob%3Fname\" will be created.\n * V2 SDK doesn't have this issue because it doesn't allow customer pass in a full URL, it accepts a separate blob name and encodeURIComponent for it.\n * We cannot accept a SDK cannot create a blob name with \"?\". So we implement strategy two:\n *\n * ### Strategy Two: SDK doesn't assume the URL has been encoded or not. It will just escape the special characters.\n *\n * This is what V10 Blob Go SDK does. It accepts a URL type in Go, and call url.EscapedPath() to escape the special chars unescaped.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b:\",\n *   SDK will escape \":\" like \"http://account.blob.core.windows.net/con/b%3A\" and send to server. A blob named \"b:\" will be created.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b%3A\",\n *   There is no special characters, so send \"http://account.blob.core.windows.net/con/b%3A\" to server. A blob named \"b:\" will be created.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b%253A\",\n *   There is no special characters, so send \"http://account.blob.core.windows.net/con/b%253A\" to server. A blob named \"b%3A\" will be created.\n *\n * This strategy gives us flexibility to create with any special characters. But \"%\" will be treated as a special characters, if the URL string\n * is not encoded, there shouldn't a \"%\" in the URL string, otherwise the URL is not a valid URL.\n * If customer needs to create a blob with \"%\" in it's blob name, use \"%25\" instead of \"%\". Just like above 3rd sample.\n * And following URL strings are invalid:\n * - \"http://account.blob.core.windows.net/con/b%\"\n * - \"http://account.blob.core.windows.net/con/b%2\"\n * - \"http://account.blob.core.windows.net/con/b%G\"\n *\n * Another special character is \"?\", use \"%2F\" to represent a blob name with \"?\" in a URL string.\n *\n * ### Strategy for containerName, blobName or other specific XXXName parameters in methods such as `containerClient.getBlobClient(blobName)`\n *\n * We will apply strategy one, and call encodeURIComponent for these parameters like blobName. Because what customers passes in is a plain name instead of a URL.\n *\n * @see https://docs.microsoft.com/en-us/rest/api/storageservices/naming-and-referencing-containers--blobs--and-metadata\n * @see https://docs.microsoft.com/en-us/rest/api/storageservices/naming-and-referencing-shares--directories--files--and-metadata\n *\n * @param url -\n */\nexport function escapeURLPath(url) {\n  var urlParsed = URLBuilder.parse(url);\n  var path = urlParsed.getPath();\n  path = path || \"/\";\n  path = escape(path);\n  urlParsed.setPath(path);\n  return urlParsed.toString();\n}\nfunction getProxyUriFromDevConnString(connectionString) {\n  // Development Connection String\n  // https://docs.microsoft.com/en-us/azure/storage/common/storage-configure-connection-string#connect-to-the-emulator-account-using-the-well-known-account-name-and-key\n  var proxyUri = \"\";\n  if (connectionString.search(\"DevelopmentStorageProxyUri=\") !== -1) {\n    // CONNECTION_STRING=UseDevelopmentStorage=true;DevelopmentStorageProxyUri=http://myProxyUri\n    var matchCredentials = connectionString.split(\";\");\n    var _iterator = _createForOfIteratorHelper(matchCredentials),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var element = _step.value;\n        if (element.trim().startsWith(\"DevelopmentStorageProxyUri=\")) {\n          proxyUri = element.trim().match(\"DevelopmentStorageProxyUri=(.*)\")[1];\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n  return proxyUri;\n}\nexport function getValueInConnString(connectionString, argument) {\n  var elements = connectionString.split(\";\");\n  var _iterator2 = _createForOfIteratorHelper(elements),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var element = _step2.value;\n      if (element.trim().startsWith(argument)) {\n        return element.trim().match(argument + \"=(.*)\")[1];\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return \"\";\n}\n/**\n * Extracts the parts of an Azure Storage account connection string.\n *\n * @param connectionString - Connection string.\n * @returns String key value pairs of the storage account's url and credentials.\n */\nexport function extractConnectionStringParts(connectionString) {\n  var proxyUri = \"\";\n  if (connectionString.startsWith(\"UseDevelopmentStorage=true\")) {\n    // Development connection string\n    proxyUri = getProxyUriFromDevConnString(connectionString);\n    connectionString = DevelopmentConnectionString;\n  }\n  // Matching BlobEndpoint in the Account connection string\n  var blobEndpoint = getValueInConnString(connectionString, \"BlobEndpoint\");\n  // Slicing off '/' at the end if exists\n  // (The methods that use `extractConnectionStringParts` expect the url to not have `/` at the end)\n  blobEndpoint = blobEndpoint.endsWith(\"/\") ? blobEndpoint.slice(0, -1) : blobEndpoint;\n  if (connectionString.search(\"DefaultEndpointsProtocol=\") !== -1 && connectionString.search(\"AccountKey=\") !== -1) {\n    // Account connection string\n    var defaultEndpointsProtocol = \"\";\n    var accountName = \"\";\n    var accountKey = Buffer.from(\"accountKey\", \"base64\");\n    var endpointSuffix = \"\";\n    // Get account name and key\n    accountName = getValueInConnString(connectionString, \"AccountName\");\n    accountKey = Buffer.from(getValueInConnString(connectionString, \"AccountKey\"), \"base64\");\n    if (!blobEndpoint) {\n      // BlobEndpoint is not present in the Account connection string\n      // Can be obtained from `${defaultEndpointsProtocol}://${accountName}.blob.${endpointSuffix}`\n      defaultEndpointsProtocol = getValueInConnString(connectionString, \"DefaultEndpointsProtocol\");\n      var protocol = defaultEndpointsProtocol.toLowerCase();\n      if (protocol !== \"https\" && protocol !== \"http\") {\n        throw new Error(\"Invalid DefaultEndpointsProtocol in the provided Connection String. Expecting 'https' or 'http'\");\n      }\n      endpointSuffix = getValueInConnString(connectionString, \"EndpointSuffix\");\n      if (!endpointSuffix) {\n        throw new Error(\"Invalid EndpointSuffix in the provided Connection String\");\n      }\n      blobEndpoint = \"\".concat(defaultEndpointsProtocol, \"://\").concat(accountName, \".blob.\").concat(endpointSuffix);\n    }\n    if (!accountName) {\n      throw new Error(\"Invalid AccountName in the provided Connection String\");\n    } else if (accountKey.length === 0) {\n      throw new Error(\"Invalid AccountKey in the provided Connection String\");\n    }\n    return {\n      kind: \"AccountConnString\",\n      url: blobEndpoint,\n      accountName: accountName,\n      accountKey: accountKey,\n      proxyUri: proxyUri\n    };\n  } else {\n    // SAS connection string\n    var accountSas = getValueInConnString(connectionString, \"SharedAccessSignature\");\n    var _accountName = getAccountNameFromUrl(blobEndpoint);\n    if (!blobEndpoint) {\n      throw new Error(\"Invalid BlobEndpoint in the provided SAS Connection String\");\n    } else if (!accountSas) {\n      throw new Error(\"Invalid SharedAccessSignature in the provided SAS Connection String\");\n    }\n    return {\n      kind: \"SASConnString\",\n      url: blobEndpoint,\n      accountName: _accountName,\n      accountSas: accountSas\n    };\n  }\n}\n/**\n * Internal escape method implemented Strategy Two mentioned in escapeURL() description.\n *\n * @param text -\n */\nfunction escape(text) {\n  return encodeURIComponent(text).replace(/%2F/g, \"/\") // Don't escape for \"/\"\n  .replace(/'/g, \"%27\") // Escape for \"'\"\n  .replace(/\\+/g, \"%20\").replace(/%25/g, \"%\"); // Revert encoded \"%\"\n}\n/**\n * Append a string to URL path. Will remove duplicated \"/\" in front of the string\n * when URL path ends with a \"/\".\n *\n * @param url - Source URL string\n * @param name - String to be appended to URL\n * @returns An updated URL string\n */\nexport function appendToURLPath(url, name) {\n  var urlParsed = URLBuilder.parse(url);\n  var path = urlParsed.getPath();\n  path = path ? path.endsWith(\"/\") ? \"\".concat(path).concat(name) : \"\".concat(path, \"/\").concat(name) : name;\n  urlParsed.setPath(path);\n  return urlParsed.toString();\n}\n/**\n * Set URL parameter name and value. If name exists in URL parameters, old value\n * will be replaced by name key. If not provide value, the parameter will be deleted.\n *\n * @param url - Source URL string\n * @param name - Parameter name\n * @param value - Parameter value\n * @returns An updated URL string\n */\nexport function setURLParameter(url, name, value) {\n  var urlParsed = URLBuilder.parse(url);\n  urlParsed.setQueryParameter(name, value);\n  return urlParsed.toString();\n}\n/**\n * Get URL parameter by name.\n *\n * @param url -\n * @param name -\n */\nexport function getURLParameter(url, name) {\n  var urlParsed = URLBuilder.parse(url);\n  return urlParsed.getQueryParameterValue(name);\n}\n/**\n * Set URL host.\n *\n * @param url - Source URL string\n * @param host - New host string\n * @returns An updated URL string\n */\nexport function setURLHost(url, host) {\n  var urlParsed = URLBuilder.parse(url);\n  urlParsed.setHost(host);\n  return urlParsed.toString();\n}\n/**\n * Get URL path from an URL string.\n *\n * @param url - Source URL string\n */\nexport function getURLPath(url) {\n  var urlParsed = URLBuilder.parse(url);\n  return urlParsed.getPath();\n}\n/**\n * Get URL scheme from an URL string.\n *\n * @param url - Source URL string\n */\nexport function getURLScheme(url) {\n  var urlParsed = URLBuilder.parse(url);\n  return urlParsed.getScheme();\n}\n/**\n * Get URL path and query from an URL string.\n *\n * @param url - Source URL string\n */\nexport function getURLPathAndQuery(url) {\n  var urlParsed = URLBuilder.parse(url);\n  var pathString = urlParsed.getPath();\n  if (!pathString) {\n    throw new RangeError(\"Invalid url without valid path.\");\n  }\n  var queryString = urlParsed.getQuery() || \"\";\n  queryString = queryString.trim();\n  if (queryString !== \"\") {\n    queryString = queryString.startsWith(\"?\") ? queryString : \"?\".concat(queryString); // Ensure query string start with '?'\n  }\n\n  return \"\".concat(pathString).concat(queryString);\n}\n/**\n * Get URL query key value pairs from an URL string.\n *\n * @param url -\n */\nexport function getURLQueries(url) {\n  var queryString = URLBuilder.parse(url).getQuery();\n  if (!queryString) {\n    return {};\n  }\n  queryString = queryString.trim();\n  queryString = queryString.startsWith(\"?\") ? queryString.substr(1) : queryString;\n  var querySubStrings = queryString.split(\"&\");\n  querySubStrings = querySubStrings.filter(function (value) {\n    var indexOfEqual = value.indexOf(\"=\");\n    var lastIndexOfEqual = value.lastIndexOf(\"=\");\n    return indexOfEqual > 0 && indexOfEqual === lastIndexOfEqual && lastIndexOfEqual < value.length - 1;\n  });\n  var queries = {};\n  var _iterator3 = _createForOfIteratorHelper(querySubStrings),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var querySubString = _step3.value;\n      var splitResults = querySubString.split(\"=\");\n      var key = splitResults[0];\n      var value = splitResults[1];\n      queries[key] = value;\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  return queries;\n}\n/**\n * Append a string to URL query.\n *\n * @param url - Source URL string.\n * @param queryParts - String to be appended to the URL query.\n * @returns An updated URL string.\n */\nexport function appendToURLQuery(url, queryParts) {\n  var urlParsed = URLBuilder.parse(url);\n  var query = urlParsed.getQuery();\n  if (query) {\n    query += \"&\" + queryParts;\n  } else {\n    query = queryParts;\n  }\n  urlParsed.setQuery(query);\n  return urlParsed.toString();\n}\n/**\n * Rounds a date off to seconds.\n *\n * @param date -\n * @param withMilliseconds - If true, YYYY-MM-DDThh:mm:ss.fffffffZ will be returned;\n *                                          If false, YYYY-MM-DDThh:mm:ssZ will be returned.\n * @returns Date string in ISO8061 format, with or without 7 milliseconds component\n */\nexport function truncatedISO8061Date(date) {\n  var withMilliseconds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  // Date.toISOString() will return like \"2018-10-29T06:34:36.139Z\"\n  var dateString = date.toISOString();\n  return withMilliseconds ? dateString.substring(0, dateString.length - 1) + \"0000\" + \"Z\" : dateString.substring(0, dateString.length - 5) + \"Z\";\n}\n/**\n * Base64 encode.\n *\n * @param content -\n */\nexport function base64encode(content) {\n  return !isNode ? btoa(content) : Buffer.from(content).toString(\"base64\");\n}\n/**\n * Base64 decode.\n *\n * @param encodedString -\n */\nexport function base64decode(encodedString) {\n  return !isNode ? atob(encodedString) : Buffer.from(encodedString, \"base64\").toString();\n}\n/**\n * Generate a 64 bytes base64 block ID string.\n *\n * @param blockIndex -\n */\nexport function generateBlockID(blockIDPrefix, blockIndex) {\n  // To generate a 64 bytes base64 string, source string should be 48\n  var maxSourceStringLength = 48;\n  // A blob can have a maximum of 100,000 uncommitted blocks at any given time\n  var maxBlockIndexLength = 6;\n  var maxAllowedBlockIDPrefixLength = maxSourceStringLength - maxBlockIndexLength;\n  if (blockIDPrefix.length > maxAllowedBlockIDPrefixLength) {\n    blockIDPrefix = blockIDPrefix.slice(0, maxAllowedBlockIDPrefixLength);\n  }\n  var res = blockIDPrefix + padStart(blockIndex.toString(), maxSourceStringLength - blockIDPrefix.length, \"0\");\n  return base64encode(res);\n}\n/**\n * Delay specified time interval.\n *\n * @param timeInMs -\n * @param aborter -\n * @param abortError -\n */\nexport function delay(_x, _x2, _x3) {\n  return _delay.apply(this, arguments);\n}\n/**\n * String.prototype.padStart()\n *\n * @param currentString -\n * @param targetLength -\n * @param padString -\n */\nfunction _delay() {\n  _delay = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(timeInMs, aborter, abortError) {\n    return _regeneratorRuntime().wrap(function _callee$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            return _context2.abrupt(\"return\", new Promise(function (resolve, reject) {\n              /* eslint-disable-next-line prefer-const */\n              var timeout;\n              var abortHandler = function abortHandler() {\n                if (timeout !== undefined) {\n                  clearTimeout(timeout);\n                }\n                reject(abortError);\n              };\n              var resolveHandler = function resolveHandler() {\n                if (aborter !== undefined) {\n                  aborter.removeEventListener(\"abort\", abortHandler);\n                }\n                resolve();\n              };\n              timeout = setTimeout(resolveHandler, timeInMs);\n              if (aborter !== undefined) {\n                aborter.addEventListener(\"abort\", abortHandler);\n              }\n            }));\n          case 1:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _delay.apply(this, arguments);\n}\nexport function padStart(currentString, targetLength) {\n  var padString = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \" \";\n  // @ts-expect-error: TS doesn't know this code needs to run downlevel sometimes\n  if (String.prototype.padStart) {\n    return currentString.padStart(targetLength, padString);\n  }\n  padString = padString || \" \";\n  if (currentString.length > targetLength) {\n    return currentString;\n  } else {\n    targetLength = targetLength - currentString.length;\n    if (targetLength > padString.length) {\n      padString += padString.repeat(targetLength / padString.length);\n    }\n    return padString.slice(0, targetLength) + currentString;\n  }\n}\nexport function sanitizeURL(url) {\n  var safeURL = url;\n  if (getURLParameter(safeURL, URLConstants.Parameters.SIGNATURE)) {\n    safeURL = setURLParameter(safeURL, URLConstants.Parameters.SIGNATURE, \"*****\");\n  }\n  return safeURL;\n}\nexport function sanitizeHeaders(originalHeader) {\n  var headers = new HttpHeaders();\n  var _iterator4 = _createForOfIteratorHelper(originalHeader.headersArray()),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var header = _step4.value;\n      if (header.name.toLowerCase() === HeaderConstants.AUTHORIZATION.toLowerCase()) {\n        headers.set(header.name, \"*****\");\n      } else if (header.name.toLowerCase() === HeaderConstants.X_MS_COPY_SOURCE) {\n        headers.set(header.name, sanitizeURL(header.value));\n      } else {\n        headers.set(header.name, header.value);\n      }\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n  return headers;\n}\n/**\n * If two strings are equal when compared case insensitive.\n *\n * @param str1 -\n * @param str2 -\n */\nexport function iEqual(str1, str2) {\n  return str1.toLocaleLowerCase() === str2.toLocaleLowerCase();\n}\n/**\n * Extracts account name from the url\n * @param url - url to extract the account name from\n * @returns with the account name\n */\nexport function getAccountNameFromUrl(url) {\n  var parsedUrl = URLBuilder.parse(url);\n  var accountName;\n  try {\n    if (parsedUrl.getHost().split(\".\")[1] === \"blob\") {\n      // `${defaultEndpointsProtocol}://${accountName}.blob.${endpointSuffix}`;\n      accountName = parsedUrl.getHost().split(\".\")[0];\n    } else if (isIpEndpointStyle(parsedUrl)) {\n      // IPv4/IPv6 address hosts... Example - http://192.0.0.10:10001/devstoreaccount1/\n      // Single word domain without a [dot] in the endpoint... Example - http://localhost:10001/devstoreaccount1/\n      // .getPath() -> /devstoreaccount1/\n      accountName = parsedUrl.getPath().split(\"/\")[1];\n    } else {\n      // Custom domain case: \"https://customdomain.com/containername/blob\".\n      accountName = \"\";\n    }\n    return accountName;\n  } catch (error) {\n    throw new Error(\"Unable to extract accountName with provided information.\");\n  }\n}\nexport function isIpEndpointStyle(parsedUrl) {\n  if (parsedUrl.getHost() === undefined) {\n    return false;\n  }\n  var host = parsedUrl.getHost() + (parsedUrl.getPort() === undefined ? \"\" : \":\" + parsedUrl.getPort());\n  // Case 1: Ipv6, use a broad regex to find out candidates whose host contains two ':'.\n  // Case 2: localhost(:port), use broad regex to match port part.\n  // Case 3: Ipv4, use broad regex which just check if host contains Ipv4.\n  // For valid host please refer to https://man7.org/linux/man-pages/man7/hostname.7.html.\n  return /^.*:.*:.*$|^localhost(:[0-9]+)?$|^(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])(\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])){3}(:[0-9]+)?$/.test(host) || parsedUrl.getPort() !== undefined && PathStylePorts.includes(parsedUrl.getPort());\n}\n/**\n * Convert Tags to encoded string.\n *\n * @param tags -\n */\nexport function toBlobTagsString(tags) {\n  if (tags === undefined) {\n    return undefined;\n  }\n  var tagPairs = [];\n  for (var key in tags) {\n    if (Object.prototype.hasOwnProperty.call(tags, key)) {\n      var value = tags[key];\n      tagPairs.push(\"\".concat(encodeURIComponent(key), \"=\").concat(encodeURIComponent(value)));\n    }\n  }\n  return tagPairs.join(\"&\");\n}\n/**\n * Convert Tags type to BlobTags.\n *\n * @param tags -\n */\nexport function toBlobTags(tags) {\n  if (tags === undefined) {\n    return undefined;\n  }\n  var res = {\n    blobTagSet: []\n  };\n  for (var key in tags) {\n    if (Object.prototype.hasOwnProperty.call(tags, key)) {\n      var value = tags[key];\n      res.blobTagSet.push({\n        key: key,\n        value: value\n      });\n    }\n  }\n  return res;\n}\n/**\n * Covert BlobTags to Tags type.\n *\n * @param tags -\n */\nexport function toTags(tags) {\n  if (tags === undefined) {\n    return undefined;\n  }\n  var res = {};\n  var _iterator5 = _createForOfIteratorHelper(tags.blobTagSet),\n    _step5;\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var blobTag = _step5.value;\n      res[blobTag.key] = blobTag.value;\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n  return res;\n}\n/**\n * Convert BlobQueryTextConfiguration to QuerySerialization type.\n *\n * @param textConfiguration -\n */\nexport function toQuerySerialization(textConfiguration) {\n  if (textConfiguration === undefined) {\n    return undefined;\n  }\n  switch (textConfiguration.kind) {\n    case \"csv\":\n      return {\n        format: {\n          type: \"delimited\",\n          delimitedTextConfiguration: {\n            columnSeparator: textConfiguration.columnSeparator || \",\",\n            fieldQuote: textConfiguration.fieldQuote || \"\",\n            recordSeparator: textConfiguration.recordSeparator,\n            escapeChar: textConfiguration.escapeCharacter || \"\",\n            headersPresent: textConfiguration.hasHeaders || false\n          }\n        }\n      };\n    case \"json\":\n      return {\n        format: {\n          type: \"json\",\n          jsonTextConfiguration: {\n            recordSeparator: textConfiguration.recordSeparator\n          }\n        }\n      };\n    case \"arrow\":\n      return {\n        format: {\n          type: \"arrow\",\n          arrowConfiguration: {\n            schema: textConfiguration.schema\n          }\n        }\n      };\n    case \"parquet\":\n      return {\n        format: {\n          type: \"parquet\"\n        }\n      };\n    default:\n      throw Error(\"Invalid BlobQueryTextConfiguration.\");\n  }\n}\nexport function parseObjectReplicationRecord(objectReplicationRecord) {\n  if (!objectReplicationRecord) {\n    return undefined;\n  }\n  if (\"policy-id\" in objectReplicationRecord) {\n    // If the dictionary contains a key with policy id, we are not required to do any parsing since\n    // the policy id should already be stored in the ObjectReplicationDestinationPolicyId.\n    return undefined;\n  }\n  var orProperties = [];\n  var _loop = function _loop(key) {\n    var ids = key.split(\"_\");\n    var policyPrefix = \"or-\";\n    if (ids[0].startsWith(policyPrefix)) {\n      ids[0] = ids[0].substring(policyPrefix.length);\n    }\n    var rule = {\n      ruleId: ids[1],\n      replicationStatus: objectReplicationRecord[key]\n    };\n    var policyIndex = orProperties.findIndex(function (policy) {\n      return policy.policyId === ids[0];\n    });\n    if (policyIndex > -1) {\n      orProperties[policyIndex].rules.push(rule);\n    } else {\n      orProperties.push({\n        policyId: ids[0],\n        rules: [rule]\n      });\n    }\n  };\n  for (var key in objectReplicationRecord) {\n    _loop(key);\n  }\n  return orProperties;\n}\n/**\n * Attach a TokenCredential to an object.\n *\n * @param thing -\n * @param credential -\n */\nexport function attachCredential(thing, credential) {\n  thing.credential = credential;\n  return thing;\n}\nexport function httpAuthorizationToString(httpAuthorization) {\n  return httpAuthorization ? httpAuthorization.scheme + \" \" + httpAuthorization.value : undefined;\n}\nexport function BlobNameToString(name) {\n  if (name.encoded) {\n    return decodeURIComponent(name.content);\n  } else {\n    return name.content;\n  }\n}\nexport function ConvertInternalResponseOfListBlobFlat(internalResponse) {\n  return Object.assign(Object.assign({}, internalResponse), {\n    segment: {\n      blobItems: internalResponse.segment.blobItems.map(function (blobItemInteral) {\n        var blobItem = Object.assign(Object.assign({}, blobItemInteral), {\n          name: BlobNameToString(blobItemInteral.name)\n        });\n        return blobItem;\n      })\n    }\n  });\n}\nexport function ConvertInternalResponseOfListBlobHierarchy(internalResponse) {\n  var _a;\n  return Object.assign(Object.assign({}, internalResponse), {\n    segment: {\n      blobPrefixes: (_a = internalResponse.segment.blobPrefixes) === null || _a === void 0 ? void 0 : _a.map(function (blobPrefixInternal) {\n        var blobPrefix = {\n          name: BlobNameToString(blobPrefixInternal.name)\n        };\n        return blobPrefix;\n      }),\n      blobItems: internalResponse.segment.blobItems.map(function (blobItemInteral) {\n        var blobItem = Object.assign(Object.assign({}, blobItemInteral), {\n          name: BlobNameToString(blobItemInteral.name)\n        });\n        return blobItem;\n      })\n    }\n  });\n}\nfunction decodeBase64String(value) {\n  if (isNode) {\n    return Buffer.from(value, \"base64\");\n  } else {\n    var byteString = atob(value);\n    var arr = new Uint8Array(byteString.length);\n    for (var i = 0; i < byteString.length; i++) {\n      arr[i] = byteString.charCodeAt(i);\n    }\n    return arr;\n  }\n}\nfunction ParseBoolean(content) {\n  if (content === undefined) return undefined;\n  if (content === \"true\") return true;\n  if (content === \"false\") return false;\n  return undefined;\n}\nfunction ParseBlobName(blobNameInXML) {\n  if (blobNameInXML[\"$\"] !== undefined && blobNameInXML[\"#\"] !== undefined) {\n    return {\n      encoded: ParseBoolean(blobNameInXML[\"$\"][\"Encoded\"]),\n      content: blobNameInXML[\"#\"]\n    };\n  } else {\n    return {\n      encoded: false,\n      content: blobNameInXML\n    };\n  }\n}\nfunction ParseBlobProperties(blobPropertiesInXML) {\n  var blobProperties = blobPropertiesInXML;\n  if (blobPropertiesInXML[\"Creation-Time\"]) {\n    blobProperties.createdOn = new Date(blobPropertiesInXML[\"Creation-Time\"]);\n    delete blobProperties[\"Creation-Time\"];\n  }\n  if (blobPropertiesInXML[\"Last-Modified\"]) {\n    blobProperties.lastModified = new Date(blobPropertiesInXML[\"Last-Modified\"]);\n    delete blobProperties[\"Last-Modified\"];\n  }\n  if (blobPropertiesInXML[\"Etag\"]) {\n    blobProperties.etag = blobPropertiesInXML[\"Etag\"];\n    delete blobProperties[\"Etag\"];\n  }\n  if (blobPropertiesInXML[\"Content-Length\"]) {\n    blobProperties.contentLength = parseFloat(blobPropertiesInXML[\"Content-Length\"]);\n    delete blobProperties[\"Content-Length\"];\n  }\n  if (blobPropertiesInXML[\"Content-Type\"]) {\n    blobProperties.contentType = blobPropertiesInXML[\"Content-Type\"];\n    delete blobProperties[\"Content-Type\"];\n  }\n  if (blobPropertiesInXML[\"Content-Encoding\"]) {\n    blobProperties.contentEncoding = blobPropertiesInXML[\"Content-Encoding\"];\n    delete blobProperties[\"Content-Encoding\"];\n  }\n  if (blobPropertiesInXML[\"Content-Language\"]) {\n    blobProperties.contentLanguage = blobPropertiesInXML[\"Content-Language\"];\n    delete blobProperties[\"Content-Language\"];\n  }\n  if (blobPropertiesInXML[\"Content-MD5\"]) {\n    blobProperties.contentMD5 = decodeBase64String(blobPropertiesInXML[\"Content-MD5\"]);\n    delete blobProperties[\"Content-MD5\"];\n  }\n  if (blobPropertiesInXML[\"Content-Disposition\"]) {\n    blobProperties.contentDisposition = blobPropertiesInXML[\"Content-Disposition\"];\n    delete blobProperties[\"Content-Disposition\"];\n  }\n  if (blobPropertiesInXML[\"Cache-Control\"]) {\n    blobProperties.cacheControl = blobPropertiesInXML[\"Cache-Control\"];\n    delete blobProperties[\"Cache-Control\"];\n  }\n  if (blobPropertiesInXML[\"x-ms-blob-sequence-number\"]) {\n    blobProperties.blobSequenceNumber = parseFloat(blobPropertiesInXML[\"x-ms-blob-sequence-number\"]);\n    delete blobProperties[\"x-ms-blob-sequence-number\"];\n  }\n  if (blobPropertiesInXML[\"BlobType\"]) {\n    blobProperties.blobType = blobPropertiesInXML[\"BlobType\"];\n    delete blobProperties[\"BlobType\"];\n  }\n  if (blobPropertiesInXML[\"LeaseStatus\"]) {\n    blobProperties.leaseStatus = blobPropertiesInXML[\"LeaseStatus\"];\n    delete blobProperties[\"LeaseStatus\"];\n  }\n  if (blobPropertiesInXML[\"LeaseState\"]) {\n    blobProperties.leaseState = blobPropertiesInXML[\"LeaseState\"];\n    delete blobProperties[\"LeaseState\"];\n  }\n  if (blobPropertiesInXML[\"LeaseDuration\"]) {\n    blobProperties.leaseDuration = blobPropertiesInXML[\"LeaseDuration\"];\n    delete blobProperties[\"LeaseDuration\"];\n  }\n  if (blobPropertiesInXML[\"CopyId\"]) {\n    blobProperties.copyId = blobPropertiesInXML[\"CopyId\"];\n    delete blobProperties[\"CopyId\"];\n  }\n  if (blobPropertiesInXML[\"CopyStatus\"]) {\n    blobProperties.copyStatus = blobPropertiesInXML[\"CopyStatus\"];\n    delete blobProperties[\"CopyStatus\"];\n  }\n  if (blobPropertiesInXML[\"CopySource\"]) {\n    blobProperties.copySource = blobPropertiesInXML[\"CopySource\"];\n    delete blobProperties[\"CopySource\"];\n  }\n  if (blobPropertiesInXML[\"CopyProgress\"]) {\n    blobProperties.copyProgress = blobPropertiesInXML[\"CopyProgress\"];\n    delete blobProperties[\"CopyProgress\"];\n  }\n  if (blobPropertiesInXML[\"CopyCompletionTime\"]) {\n    blobProperties.copyCompletedOn = new Date(blobPropertiesInXML[\"CopyCompletionTime\"]);\n    delete blobProperties[\"CopyCompletionTime\"];\n  }\n  if (blobPropertiesInXML[\"CopyStatusDescription\"]) {\n    blobProperties.copyStatusDescription = blobPropertiesInXML[\"CopyStatusDescription\"];\n    delete blobProperties[\"CopyStatusDescription\"];\n  }\n  if (blobPropertiesInXML[\"ServerEncrypted\"]) {\n    blobProperties.serverEncrypted = ParseBoolean(blobPropertiesInXML[\"ServerEncrypted\"]);\n    delete blobProperties[\"ServerEncrypted\"];\n  }\n  if (blobPropertiesInXML[\"IncrementalCopy\"]) {\n    blobProperties.incrementalCopy = ParseBoolean(blobPropertiesInXML[\"IncrementalCopy\"]);\n    delete blobProperties[\"IncrementalCopy\"];\n  }\n  if (blobPropertiesInXML[\"DestinationSnapshot\"]) {\n    blobProperties.destinationSnapshot = blobPropertiesInXML[\"DestinationSnapshot\"];\n    delete blobProperties[\"DestinationSnapshot\"];\n  }\n  if (blobPropertiesInXML[\"DeletedTime\"]) {\n    blobProperties.deletedOn = new Date(blobPropertiesInXML[\"DeletedTime\"]);\n    delete blobProperties[\"DeletedTime\"];\n  }\n  if (blobPropertiesInXML[\"RemainingRetentionDays\"]) {\n    blobProperties.remainingRetentionDays = parseFloat(blobPropertiesInXML[\"RemainingRetentionDays\"]);\n    delete blobProperties[\"RemainingRetentionDays\"];\n  }\n  if (blobPropertiesInXML[\"AccessTier\"]) {\n    blobProperties.accessTier = blobPropertiesInXML[\"AccessTier\"];\n    delete blobProperties[\"AccessTier\"];\n  }\n  if (blobPropertiesInXML[\"AccessTierInferred\"]) {\n    blobProperties.accessTierInferred = ParseBoolean(blobPropertiesInXML[\"AccessTierInferred\"]);\n    delete blobProperties[\"AccessTierInferred\"];\n  }\n  if (blobPropertiesInXML[\"ArchiveStatus\"]) {\n    blobProperties.archiveStatus = blobPropertiesInXML[\"ArchiveStatus\"];\n    delete blobProperties[\"ArchiveStatus\"];\n  }\n  if (blobPropertiesInXML[\"CustomerProvidedKeySha256\"]) {\n    blobProperties.customerProvidedKeySha256 = blobPropertiesInXML[\"CustomerProvidedKeySha256\"];\n    delete blobProperties[\"CustomerProvidedKeySha256\"];\n  }\n  if (blobPropertiesInXML[\"EncryptionScope\"]) {\n    blobProperties.encryptionScope = blobPropertiesInXML[\"EncryptionScope\"];\n    delete blobProperties[\"EncryptionScope\"];\n  }\n  if (blobPropertiesInXML[\"AccessTierChangeTime\"]) {\n    blobProperties.accessTierChangedOn = new Date(blobPropertiesInXML[\"AccessTierChangeTime\"]);\n    delete blobProperties[\"AccessTierChangeTime\"];\n  }\n  if (blobPropertiesInXML[\"TagCount\"]) {\n    blobProperties.tagCount = parseFloat(blobPropertiesInXML[\"TagCount\"]);\n    delete blobProperties[\"TagCount\"];\n  }\n  if (blobPropertiesInXML[\"Expiry-Time\"]) {\n    blobProperties.expiresOn = new Date(blobPropertiesInXML[\"Expiry-Time\"]);\n    delete blobProperties[\"Expiry-Time\"];\n  }\n  if (blobPropertiesInXML[\"Sealed\"]) {\n    blobProperties.isSealed = ParseBoolean(blobPropertiesInXML[\"Sealed\"]);\n    delete blobProperties[\"Sealed\"];\n  }\n  if (blobPropertiesInXML[\"RehydratePriority\"]) {\n    blobProperties.rehydratePriority = blobPropertiesInXML[\"RehydratePriority\"];\n    delete blobProperties[\"RehydratePriority\"];\n  }\n  if (blobPropertiesInXML[\"LastAccessTime\"]) {\n    blobProperties.lastAccessedOn = new Date(blobPropertiesInXML[\"LastAccessTime\"]);\n    delete blobProperties[\"LastAccessTime\"];\n  }\n  if (blobPropertiesInXML[\"ImmutabilityPolicyUntilDate\"]) {\n    blobProperties.immutabilityPolicyExpiresOn = new Date(blobPropertiesInXML[\"ImmutabilityPolicyUntilDate\"]);\n    delete blobProperties[\"ImmutabilityPolicyUntilDate\"];\n  }\n  if (blobPropertiesInXML[\"ImmutabilityPolicyMode\"]) {\n    blobProperties.immutabilityPolicyMode = blobPropertiesInXML[\"ImmutabilityPolicyMode\"];\n    delete blobProperties[\"ImmutabilityPolicyMode\"];\n  }\n  if (blobPropertiesInXML[\"LegalHold\"]) {\n    blobProperties.legalHold = ParseBoolean(blobPropertiesInXML[\"LegalHold\"]);\n    delete blobProperties[\"LegalHold\"];\n  }\n  return blobProperties;\n}\nfunction ParseBlobItem(blobInXML) {\n  var blobItem = blobInXML;\n  blobItem.properties = ParseBlobProperties(blobInXML[\"Properties\"]);\n  delete blobItem[\"Properties\"];\n  blobItem.name = ParseBlobName(blobInXML[\"Name\"]);\n  delete blobItem[\"Name\"];\n  blobItem.deleted = ParseBoolean(blobInXML[\"Deleted\"]);\n  delete blobItem[\"Deleted\"];\n  if (blobInXML[\"Snapshot\"]) {\n    blobItem.snapshot = blobInXML[\"Snapshot\"];\n    delete blobItem[\"Snapshot\"];\n  }\n  if (blobInXML[\"VersionId\"]) {\n    blobItem.versionId = blobInXML[\"VersionId\"];\n    delete blobItem[\"VersionId\"];\n  }\n  if (blobInXML[\"IsCurrentVersion\"]) {\n    blobItem.isCurrentVersion = ParseBoolean(blobInXML[\"IsCurrentVersion\"]);\n    delete blobItem[\"IsCurrentVersion\"];\n  }\n  if (blobInXML[\"Metadata\"]) {\n    blobItem.metadata = blobInXML[\"Metadata\"];\n    delete blobItem[\"Metadata\"];\n  }\n  if (blobInXML[\"Tags\"]) {\n    blobItem.blobTags = ParseBlobTags(blobInXML[\"Tags\"]);\n    delete blobItem[\"Tags\"];\n  }\n  if (blobInXML[\"OrMetadata\"]) {\n    blobItem.objectReplicationMetadata = blobInXML[\"OrMetadata\"];\n    delete blobItem[\"OrMetadata\"];\n  }\n  if (blobInXML[\"HasVersionsOnly\"]) {\n    blobItem.hasVersionsOnly = ParseBoolean(blobInXML[\"HasVersionsOnly\"]);\n    delete blobItem[\"HasVersionsOnly\"];\n  }\n  return blobItem;\n}\nfunction ParseBlobPrefix(blobPrefixInXML) {\n  return {\n    name: ParseBlobName(blobPrefixInXML[\"Name\"])\n  };\n}\nfunction ParseBlobTag(blobTagInXML) {\n  return {\n    key: blobTagInXML[\"Key\"],\n    value: blobTagInXML[\"Value\"]\n  };\n}\nfunction ParseBlobTags(blobTagsInXML) {\n  if (blobTagsInXML === undefined || blobTagsInXML[\"TagSet\"] === undefined || blobTagsInXML[\"TagSet\"][\"Tag\"] === undefined) {\n    return undefined;\n  }\n  var blobTagSet = [];\n  if (blobTagsInXML[\"TagSet\"][\"Tag\"] instanceof Array) {\n    blobTagsInXML[\"TagSet\"][\"Tag\"].forEach(function (blobTagInXML) {\n      blobTagSet.push(ParseBlobTag(blobTagInXML));\n    });\n  } else {\n    blobTagSet.push(ParseBlobTag(blobTagsInXML[\"TagSet\"][\"Tag\"]));\n  }\n  return {\n    blobTagSet: blobTagSet\n  };\n}\nexport function ProcessBlobItems(blobArrayInXML) {\n  var blobItems = [];\n  if (blobArrayInXML instanceof Array) {\n    blobArrayInXML.forEach(function (blobInXML) {\n      blobItems.push(ParseBlobItem(blobInXML));\n    });\n  } else {\n    blobItems.push(ParseBlobItem(blobArrayInXML));\n  }\n  return blobItems;\n}\nexport function ProcessBlobPrefixes(blobPrefixesInXML) {\n  var blobPrefixes = [];\n  if (blobPrefixesInXML instanceof Array) {\n    blobPrefixesInXML.forEach(function (blobPrefixInXML) {\n      blobPrefixes.push(ParseBlobPrefix(blobPrefixInXML));\n    });\n  } else {\n    blobPrefixes.push(ParseBlobPrefix(blobPrefixesInXML));\n  }\n  return blobPrefixes;\n}\nexport function ExtractPageRangeInfoItems(getPageRangesSegment) {\n  var pageRange, clearRange, pageRangeIndex, clearRangeIndex;\n  return _regeneratorRuntime().wrap(function ExtractPageRangeInfoItems$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          pageRange = [];\n          clearRange = [];\n          if (getPageRangesSegment.pageRange) pageRange = getPageRangesSegment.pageRange;\n          if (getPageRangesSegment.clearRange) clearRange = getPageRangesSegment.clearRange;\n          pageRangeIndex = 0;\n          clearRangeIndex = 0;\n        case 6:\n          if (!(pageRangeIndex < pageRange.length && clearRangeIndex < clearRange.length)) {\n            _context.next = 18;\n            break;\n          }\n          if (!(pageRange[pageRangeIndex].start < clearRange[clearRangeIndex].start)) {\n            _context.next = 13;\n            break;\n          }\n          _context.next = 10;\n          return {\n            start: pageRange[pageRangeIndex].start,\n            end: pageRange[pageRangeIndex].end,\n            isClear: false\n          };\n        case 10:\n          ++pageRangeIndex;\n          _context.next = 16;\n          break;\n        case 13:\n          _context.next = 15;\n          return {\n            start: clearRange[clearRangeIndex].start,\n            end: clearRange[clearRangeIndex].end,\n            isClear: true\n          };\n        case 15:\n          ++clearRangeIndex;\n        case 16:\n          _context.next = 6;\n          break;\n        case 18:\n          if (!(pageRangeIndex < pageRange.length)) {\n            _context.next = 24;\n            break;\n          }\n          _context.next = 21;\n          return {\n            start: pageRange[pageRangeIndex].start,\n            end: pageRange[pageRangeIndex].end,\n            isClear: false\n          };\n        case 21:\n          ++pageRangeIndex;\n          _context.next = 18;\n          break;\n        case 24:\n          if (!(clearRangeIndex < clearRange.length)) {\n            _context.next = 30;\n            break;\n          }\n          _context.next = 27;\n          return {\n            start: clearRange[clearRangeIndex].start,\n            end: clearRange[clearRangeIndex].end,\n            isClear: true\n          };\n        case 27:\n          ++clearRangeIndex;\n          _context.next = 24;\n          break;\n        case 30:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}\n/**\n * Escape the blobName but keep path separator ('/').\n */\nexport function EscapePath(blobName) {\n  var split = blobName.split(\"/\");\n  for (var i = 0; i < split.length; i++) {\n    split[i] = encodeURIComponent(split[i]);\n  }\n  return split.join(\"/\");\n}","map":{"version":3,"mappings":"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","names":["ExtractPageRangeInfoItems","HttpHeaders","isNode","URLBuilder","DevelopmentConnectionString","HeaderConstants","PathStylePorts","URLConstants","escapeURLPath","url","urlParsed","parse","path","getPath","escape","setPath","toString","getProxyUriFromDevConnString","connectionString","proxyUri","search","matchCredentials","split","element","trim","startsWith","match","getValueInConnString","argument","elements","extractConnectionStringParts","blobEndpoint","endsWith","slice","defaultEndpointsProtocol","accountName","accountKey","Buffer","from","endpointSuffix","protocol","toLowerCase","Error","length","kind","accountSas","getAccountNameFromUrl","text","encodeURIComponent","replace","appendToURLPath","name","setURLParameter","value","setQueryParameter","getURLParameter","getQueryParameterValue","setURLHost","host","setHost","getURLPath","getURLScheme","getScheme","getURLPathAndQuery","pathString","RangeError","queryString","getQuery","getURLQueries","substr","querySubStrings","filter","indexOfEqual","indexOf","lastIndexOfEqual","lastIndexOf","queries","querySubString","splitResults","key","appendToURLQuery","queryParts","query","setQuery","truncatedISO8061Date","date","withMilliseconds","dateString","toISOString","substring","base64encode","content","btoa","base64decode","encodedString","atob","generateBlockID","blockIDPrefix","blockIndex","maxSourceStringLength","maxBlockIndexLength","maxAllowedBlockIDPrefixLength","res","padStart","delay","timeInMs","aborter","abortError","Promise","resolve","reject","timeout","abortHandler","undefined","clearTimeout","resolveHandler","removeEventListener","setTimeout","addEventListener","currentString","targetLength","padString","String","prototype","repeat","sanitizeURL","safeURL","Parameters","SIGNATURE","sanitizeHeaders","originalHeader","headers","headersArray","header","AUTHORIZATION","set","X_MS_COPY_SOURCE","iEqual","str1","str2","toLocaleLowerCase","parsedUrl","getHost","isIpEndpointStyle","error","getPort","test","includes","toBlobTagsString","tags","tagPairs","Object","hasOwnProperty","call","push","join","toBlobTags","blobTagSet","toTags","blobTag","toQuerySerialization","textConfiguration","format","type","delimitedTextConfiguration","columnSeparator","fieldQuote","recordSeparator","escapeChar","escapeCharacter","headersPresent","hasHeaders","jsonTextConfiguration","arrowConfiguration","schema","parseObjectReplicationRecord","objectReplicationRecord","orProperties","ids","policyPrefix","rule","ruleId","replicationStatus","policyIndex","findIndex","policy","policyId","rules","attachCredential","thing","credential","httpAuthorizationToString","httpAuthorization","scheme","BlobNameToString","encoded","decodeURIComponent","ConvertInternalResponseOfListBlobFlat","internalResponse","segment","blobItems","map","blobItemInteral","blobItem","ConvertInternalResponseOfListBlobHierarchy","blobPrefixes","blobPrefixInternal","blobPrefix","decodeBase64String","byteString","arr","Uint8Array","i","charCodeAt","ParseBoolean","ParseBlobName","blobNameInXML","ParseBlobProperties","blobPropertiesInXML","blobProperties","createdOn","Date","lastModified","etag","contentLength","parseFloat","contentType","contentEncoding","contentLanguage","contentMD5","contentDisposition","cacheControl","blobSequenceNumber","blobType","leaseStatus","leaseState","leaseDuration","copyId","copyStatus","copySource","copyProgress","copyCompletedOn","copyStatusDescription","serverEncrypted","incrementalCopy","destinationSnapshot","deletedOn","remainingRetentionDays","accessTier","accessTierInferred","archiveStatus","customerProvidedKeySha256","encryptionScope","accessTierChangedOn","tagCount","expiresOn","isSealed","rehydratePriority","lastAccessedOn","immutabilityPolicyExpiresOn","immutabilityPolicyMode","legalHold","ParseBlobItem","blobInXML","properties","deleted","snapshot","versionId","isCurrentVersion","metadata","blobTags","ParseBlobTags","objectReplicationMetadata","hasVersionsOnly","ParseBlobPrefix","blobPrefixInXML","ParseBlobTag","blobTagInXML","blobTagsInXML","Array","forEach","ProcessBlobItems","blobArrayInXML","ProcessBlobPrefixes","blobPrefixesInXML","getPageRangesSegment","pageRange","clearRange","pageRangeIndex","clearRangeIndex","start","end","isClear","EscapePath","blobName"],"sourceRoot":"","sources":["../../../../src/utils/utils.common.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { HttpHeaders, isNode, URLBuilder, TokenCredential } from \"@azure/core-http\";\n\nimport {\n  BlobQueryArrowConfiguration,\n  BlobQueryCsvTextConfiguration,\n  BlobQueryJsonTextConfiguration,\n  BlobQueryParquetConfiguration,\n} from \"../Clients\";\nimport {\n  QuerySerialization,\n  BlobTags,\n  BlobName,\n  ListBlobsFlatSegmentResponse,\n  ListBlobsHierarchySegmentResponse,\n  BlobItemInternal,\n  BlobPrefix,\n  BlobType,\n  LeaseStatusType,\n  LeaseStateType,\n  LeaseDurationType,\n  CopyStatusType,\n  AccessTier,\n  ArchiveStatus,\n  RehydratePriority,\n  BlobImmutabilityPolicyMode,\n  BlobTag,\n  PageRange,\n  ClearRange,\n  BlobPropertiesInternal,\n} from \"../generated/src/models\";\nimport {\n  DevelopmentConnectionString,\n  HeaderConstants,\n  PathStylePorts,\n  URLConstants,\n} from \"./constants\";\nimport {\n  Tags,\n  ObjectReplicationPolicy,\n  ObjectReplicationRule,\n  ObjectReplicationStatus,\n  HttpAuthorization,\n} from \"../models\";\nimport {\n  ListBlobsFlatSegmentResponseModel,\n  BlobItemInternal as BlobItemInternalModel,\n  ListBlobsHierarchySegmentResponseModel,\n  BlobPrefix as BlobPrefixModel,\n  PageBlobGetPageRangesDiffResponseModel,\n  PageRangeInfo,\n} from \"../generatedModels\";\n\n/**\n * Reserved URL characters must be properly escaped for Storage services like Blob or File.\n *\n * ## URL encode and escape strategy for JS SDKs\n *\n * When customers pass a URL string into XxxClient classes constructor, the URL string may already be URL encoded or not.\n * But before sending to Azure Storage server, the URL must be encoded. However, it's hard for a SDK to guess whether the URL\n * string has been encoded or not. We have 2 potential strategies, and chose strategy two for the XxxClient constructors.\n *\n * ### Strategy One: Assume the customer URL string is not encoded, and always encode URL string in SDK.\n *\n * This is what legacy V2 SDK does, simple and works for most of the cases.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b:\",\n *   SDK will encode it to \"http://account.blob.core.windows.net/con/b%3A\" and send to server. A blob named \"b:\" will be created.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b%3A\",\n *   SDK will encode it to \"http://account.blob.core.windows.net/con/b%253A\" and send to server. A blob named \"b%3A\" will be created.\n *\n * But this strategy will make it not possible to create a blob with \"?\" in it's name. Because when customer URL string is\n * \"http://account.blob.core.windows.net/con/blob?name\", the \"?name\" will be treated as URL paramter instead of blob name.\n * If customer URL string is \"http://account.blob.core.windows.net/con/blob%3Fname\", a blob named \"blob%3Fname\" will be created.\n * V2 SDK doesn't have this issue because it doesn't allow customer pass in a full URL, it accepts a separate blob name and encodeURIComponent for it.\n * We cannot accept a SDK cannot create a blob name with \"?\". So we implement strategy two:\n *\n * ### Strategy Two: SDK doesn't assume the URL has been encoded or not. It will just escape the special characters.\n *\n * This is what V10 Blob Go SDK does. It accepts a URL type in Go, and call url.EscapedPath() to escape the special chars unescaped.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b:\",\n *   SDK will escape \":\" like \"http://account.blob.core.windows.net/con/b%3A\" and send to server. A blob named \"b:\" will be created.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b%3A\",\n *   There is no special characters, so send \"http://account.blob.core.windows.net/con/b%3A\" to server. A blob named \"b:\" will be created.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b%253A\",\n *   There is no special characters, so send \"http://account.blob.core.windows.net/con/b%253A\" to server. A blob named \"b%3A\" will be created.\n *\n * This strategy gives us flexibility to create with any special characters. But \"%\" will be treated as a special characters, if the URL string\n * is not encoded, there shouldn't a \"%\" in the URL string, otherwise the URL is not a valid URL.\n * If customer needs to create a blob with \"%\" in it's blob name, use \"%25\" instead of \"%\". Just like above 3rd sample.\n * And following URL strings are invalid:\n * - \"http://account.blob.core.windows.net/con/b%\"\n * - \"http://account.blob.core.windows.net/con/b%2\"\n * - \"http://account.blob.core.windows.net/con/b%G\"\n *\n * Another special character is \"?\", use \"%2F\" to represent a blob name with \"?\" in a URL string.\n *\n * ### Strategy for containerName, blobName or other specific XXXName parameters in methods such as `containerClient.getBlobClient(blobName)`\n *\n * We will apply strategy one, and call encodeURIComponent for these parameters like blobName. Because what customers passes in is a plain name instead of a URL.\n *\n * @see https://docs.microsoft.com/en-us/rest/api/storageservices/naming-and-referencing-containers--blobs--and-metadata\n * @see https://docs.microsoft.com/en-us/rest/api/storageservices/naming-and-referencing-shares--directories--files--and-metadata\n *\n * @param url -\n */\nexport function escapeURLPath(url: string): string {\n  const urlParsed = URLBuilder.parse(url);\n\n  let path = urlParsed.getPath();\n  path = path || \"/\";\n\n  path = escape(path);\n  urlParsed.setPath(path);\n\n  return urlParsed.toString();\n}\n\nexport interface ConnectionString {\n  kind: \"AccountConnString\" | \"SASConnString\";\n  url: string;\n  accountName: string;\n  accountKey?: any;\n  accountSas?: string;\n  proxyUri?: string; // Development Connection String may contain proxyUri\n}\n\nfunction getProxyUriFromDevConnString(connectionString: string): string {\n  // Development Connection String\n  // https://docs.microsoft.com/en-us/azure/storage/common/storage-configure-connection-string#connect-to-the-emulator-account-using-the-well-known-account-name-and-key\n  let proxyUri = \"\";\n  if (connectionString.search(\"DevelopmentStorageProxyUri=\") !== -1) {\n    // CONNECTION_STRING=UseDevelopmentStorage=true;DevelopmentStorageProxyUri=http://myProxyUri\n    const matchCredentials = connectionString.split(\";\");\n    for (const element of matchCredentials) {\n      if (element.trim().startsWith(\"DevelopmentStorageProxyUri=\")) {\n        proxyUri = element.trim().match(\"DevelopmentStorageProxyUri=(.*)\")![1];\n      }\n    }\n  }\n  return proxyUri;\n}\n\nexport function getValueInConnString(\n  connectionString: string,\n  argument:\n    | \"BlobEndpoint\"\n    | \"AccountName\"\n    | \"AccountKey\"\n    | \"DefaultEndpointsProtocol\"\n    | \"EndpointSuffix\"\n    | \"SharedAccessSignature\"\n): string {\n  const elements = connectionString.split(\";\");\n  for (const element of elements) {\n    if (element.trim().startsWith(argument)) {\n      return element.trim().match(argument + \"=(.*)\")![1];\n    }\n  }\n  return \"\";\n}\n\n/**\n * Extracts the parts of an Azure Storage account connection string.\n *\n * @param connectionString - Connection string.\n * @returns String key value pairs of the storage account's url and credentials.\n */\nexport function extractConnectionStringParts(connectionString: string): ConnectionString {\n  let proxyUri = \"\";\n\n  if (connectionString.startsWith(\"UseDevelopmentStorage=true\")) {\n    // Development connection string\n    proxyUri = getProxyUriFromDevConnString(connectionString);\n    connectionString = DevelopmentConnectionString;\n  }\n\n  // Matching BlobEndpoint in the Account connection string\n  let blobEndpoint = getValueInConnString(connectionString, \"BlobEndpoint\");\n  // Slicing off '/' at the end if exists\n  // (The methods that use `extractConnectionStringParts` expect the url to not have `/` at the end)\n  blobEndpoint = blobEndpoint.endsWith(\"/\") ? blobEndpoint.slice(0, -1) : blobEndpoint;\n\n  if (\n    connectionString.search(\"DefaultEndpointsProtocol=\") !== -1 &&\n    connectionString.search(\"AccountKey=\") !== -1\n  ) {\n    // Account connection string\n\n    let defaultEndpointsProtocol = \"\";\n    let accountName = \"\";\n    let accountKey = Buffer.from(\"accountKey\", \"base64\");\n    let endpointSuffix = \"\";\n\n    // Get account name and key\n    accountName = getValueInConnString(connectionString, \"AccountName\");\n    accountKey = Buffer.from(getValueInConnString(connectionString, \"AccountKey\"), \"base64\");\n\n    if (!blobEndpoint) {\n      // BlobEndpoint is not present in the Account connection string\n      // Can be obtained from `${defaultEndpointsProtocol}://${accountName}.blob.${endpointSuffix}`\n\n      defaultEndpointsProtocol = getValueInConnString(connectionString, \"DefaultEndpointsProtocol\");\n      const protocol = defaultEndpointsProtocol!.toLowerCase();\n      if (protocol !== \"https\" && protocol !== \"http\") {\n        throw new Error(\n          \"Invalid DefaultEndpointsProtocol in the provided Connection String. Expecting 'https' or 'http'\"\n        );\n      }\n\n      endpointSuffix = getValueInConnString(connectionString, \"EndpointSuffix\");\n      if (!endpointSuffix) {\n        throw new Error(\"Invalid EndpointSuffix in the provided Connection String\");\n      }\n      blobEndpoint = `${defaultEndpointsProtocol}://${accountName}.blob.${endpointSuffix}`;\n    }\n\n    if (!accountName) {\n      throw new Error(\"Invalid AccountName in the provided Connection String\");\n    } else if (accountKey.length === 0) {\n      throw new Error(\"Invalid AccountKey in the provided Connection String\");\n    }\n\n    return {\n      kind: \"AccountConnString\",\n      url: blobEndpoint,\n      accountName,\n      accountKey,\n      proxyUri,\n    };\n  } else {\n    // SAS connection string\n\n    const accountSas = getValueInConnString(connectionString, \"SharedAccessSignature\");\n    const accountName = getAccountNameFromUrl(blobEndpoint);\n    if (!blobEndpoint) {\n      throw new Error(\"Invalid BlobEndpoint in the provided SAS Connection String\");\n    } else if (!accountSas) {\n      throw new Error(\"Invalid SharedAccessSignature in the provided SAS Connection String\");\n    }\n\n    return { kind: \"SASConnString\", url: blobEndpoint, accountName, accountSas };\n  }\n}\n\n/**\n * Internal escape method implemented Strategy Two mentioned in escapeURL() description.\n *\n * @param text -\n */\nfunction escape(text: string): string {\n  return encodeURIComponent(text)\n    .replace(/%2F/g, \"/\") // Don't escape for \"/\"\n    .replace(/'/g, \"%27\") // Escape for \"'\"\n    .replace(/\\+/g, \"%20\")\n    .replace(/%25/g, \"%\"); // Revert encoded \"%\"\n}\n\n/**\n * Append a string to URL path. Will remove duplicated \"/\" in front of the string\n * when URL path ends with a \"/\".\n *\n * @param url - Source URL string\n * @param name - String to be appended to URL\n * @returns An updated URL string\n */\nexport function appendToURLPath(url: string, name: string): string {\n  const urlParsed = URLBuilder.parse(url);\n\n  let path = urlParsed.getPath();\n  path = path ? (path.endsWith(\"/\") ? `${path}${name}` : `${path}/${name}`) : name;\n  urlParsed.setPath(path);\n\n  return urlParsed.toString();\n}\n\n/**\n * Set URL parameter name and value. If name exists in URL parameters, old value\n * will be replaced by name key. If not provide value, the parameter will be deleted.\n *\n * @param url - Source URL string\n * @param name - Parameter name\n * @param value - Parameter value\n * @returns An updated URL string\n */\nexport function setURLParameter(url: string, name: string, value?: string): string {\n  const urlParsed = URLBuilder.parse(url);\n  urlParsed.setQueryParameter(name, value);\n  return urlParsed.toString();\n}\n\n/**\n * Get URL parameter by name.\n *\n * @param url -\n * @param name -\n */\nexport function getURLParameter(url: string, name: string): string | string[] | undefined {\n  const urlParsed = URLBuilder.parse(url);\n  return urlParsed.getQueryParameterValue(name);\n}\n\n/**\n * Set URL host.\n *\n * @param url - Source URL string\n * @param host - New host string\n * @returns An updated URL string\n */\nexport function setURLHost(url: string, host: string): string {\n  const urlParsed = URLBuilder.parse(url);\n  urlParsed.setHost(host);\n  return urlParsed.toString();\n}\n\n/**\n * Get URL path from an URL string.\n *\n * @param url - Source URL string\n */\nexport function getURLPath(url: string): string | undefined {\n  const urlParsed = URLBuilder.parse(url);\n  return urlParsed.getPath();\n}\n\n/**\n * Get URL scheme from an URL string.\n *\n * @param url - Source URL string\n */\nexport function getURLScheme(url: string): string | undefined {\n  const urlParsed = URLBuilder.parse(url);\n  return urlParsed.getScheme();\n}\n\n/**\n * Get URL path and query from an URL string.\n *\n * @param url - Source URL string\n */\nexport function getURLPathAndQuery(url: string): string | undefined {\n  const urlParsed = URLBuilder.parse(url);\n  const pathString = urlParsed.getPath();\n  if (!pathString) {\n    throw new RangeError(\"Invalid url without valid path.\");\n  }\n\n  let queryString = urlParsed.getQuery() || \"\";\n  queryString = queryString.trim();\n  if (queryString !== \"\") {\n    queryString = queryString.startsWith(\"?\") ? queryString : `?${queryString}`; // Ensure query string start with '?'\n  }\n\n  return `${pathString}${queryString}`;\n}\n\n/**\n * Get URL query key value pairs from an URL string.\n *\n * @param url -\n */\nexport function getURLQueries(url: string): { [key: string]: string } {\n  let queryString = URLBuilder.parse(url).getQuery();\n  if (!queryString) {\n    return {};\n  }\n\n  queryString = queryString.trim();\n  queryString = queryString.startsWith(\"?\") ? queryString.substr(1) : queryString;\n\n  let querySubStrings: string[] = queryString.split(\"&\");\n  querySubStrings = querySubStrings.filter((value: string) => {\n    const indexOfEqual = value.indexOf(\"=\");\n    const lastIndexOfEqual = value.lastIndexOf(\"=\");\n    return (\n      indexOfEqual > 0 && indexOfEqual === lastIndexOfEqual && lastIndexOfEqual < value.length - 1\n    );\n  });\n\n  const queries: { [key: string]: string } = {};\n  for (const querySubString of querySubStrings) {\n    const splitResults = querySubString.split(\"=\");\n    const key: string = splitResults[0];\n    const value: string = splitResults[1];\n    queries[key] = value;\n  }\n\n  return queries;\n}\n\n/**\n * Append a string to URL query.\n *\n * @param url - Source URL string.\n * @param queryParts - String to be appended to the URL query.\n * @returns An updated URL string.\n */\nexport function appendToURLQuery(url: string, queryParts: string): string {\n  const urlParsed = URLBuilder.parse(url);\n\n  let query = urlParsed.getQuery();\n  if (query) {\n    query += \"&\" + queryParts;\n  } else {\n    query = queryParts;\n  }\n\n  urlParsed.setQuery(query);\n  return urlParsed.toString();\n}\n\n/**\n * Rounds a date off to seconds.\n *\n * @param date -\n * @param withMilliseconds - If true, YYYY-MM-DDThh:mm:ss.fffffffZ will be returned;\n *                                          If false, YYYY-MM-DDThh:mm:ssZ will be returned.\n * @returns Date string in ISO8061 format, with or without 7 milliseconds component\n */\nexport function truncatedISO8061Date(date: Date, withMilliseconds: boolean = true): string {\n  // Date.toISOString() will return like \"2018-10-29T06:34:36.139Z\"\n  const dateString = date.toISOString();\n\n  return withMilliseconds\n    ? dateString.substring(0, dateString.length - 1) + \"0000\" + \"Z\"\n    : dateString.substring(0, dateString.length - 5) + \"Z\";\n}\n\n/**\n * Base64 encode.\n *\n * @param content -\n */\nexport function base64encode(content: string): string {\n  return !isNode ? btoa(content) : Buffer.from(content).toString(\"base64\");\n}\n\n/**\n * Base64 decode.\n *\n * @param encodedString -\n */\nexport function base64decode(encodedString: string): string {\n  return !isNode ? atob(encodedString) : Buffer.from(encodedString, \"base64\").toString();\n}\n\n/**\n * Generate a 64 bytes base64 block ID string.\n *\n * @param blockIndex -\n */\nexport function generateBlockID(blockIDPrefix: string, blockIndex: number): string {\n  // To generate a 64 bytes base64 string, source string should be 48\n  const maxSourceStringLength = 48;\n\n  // A blob can have a maximum of 100,000 uncommitted blocks at any given time\n  const maxBlockIndexLength = 6;\n\n  const maxAllowedBlockIDPrefixLength = maxSourceStringLength - maxBlockIndexLength;\n\n  if (blockIDPrefix.length > maxAllowedBlockIDPrefixLength) {\n    blockIDPrefix = blockIDPrefix.slice(0, maxAllowedBlockIDPrefixLength);\n  }\n  const res =\n    blockIDPrefix +\n    padStart(blockIndex.toString(), maxSourceStringLength - blockIDPrefix.length, \"0\");\n  return base64encode(res);\n}\n\n/**\n * Delay specified time interval.\n *\n * @param timeInMs -\n * @param aborter -\n * @param abortError -\n */\nexport async function delay(\n  timeInMs: number,\n  aborter?: AbortSignalLike,\n  abortError?: Error\n): Promise<void> {\n  return new Promise<void>((resolve, reject) => {\n    /* eslint-disable-next-line prefer-const */\n    let timeout: any;\n\n    const abortHandler = () => {\n      if (timeout !== undefined) {\n        clearTimeout(timeout);\n      }\n      reject(abortError);\n    };\n\n    const resolveHandler = () => {\n      if (aborter !== undefined) {\n        aborter.removeEventListener(\"abort\", abortHandler);\n      }\n      resolve();\n    };\n\n    timeout = setTimeout(resolveHandler, timeInMs);\n\n    if (aborter !== undefined) {\n      aborter.addEventListener(\"abort\", abortHandler);\n    }\n  });\n}\n\n/**\n * String.prototype.padStart()\n *\n * @param currentString -\n * @param targetLength -\n * @param padString -\n */\nexport function padStart(\n  currentString: string,\n  targetLength: number,\n  padString: string = \" \"\n): string {\n  // @ts-expect-error: TS doesn't know this code needs to run downlevel sometimes\n  if (String.prototype.padStart) {\n    return currentString.padStart(targetLength, padString);\n  }\n\n  padString = padString || \" \";\n  if (currentString.length > targetLength) {\n    return currentString;\n  } else {\n    targetLength = targetLength - currentString.length;\n    if (targetLength > padString.length) {\n      padString += padString.repeat(targetLength / padString.length);\n    }\n    return padString.slice(0, targetLength) + currentString;\n  }\n}\n\nexport function sanitizeURL(url: string): string {\n  let safeURL: string = url;\n  if (getURLParameter(safeURL, URLConstants.Parameters.SIGNATURE)) {\n    safeURL = setURLParameter(safeURL, URLConstants.Parameters.SIGNATURE, \"*****\");\n  }\n\n  return safeURL;\n}\n\nexport function sanitizeHeaders(originalHeader: HttpHeaders): HttpHeaders {\n  const headers: HttpHeaders = new HttpHeaders();\n  for (const header of originalHeader.headersArray()) {\n    if (header.name.toLowerCase() === HeaderConstants.AUTHORIZATION.toLowerCase()) {\n      headers.set(header.name, \"*****\");\n    } else if (header.name.toLowerCase() === HeaderConstants.X_MS_COPY_SOURCE) {\n      headers.set(header.name, sanitizeURL(header.value));\n    } else {\n      headers.set(header.name, header.value);\n    }\n  }\n\n  return headers;\n}\n/**\n * If two strings are equal when compared case insensitive.\n *\n * @param str1 -\n * @param str2 -\n */\nexport function iEqual(str1: string, str2: string): boolean {\n  return str1.toLocaleLowerCase() === str2.toLocaleLowerCase();\n}\n\n/**\n * Extracts account name from the url\n * @param url - url to extract the account name from\n * @returns with the account name\n */\nexport function getAccountNameFromUrl(url: string): string {\n  const parsedUrl: URLBuilder = URLBuilder.parse(url);\n  let accountName;\n  try {\n    if (parsedUrl.getHost()!.split(\".\")[1] === \"blob\") {\n      // `${defaultEndpointsProtocol}://${accountName}.blob.${endpointSuffix}`;\n      accountName = parsedUrl.getHost()!.split(\".\")[0];\n    } else if (isIpEndpointStyle(parsedUrl)) {\n      // IPv4/IPv6 address hosts... Example - http://192.0.0.10:10001/devstoreaccount1/\n      // Single word domain without a [dot] in the endpoint... Example - http://localhost:10001/devstoreaccount1/\n      // .getPath() -> /devstoreaccount1/\n      accountName = parsedUrl.getPath()!.split(\"/\")[1];\n    } else {\n      // Custom domain case: \"https://customdomain.com/containername/blob\".\n      accountName = \"\";\n    }\n    return accountName;\n  } catch (error: any) {\n    throw new Error(\"Unable to extract accountName with provided information.\");\n  }\n}\n\nexport function isIpEndpointStyle(parsedUrl: URLBuilder): boolean {\n  if (parsedUrl.getHost() === undefined) {\n    return false;\n  }\n\n  const host =\n    parsedUrl.getHost()! + (parsedUrl.getPort() === undefined ? \"\" : \":\" + parsedUrl.getPort());\n\n  // Case 1: Ipv6, use a broad regex to find out candidates whose host contains two ':'.\n  // Case 2: localhost(:port), use broad regex to match port part.\n  // Case 3: Ipv4, use broad regex which just check if host contains Ipv4.\n  // For valid host please refer to https://man7.org/linux/man-pages/man7/hostname.7.html.\n  return (\n    /^.*:.*:.*$|^localhost(:[0-9]+)?$|^(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])(\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])){3}(:[0-9]+)?$/.test(\n      host\n    ) ||\n    (parsedUrl.getPort() !== undefined && PathStylePorts.includes(parsedUrl.getPort()!))\n  );\n}\n\n/**\n * Convert Tags to encoded string.\n *\n * @param tags -\n */\nexport function toBlobTagsString(tags?: Tags): string | undefined {\n  if (tags === undefined) {\n    return undefined;\n  }\n\n  const tagPairs = [];\n  for (const key in tags) {\n    if (Object.prototype.hasOwnProperty.call(tags, key)) {\n      const value = tags[key];\n      tagPairs.push(`${encodeURIComponent(key)}=${encodeURIComponent(value)}`);\n    }\n  }\n\n  return tagPairs.join(\"&\");\n}\n\n/**\n * Convert Tags type to BlobTags.\n *\n * @param tags -\n */\nexport function toBlobTags(tags?: Tags): BlobTags | undefined {\n  if (tags === undefined) {\n    return undefined;\n  }\n\n  const res: BlobTags = {\n    blobTagSet: [],\n  };\n\n  for (const key in tags) {\n    if (Object.prototype.hasOwnProperty.call(tags, key)) {\n      const value = tags[key];\n      res.blobTagSet.push({\n        key,\n        value,\n      });\n    }\n  }\n  return res;\n}\n\n/**\n * Covert BlobTags to Tags type.\n *\n * @param tags -\n */\nexport function toTags(tags?: BlobTags): Tags | undefined {\n  if (tags === undefined) {\n    return undefined;\n  }\n\n  const res: Tags = {};\n  for (const blobTag of tags.blobTagSet) {\n    res[blobTag.key] = blobTag.value;\n  }\n  return res;\n}\n\n/**\n * Convert BlobQueryTextConfiguration to QuerySerialization type.\n *\n * @param textConfiguration -\n */\nexport function toQuerySerialization(\n  textConfiguration?:\n    | BlobQueryJsonTextConfiguration\n    | BlobQueryCsvTextConfiguration\n    | BlobQueryArrowConfiguration\n    | BlobQueryParquetConfiguration\n): QuerySerialization | undefined {\n  if (textConfiguration === undefined) {\n    return undefined;\n  }\n\n  switch (textConfiguration.kind) {\n    case \"csv\":\n      return {\n        format: {\n          type: \"delimited\",\n          delimitedTextConfiguration: {\n            columnSeparator: textConfiguration.columnSeparator || \",\",\n            fieldQuote: textConfiguration.fieldQuote || \"\",\n            recordSeparator: textConfiguration.recordSeparator,\n            escapeChar: textConfiguration.escapeCharacter || \"\",\n            headersPresent: textConfiguration.hasHeaders || false,\n          },\n        },\n      };\n    case \"json\":\n      return {\n        format: {\n          type: \"json\",\n          jsonTextConfiguration: {\n            recordSeparator: textConfiguration.recordSeparator,\n          },\n        },\n      };\n    case \"arrow\":\n      return {\n        format: {\n          type: \"arrow\",\n          arrowConfiguration: {\n            schema: textConfiguration.schema,\n          },\n        },\n      };\n    case \"parquet\":\n      return {\n        format: {\n          type: \"parquet\",\n        },\n      };\n\n    default:\n      throw Error(\"Invalid BlobQueryTextConfiguration.\");\n  }\n}\n\nexport function parseObjectReplicationRecord(\n  objectReplicationRecord?: Record<string, string>\n): ObjectReplicationPolicy[] | undefined {\n  if (!objectReplicationRecord) {\n    return undefined;\n  }\n\n  if (\"policy-id\" in objectReplicationRecord) {\n    // If the dictionary contains a key with policy id, we are not required to do any parsing since\n    // the policy id should already be stored in the ObjectReplicationDestinationPolicyId.\n    return undefined;\n  }\n\n  const orProperties: ObjectReplicationPolicy[] = [];\n  for (const key in objectReplicationRecord) {\n    const ids = key.split(\"_\");\n    const policyPrefix = \"or-\";\n    if (ids[0].startsWith(policyPrefix)) {\n      ids[0] = ids[0].substring(policyPrefix.length);\n    }\n    const rule: ObjectReplicationRule = {\n      ruleId: ids[1],\n      replicationStatus: objectReplicationRecord[key] as ObjectReplicationStatus,\n    };\n    const policyIndex = orProperties.findIndex((policy) => policy.policyId === ids[0]);\n    if (policyIndex > -1) {\n      orProperties[policyIndex].rules.push(rule);\n    } else {\n      orProperties.push({\n        policyId: ids[0],\n        rules: [rule],\n      });\n    }\n  }\n  return orProperties;\n}\n\n/**\n * Attach a TokenCredential to an object.\n *\n * @param thing -\n * @param credential -\n */\nexport function attachCredential<T>(thing: T, credential: TokenCredential): T {\n  (thing as any).credential = credential;\n  return thing;\n}\n\nexport function httpAuthorizationToString(\n  httpAuthorization?: HttpAuthorization\n): string | undefined {\n  return httpAuthorization ? httpAuthorization.scheme + \" \" + httpAuthorization.value : undefined;\n}\n\nexport function BlobNameToString(name: BlobName): string {\n  if (name.encoded) {\n    return decodeURIComponent(name.content!);\n  } else {\n    return name.content!;\n  }\n}\n\nexport function ConvertInternalResponseOfListBlobFlat(\n  internalResponse: ListBlobsFlatSegmentResponse\n): ListBlobsFlatSegmentResponseModel {\n  return {\n    ...internalResponse,\n    segment: {\n      blobItems: internalResponse.segment.blobItems.map((blobItemInteral) => {\n        const blobItem: BlobItemInternalModel = {\n          ...blobItemInteral,\n          name: BlobNameToString(blobItemInteral.name),\n        };\n        return blobItem;\n      }),\n    },\n  };\n}\n\nexport function ConvertInternalResponseOfListBlobHierarchy(\n  internalResponse: ListBlobsHierarchySegmentResponse\n): ListBlobsHierarchySegmentResponseModel {\n  return {\n    ...internalResponse,\n    segment: {\n      blobPrefixes: internalResponse.segment.blobPrefixes?.map((blobPrefixInternal) => {\n        const blobPrefix: BlobPrefixModel = {\n          name: BlobNameToString(blobPrefixInternal.name),\n        };\n        return blobPrefix;\n      }),\n      blobItems: internalResponse.segment.blobItems.map((blobItemInteral) => {\n        const blobItem: BlobItemInternalModel = {\n          ...blobItemInteral,\n          name: BlobNameToString(blobItemInteral.name),\n        };\n        return blobItem;\n      }),\n    },\n  };\n}\n\nfunction decodeBase64String(value: string): Uint8Array {\n  if (isNode) {\n    return Buffer.from(value, \"base64\");\n  } else {\n    const byteString = atob(value);\n    const arr = new Uint8Array(byteString.length);\n    for (let i = 0; i < byteString.length; i++) {\n      arr[i] = byteString.charCodeAt(i);\n    }\n    return arr;\n  }\n}\n\nfunction ParseBoolean(content: any) {\n  if (content === undefined) return undefined;\n  if (content === \"true\") return true;\n  if (content === \"false\") return false;\n  return undefined;\n}\n\nfunction ParseBlobName(blobNameInXML: any): BlobName {\n  if (blobNameInXML[\"$\"] !== undefined && blobNameInXML[\"#\"] !== undefined) {\n    return {\n      encoded: ParseBoolean(blobNameInXML[\"$\"][\"Encoded\"]),\n      content: blobNameInXML[\"#\"] as string,\n    };\n  } else {\n    return {\n      encoded: false,\n      content: blobNameInXML as string,\n    };\n  }\n}\n\nfunction ParseBlobProperties(blobPropertiesInXML: any): BlobPropertiesInternal {\n  const blobProperties = blobPropertiesInXML;\n  if (blobPropertiesInXML[\"Creation-Time\"]) {\n    blobProperties.createdOn = new Date(blobPropertiesInXML[\"Creation-Time\"] as string);\n    delete blobProperties[\"Creation-Time\"];\n  }\n\n  if (blobPropertiesInXML[\"Last-Modified\"]) {\n    blobProperties.lastModified = new Date(blobPropertiesInXML[\"Last-Modified\"] as string);\n    delete blobProperties[\"Last-Modified\"];\n  }\n\n  if (blobPropertiesInXML[\"Etag\"]) {\n    blobProperties.etag = blobPropertiesInXML[\"Etag\"] as string;\n    delete blobProperties[\"Etag\"];\n  }\n\n  if (blobPropertiesInXML[\"Content-Length\"]) {\n    blobProperties.contentLength = parseFloat(blobPropertiesInXML[\"Content-Length\"] as string);\n    delete blobProperties[\"Content-Length\"];\n  }\n\n  if (blobPropertiesInXML[\"Content-Type\"]) {\n    blobProperties.contentType = blobPropertiesInXML[\"Content-Type\"] as string;\n    delete blobProperties[\"Content-Type\"];\n  }\n\n  if (blobPropertiesInXML[\"Content-Encoding\"]) {\n    blobProperties.contentEncoding = blobPropertiesInXML[\"Content-Encoding\"] as string;\n    delete blobProperties[\"Content-Encoding\"];\n  }\n\n  if (blobPropertiesInXML[\"Content-Language\"]) {\n    blobProperties.contentLanguage = blobPropertiesInXML[\"Content-Language\"] as string;\n    delete blobProperties[\"Content-Language\"];\n  }\n\n  if (blobPropertiesInXML[\"Content-MD5\"]) {\n    blobProperties.contentMD5 = decodeBase64String(blobPropertiesInXML[\"Content-MD5\"] as string);\n    delete blobProperties[\"Content-MD5\"];\n  }\n\n  if (blobPropertiesInXML[\"Content-Disposition\"]) {\n    blobProperties.contentDisposition = blobPropertiesInXML[\"Content-Disposition\"] as string;\n    delete blobProperties[\"Content-Disposition\"];\n  }\n\n  if (blobPropertiesInXML[\"Cache-Control\"]) {\n    blobProperties.cacheControl = blobPropertiesInXML[\"Cache-Control\"] as string;\n    delete blobProperties[\"Cache-Control\"];\n  }\n\n  if (blobPropertiesInXML[\"x-ms-blob-sequence-number\"]) {\n    blobProperties.blobSequenceNumber = parseFloat(\n      blobPropertiesInXML[\"x-ms-blob-sequence-number\"] as string\n    );\n    delete blobProperties[\"x-ms-blob-sequence-number\"];\n  }\n\n  if (blobPropertiesInXML[\"BlobType\"]) {\n    blobProperties.blobType = blobPropertiesInXML[\"BlobType\"] as BlobType;\n    delete blobProperties[\"BlobType\"];\n  }\n\n  if (blobPropertiesInXML[\"LeaseStatus\"]) {\n    blobProperties.leaseStatus = blobPropertiesInXML[\"LeaseStatus\"] as LeaseStatusType;\n    delete blobProperties[\"LeaseStatus\"];\n  }\n\n  if (blobPropertiesInXML[\"LeaseState\"]) {\n    blobProperties.leaseState = blobPropertiesInXML[\"LeaseState\"] as LeaseStateType;\n    delete blobProperties[\"LeaseState\"];\n  }\n\n  if (blobPropertiesInXML[\"LeaseDuration\"]) {\n    blobProperties.leaseDuration = blobPropertiesInXML[\"LeaseDuration\"] as LeaseDurationType;\n    delete blobProperties[\"LeaseDuration\"];\n  }\n\n  if (blobPropertiesInXML[\"CopyId\"]) {\n    blobProperties.copyId = blobPropertiesInXML[\"CopyId\"] as string;\n    delete blobProperties[\"CopyId\"];\n  }\n\n  if (blobPropertiesInXML[\"CopyStatus\"]) {\n    blobProperties.copyStatus = blobPropertiesInXML[\"CopyStatus\"] as CopyStatusType;\n    delete blobProperties[\"CopyStatus\"];\n  }\n\n  if (blobPropertiesInXML[\"CopySource\"]) {\n    blobProperties.copySource = blobPropertiesInXML[\"CopySource\"] as string;\n    delete blobProperties[\"CopySource\"];\n  }\n\n  if (blobPropertiesInXML[\"CopyProgress\"]) {\n    blobProperties.copyProgress = blobPropertiesInXML[\"CopyProgress\"] as string;\n    delete blobProperties[\"CopyProgress\"];\n  }\n\n  if (blobPropertiesInXML[\"CopyCompletionTime\"]) {\n    blobProperties.copyCompletedOn = new Date(blobPropertiesInXML[\"CopyCompletionTime\"] as string);\n    delete blobProperties[\"CopyCompletionTime\"];\n  }\n\n  if (blobPropertiesInXML[\"CopyStatusDescription\"]) {\n    blobProperties.copyStatusDescription = blobPropertiesInXML[\"CopyStatusDescription\"] as string;\n    delete blobProperties[\"CopyStatusDescription\"];\n  }\n\n  if (blobPropertiesInXML[\"ServerEncrypted\"]) {\n    blobProperties.serverEncrypted = ParseBoolean(blobPropertiesInXML[\"ServerEncrypted\"]);\n    delete blobProperties[\"ServerEncrypted\"];\n  }\n\n  if (blobPropertiesInXML[\"IncrementalCopy\"]) {\n    blobProperties.incrementalCopy = ParseBoolean(blobPropertiesInXML[\"IncrementalCopy\"]);\n    delete blobProperties[\"IncrementalCopy\"];\n  }\n\n  if (blobPropertiesInXML[\"DestinationSnapshot\"]) {\n    blobProperties.destinationSnapshot = blobPropertiesInXML[\"DestinationSnapshot\"] as string;\n    delete blobProperties[\"DestinationSnapshot\"];\n  }\n\n  if (blobPropertiesInXML[\"DeletedTime\"]) {\n    blobProperties.deletedOn = new Date(blobPropertiesInXML[\"DeletedTime\"] as string);\n    delete blobProperties[\"DeletedTime\"];\n  }\n\n  if (blobPropertiesInXML[\"RemainingRetentionDays\"]) {\n    blobProperties.remainingRetentionDays = parseFloat(\n      blobPropertiesInXML[\"RemainingRetentionDays\"] as string\n    );\n    delete blobProperties[\"RemainingRetentionDays\"];\n  }\n\n  if (blobPropertiesInXML[\"AccessTier\"]) {\n    blobProperties.accessTier = blobPropertiesInXML[\"AccessTier\"] as AccessTier;\n    delete blobProperties[\"AccessTier\"];\n  }\n\n  if (blobPropertiesInXML[\"AccessTierInferred\"]) {\n    blobProperties.accessTierInferred = ParseBoolean(blobPropertiesInXML[\"AccessTierInferred\"]);\n    delete blobProperties[\"AccessTierInferred\"];\n  }\n\n  if (blobPropertiesInXML[\"ArchiveStatus\"]) {\n    blobProperties.archiveStatus = blobPropertiesInXML[\"ArchiveStatus\"] as ArchiveStatus;\n    delete blobProperties[\"ArchiveStatus\"];\n  }\n\n  if (blobPropertiesInXML[\"CustomerProvidedKeySha256\"]) {\n    blobProperties.customerProvidedKeySha256 = blobPropertiesInXML[\n      \"CustomerProvidedKeySha256\"\n    ] as string;\n    delete blobProperties[\"CustomerProvidedKeySha256\"];\n  }\n\n  if (blobPropertiesInXML[\"EncryptionScope\"]) {\n    blobProperties.encryptionScope = blobPropertiesInXML[\"EncryptionScope\"] as string;\n    delete blobProperties[\"EncryptionScope\"];\n  }\n\n  if (blobPropertiesInXML[\"AccessTierChangeTime\"]) {\n    blobProperties.accessTierChangedOn = new Date(\n      blobPropertiesInXML[\"AccessTierChangeTime\"] as string\n    );\n    delete blobProperties[\"AccessTierChangeTime\"];\n  }\n\n  if (blobPropertiesInXML[\"TagCount\"]) {\n    blobProperties.tagCount = parseFloat(blobPropertiesInXML[\"TagCount\"] as string);\n    delete blobProperties[\"TagCount\"];\n  }\n\n  if (blobPropertiesInXML[\"Expiry-Time\"]) {\n    blobProperties.expiresOn = new Date(blobPropertiesInXML[\"Expiry-Time\"] as string);\n    delete blobProperties[\"Expiry-Time\"];\n  }\n\n  if (blobPropertiesInXML[\"Sealed\"]) {\n    blobProperties.isSealed = ParseBoolean(blobPropertiesInXML[\"Sealed\"]);\n    delete blobProperties[\"Sealed\"];\n  }\n\n  if (blobPropertiesInXML[\"RehydratePriority\"]) {\n    blobProperties.rehydratePriority = blobPropertiesInXML[\n      \"RehydratePriority\"\n    ] as RehydratePriority;\n    delete blobProperties[\"RehydratePriority\"];\n  }\n\n  if (blobPropertiesInXML[\"LastAccessTime\"]) {\n    blobProperties.lastAccessedOn = new Date(blobPropertiesInXML[\"LastAccessTime\"] as string);\n    delete blobProperties[\"LastAccessTime\"];\n  }\n\n  if (blobPropertiesInXML[\"ImmutabilityPolicyUntilDate\"]) {\n    blobProperties.immutabilityPolicyExpiresOn = new Date(\n      blobPropertiesInXML[\"ImmutabilityPolicyUntilDate\"] as string\n    );\n    delete blobProperties[\"ImmutabilityPolicyUntilDate\"];\n  }\n\n  if (blobPropertiesInXML[\"ImmutabilityPolicyMode\"]) {\n    blobProperties.immutabilityPolicyMode = blobPropertiesInXML[\n      \"ImmutabilityPolicyMode\"\n    ] as BlobImmutabilityPolicyMode;\n    delete blobProperties[\"ImmutabilityPolicyMode\"];\n  }\n\n  if (blobPropertiesInXML[\"LegalHold\"]) {\n    blobProperties.legalHold = ParseBoolean(blobPropertiesInXML[\"LegalHold\"]);\n    delete blobProperties[\"LegalHold\"];\n  }\n\n  return blobProperties;\n}\n\nfunction ParseBlobItem(blobInXML: any): BlobItemInternal {\n  const blobItem = blobInXML;\n  blobItem.properties = ParseBlobProperties(blobInXML[\"Properties\"]);\n  delete blobItem[\"Properties\"];\n\n  blobItem.name = ParseBlobName(blobInXML[\"Name\"]);\n  delete blobItem[\"Name\"];\n  blobItem.deleted = ParseBoolean(blobInXML[\"Deleted\"])!;\n  delete blobItem[\"Deleted\"];\n\n  if (blobInXML[\"Snapshot\"]) {\n    blobItem.snapshot = blobInXML[\"Snapshot\"] as string;\n    delete blobItem[\"Snapshot\"];\n  }\n\n  if (blobInXML[\"VersionId\"]) {\n    blobItem.versionId = blobInXML[\"VersionId\"] as string;\n    delete blobItem[\"VersionId\"];\n  }\n\n  if (blobInXML[\"IsCurrentVersion\"]) {\n    blobItem.isCurrentVersion = ParseBoolean(blobInXML[\"IsCurrentVersion\"]);\n    delete blobItem[\"IsCurrentVersion\"];\n  }\n\n  if (blobInXML[\"Metadata\"]) {\n    blobItem.metadata = blobInXML[\"Metadata\"];\n    delete blobItem[\"Metadata\"];\n  }\n\n  if (blobInXML[\"Tags\"]) {\n    blobItem.blobTags = ParseBlobTags(blobInXML[\"Tags\"]);\n    delete blobItem[\"Tags\"];\n  }\n\n  if (blobInXML[\"OrMetadata\"]) {\n    blobItem.objectReplicationMetadata = blobInXML[\"OrMetadata\"];\n    delete blobItem[\"OrMetadata\"];\n  }\n\n  if (blobInXML[\"HasVersionsOnly\"]) {\n    blobItem.hasVersionsOnly = ParseBoolean(blobInXML[\"HasVersionsOnly\"]);\n    delete blobItem[\"HasVersionsOnly\"];\n  }\n  return blobItem;\n}\n\nfunction ParseBlobPrefix(blobPrefixInXML: any): BlobPrefix {\n  return {\n    name: ParseBlobName(blobPrefixInXML[\"Name\"]),\n  };\n}\n\nfunction ParseBlobTag(blobTagInXML: any): BlobTag {\n  return {\n    key: blobTagInXML[\"Key\"],\n    value: blobTagInXML[\"Value\"],\n  };\n}\n\nfunction ParseBlobTags(blobTagsInXML: any): BlobTags | undefined {\n  if (\n    blobTagsInXML === undefined ||\n    blobTagsInXML[\"TagSet\"] === undefined ||\n    blobTagsInXML[\"TagSet\"][\"Tag\"] === undefined\n  ) {\n    return undefined;\n  }\n\n  const blobTagSet = [];\n  if (blobTagsInXML[\"TagSet\"][\"Tag\"] instanceof Array) {\n    blobTagsInXML[\"TagSet\"][\"Tag\"].forEach((blobTagInXML: any) => {\n      blobTagSet.push(ParseBlobTag(blobTagInXML));\n    });\n  } else {\n    blobTagSet.push(ParseBlobTag(blobTagsInXML[\"TagSet\"][\"Tag\"]));\n  }\n\n  return { blobTagSet: blobTagSet };\n}\n\nexport function ProcessBlobItems(blobArrayInXML: any[]): BlobItemInternal[] {\n  const blobItems = [];\n\n  if (blobArrayInXML instanceof Array) {\n    blobArrayInXML.forEach((blobInXML: any) => {\n      blobItems.push(ParseBlobItem(blobInXML));\n    });\n  } else {\n    blobItems.push(ParseBlobItem(blobArrayInXML));\n  }\n\n  return blobItems;\n}\n\nexport function ProcessBlobPrefixes(blobPrefixesInXML: any[]): BlobPrefix[] {\n  const blobPrefixes = [];\n\n  if (blobPrefixesInXML instanceof Array) {\n    blobPrefixesInXML.forEach((blobPrefixInXML: any) => {\n      blobPrefixes.push(ParseBlobPrefix(blobPrefixInXML));\n    });\n  } else {\n    blobPrefixes.push(ParseBlobPrefix(blobPrefixesInXML));\n  }\n\n  return blobPrefixes;\n}\n\nexport function* ExtractPageRangeInfoItems(\n  getPageRangesSegment: PageBlobGetPageRangesDiffResponseModel\n): IterableIterator<PageRangeInfo> {\n  let pageRange: PageRange[] = [];\n  let clearRange: ClearRange[] = [];\n\n  if (getPageRangesSegment.pageRange) pageRange = getPageRangesSegment.pageRange;\n  if (getPageRangesSegment.clearRange) clearRange = getPageRangesSegment.clearRange;\n\n  let pageRangeIndex = 0;\n  let clearRangeIndex = 0;\n\n  while (pageRangeIndex < pageRange.length && clearRangeIndex < clearRange.length) {\n    if (pageRange[pageRangeIndex].start < clearRange[clearRangeIndex].start) {\n      yield {\n        start: pageRange[pageRangeIndex].start,\n        end: pageRange[pageRangeIndex].end,\n        isClear: false,\n      };\n      ++pageRangeIndex;\n    } else {\n      yield {\n        start: clearRange[clearRangeIndex].start,\n        end: clearRange[clearRangeIndex].end,\n        isClear: true,\n      };\n      ++clearRangeIndex;\n    }\n  }\n\n  for (; pageRangeIndex < pageRange.length; ++pageRangeIndex) {\n    yield {\n      start: pageRange[pageRangeIndex].start,\n      end: pageRange[pageRangeIndex].end,\n      isClear: false,\n    };\n  }\n\n  for (; clearRangeIndex < clearRange.length; ++clearRangeIndex) {\n    yield {\n      start: clearRange[clearRangeIndex].start,\n      end: clearRange[clearRangeIndex].end,\n      isClear: true,\n    };\n  }\n}\n\n/**\n * Escape the blobName but keep path separator ('/').\n */\nexport function EscapePath(blobName: string): string {\n  const split = blobName.split(\"/\");\n  for (let i = 0; i < split.length; i++) {\n    split[i] = encodeURIComponent(split[i]);\n  }\n  return split.join(\"/\");\n}\n"]},"metadata":{},"sourceType":"module"}