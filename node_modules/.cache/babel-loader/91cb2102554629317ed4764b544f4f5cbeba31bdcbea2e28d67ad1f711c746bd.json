{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport * as utils from \"./util/utils\";\nimport { MapperType } from \"./serializer\";\nimport { DefaultDeserializationOptions, deserializationPolicy } from \"./policies/deserializationPolicy\";\nimport { DefaultKeepAliveOptions, keepAlivePolicy } from \"./policies/keepAlivePolicy\";\nimport { DefaultRedirectOptions, redirectPolicy } from \"./policies/redirectPolicy\";\nimport { DefaultRetryOptions, exponentialRetryPolicy } from \"./policies/exponentialRetryPolicy\";\nimport { logPolicy } from \"./policies/logPolicy\";\nimport { getPathStringFromParameter, getPathStringFromParameterPath } from \"./operationParameter\";\nimport { getStreamResponseStatusCodes } from \"./operationSpec\";\nimport { WebResource, isWebResourceLike } from \"./webResource\";\nimport { RequestPolicyOptions } from \"./policies/requestPolicy\";\nimport { XML_ATTRKEY, XML_CHARKEY } from \"./util/serializer.common\";\nimport { isNode } from \"./util/utils\";\nimport { isTokenCredential } from \"@azure/core-auth\";\nimport { getDefaultUserAgentHeaderName, getDefaultUserAgentValue, userAgentPolicy } from \"./policies/userAgentPolicy\";\nimport { QueryCollectionFormat } from \"./queryCollectionFormat\";\nimport { URLBuilder } from \"./url\";\nimport { bearerTokenAuthenticationPolicy } from \"./policies/bearerTokenAuthenticationPolicy\";\nimport { disableResponseDecompressionPolicy } from \"./policies/disableResponseDecompressionPolicy\";\nimport { generateClientRequestIdPolicy } from \"./policies/generateClientRequestIdPolicy\";\nimport { getCachedDefaultHttpClient } from \"./httpClientCache\";\nimport { logger } from \"./log\";\nimport { ndJsonPolicy } from \"./policies/ndJsonPolicy\";\nimport { proxyPolicy } from \"./policies/proxyPolicy\";\nimport { rpRegistrationPolicy } from \"./policies/rpRegistrationPolicy\";\nimport { signingPolicy } from \"./policies/signingPolicy\";\nimport { stringifyXML } from \"./util/xml\";\nimport { systemErrorRetryPolicy } from \"./policies/systemErrorRetryPolicy\";\nimport { throttlingRetryPolicy } from \"./policies/throttlingRetryPolicy\";\nimport { tracingPolicy } from \"./policies/tracingPolicy\";\n/**\n * ServiceClient sends service requests and receives responses.\n */\nexport class ServiceClient {\n  /**\n   * The ServiceClient constructor\n   * @param credentials - The credentials used for authentication with the service.\n   * @param options - The service client options that govern the behavior of the client.\n   */\n  constructor(credentials, /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options */\n  options) {\n    if (!options) {\n      options = {};\n    }\n    this._withCredentials = options.withCredentials || false;\n    this._httpClient = options.httpClient || getCachedDefaultHttpClient();\n    this._requestPolicyOptions = new RequestPolicyOptions(options.httpPipelineLogger);\n    let requestPolicyFactories;\n    if (Array.isArray(options.requestPolicyFactories)) {\n      logger.info(\"ServiceClient: using custom request policies\");\n      requestPolicyFactories = options.requestPolicyFactories;\n    } else {\n      let authPolicyFactory = undefined;\n      if (isTokenCredential(credentials)) {\n        logger.info(\"ServiceClient: creating bearer token authentication policy from provided credentials\");\n        // Create a wrapped RequestPolicyFactory here so that we can provide the\n        // correct scope to the BearerTokenAuthenticationPolicy at the first time\n        // one is requested.  This is needed because generated ServiceClient\n        // implementations do not set baseUri until after ServiceClient's constructor\n        // is finished, leaving baseUri empty at the time when it is needed to\n        // build the correct scope name.\n        const wrappedPolicyFactory = () => {\n          let bearerTokenPolicyFactory = undefined;\n          // eslint-disable-next-line @typescript-eslint/no-this-alias\n          const serviceClient = this;\n          const serviceClientOptions = options;\n          return {\n            create(nextPolicy, createOptions) {\n              const credentialScopes = getCredentialScopes(serviceClientOptions, serviceClient.baseUri);\n              if (!credentialScopes) {\n                throw new Error(`When using credential, the ServiceClient must contain a baseUri or a credentialScopes in ServiceClientOptions. Unable to create a bearerTokenAuthenticationPolicy`);\n              }\n              if (bearerTokenPolicyFactory === undefined || bearerTokenPolicyFactory === null) {\n                bearerTokenPolicyFactory = bearerTokenAuthenticationPolicy(credentials, credentialScopes);\n              }\n              return bearerTokenPolicyFactory.create(nextPolicy, createOptions);\n            }\n          };\n        };\n        authPolicyFactory = wrappedPolicyFactory();\n      } else if (credentials && typeof credentials.signRequest === \"function\") {\n        logger.info(\"ServiceClient: creating signing policy from provided credentials\");\n        authPolicyFactory = signingPolicy(credentials);\n      } else if (credentials !== undefined && credentials !== null) {\n        throw new Error(\"The credentials argument must implement the TokenCredential interface\");\n      }\n      logger.info(\"ServiceClient: using default request policies\");\n      requestPolicyFactories = createDefaultRequestPolicyFactories(authPolicyFactory, options);\n      if (options.requestPolicyFactories) {\n        // options.requestPolicyFactories can also be a function that manipulates\n        // the default requestPolicyFactories array\n        const newRequestPolicyFactories = options.requestPolicyFactories(requestPolicyFactories);\n        if (newRequestPolicyFactories) {\n          requestPolicyFactories = newRequestPolicyFactories;\n        }\n      }\n    }\n    this._requestPolicyFactories = requestPolicyFactories;\n  }\n  /**\n   * Send the provided httpRequest.\n   */\n  sendRequest(options) {\n    if (options === null || options === undefined || typeof options !== \"object\") {\n      throw new Error(\"options cannot be null or undefined and it must be of type object.\");\n    }\n    let httpRequest;\n    try {\n      if (isWebResourceLike(options)) {\n        options.validateRequestProperties();\n        httpRequest = options;\n      } else {\n        httpRequest = new WebResource();\n        httpRequest = httpRequest.prepare(options);\n      }\n    } catch (error) {\n      return Promise.reject(error);\n    }\n    let httpPipeline = this._httpClient;\n    if (this._requestPolicyFactories && this._requestPolicyFactories.length > 0) {\n      for (let i = this._requestPolicyFactories.length - 1; i >= 0; --i) {\n        httpPipeline = this._requestPolicyFactories[i].create(httpPipeline, this._requestPolicyOptions);\n      }\n    }\n    return httpPipeline.sendRequest(httpRequest);\n  }\n  /**\n   * Send an HTTP request that is populated using the provided OperationSpec.\n   * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.\n   * @param operationSpec - The OperationSpec to use to populate the httpRequest.\n   * @param callback - The callback to call when the response is received.\n   */\n  async sendOperationRequest(operationArguments, operationSpec, callback) {\n    var _a;\n    if (typeof operationArguments.options === \"function\") {\n      callback = operationArguments.options;\n      operationArguments.options = undefined;\n    }\n    const serializerOptions = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions;\n    const httpRequest = new WebResource();\n    let result;\n    try {\n      const baseUri = operationSpec.baseUrl || this.baseUri;\n      if (!baseUri) {\n        throw new Error(\"If operationSpec.baseUrl is not specified, then the ServiceClient must have a baseUri string property that contains the base URL to use.\");\n      }\n      httpRequest.method = operationSpec.httpMethod;\n      httpRequest.operationSpec = operationSpec;\n      const requestUrl = URLBuilder.parse(baseUri);\n      if (operationSpec.path) {\n        requestUrl.appendPath(operationSpec.path);\n      }\n      if (operationSpec.urlParameters && operationSpec.urlParameters.length > 0) {\n        for (const urlParameter of operationSpec.urlParameters) {\n          let urlParameterValue = getOperationArgumentValueFromParameter(this, operationArguments, urlParameter, operationSpec.serializer);\n          urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, getPathStringFromParameter(urlParameter), serializerOptions);\n          if (!urlParameter.skipEncoding) {\n            urlParameterValue = encodeURIComponent(urlParameterValue);\n          }\n          requestUrl.replaceAll(`{${urlParameter.mapper.serializedName || getPathStringFromParameter(urlParameter)}}`, urlParameterValue);\n        }\n      }\n      if (operationSpec.queryParameters && operationSpec.queryParameters.length > 0) {\n        for (const queryParameter of operationSpec.queryParameters) {\n          let queryParameterValue = getOperationArgumentValueFromParameter(this, operationArguments, queryParameter, operationSpec.serializer);\n          if (queryParameterValue !== undefined && queryParameterValue !== null) {\n            queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, getPathStringFromParameter(queryParameter), serializerOptions);\n            if (queryParameter.collectionFormat !== undefined && queryParameter.collectionFormat !== null) {\n              if (queryParameter.collectionFormat === QueryCollectionFormat.Multi) {\n                if (queryParameterValue.length === 0) {\n                  // The collection is empty, no need to try serializing the current queryParam\n                  continue;\n                } else {\n                  for (const index in queryParameterValue) {\n                    const item = queryParameterValue[index];\n                    queryParameterValue[index] = item === undefined || item === null ? \"\" : item.toString();\n                  }\n                }\n              } else if (queryParameter.collectionFormat === QueryCollectionFormat.Ssv || queryParameter.collectionFormat === QueryCollectionFormat.Tsv) {\n                queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);\n              }\n            }\n            if (!queryParameter.skipEncoding) {\n              if (Array.isArray(queryParameterValue)) {\n                for (const index in queryParameterValue) {\n                  if (queryParameterValue[index] !== undefined && queryParameterValue[index] !== null) {\n                    queryParameterValue[index] = encodeURIComponent(queryParameterValue[index]);\n                  }\n                }\n              } else {\n                queryParameterValue = encodeURIComponent(queryParameterValue);\n              }\n            }\n            if (queryParameter.collectionFormat !== undefined && queryParameter.collectionFormat !== null && queryParameter.collectionFormat !== QueryCollectionFormat.Multi && queryParameter.collectionFormat !== QueryCollectionFormat.Ssv && queryParameter.collectionFormat !== QueryCollectionFormat.Tsv) {\n              queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);\n            }\n            requestUrl.setQueryParameter(queryParameter.mapper.serializedName || getPathStringFromParameter(queryParameter), queryParameterValue);\n          }\n        }\n      }\n      httpRequest.url = requestUrl.toString();\n      const contentType = operationSpec.contentType || this.requestContentType;\n      if (contentType && operationSpec.requestBody) {\n        httpRequest.headers.set(\"Content-Type\", contentType);\n      }\n      if (operationSpec.headerParameters) {\n        for (const headerParameter of operationSpec.headerParameters) {\n          let headerValue = getOperationArgumentValueFromParameter(this, operationArguments, headerParameter, operationSpec.serializer);\n          if (headerValue !== undefined && headerValue !== null) {\n            headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, getPathStringFromParameter(headerParameter), serializerOptions);\n            const headerCollectionPrefix = headerParameter.mapper.headerCollectionPrefix;\n            if (headerCollectionPrefix) {\n              for (const key of Object.keys(headerValue)) {\n                httpRequest.headers.set(headerCollectionPrefix + key, headerValue[key]);\n              }\n            } else {\n              httpRequest.headers.set(headerParameter.mapper.serializedName || getPathStringFromParameter(headerParameter), headerValue);\n            }\n          }\n        }\n      }\n      const options = operationArguments.options;\n      if (options) {\n        if (options.customHeaders) {\n          for (const customHeaderName in options.customHeaders) {\n            httpRequest.headers.set(customHeaderName, options.customHeaders[customHeaderName]);\n          }\n        }\n        if (options.abortSignal) {\n          httpRequest.abortSignal = options.abortSignal;\n        }\n        if (options.timeout) {\n          httpRequest.timeout = options.timeout;\n        }\n        if (options.onUploadProgress) {\n          httpRequest.onUploadProgress = options.onUploadProgress;\n        }\n        if (options.onDownloadProgress) {\n          httpRequest.onDownloadProgress = options.onDownloadProgress;\n        }\n        if (options.spanOptions) {\n          // By passing spanOptions if they exist at runtime, we're backwards compatible with @azure/core-tracing@preview.13 and earlier.\n          httpRequest.spanOptions = options.spanOptions;\n        }\n        if (options.tracingContext) {\n          httpRequest.tracingContext = options.tracingContext;\n        }\n        if (options.shouldDeserialize !== undefined && options.shouldDeserialize !== null) {\n          httpRequest.shouldDeserialize = options.shouldDeserialize;\n        }\n      }\n      httpRequest.withCredentials = this._withCredentials;\n      serializeRequestBody(this, httpRequest, operationArguments, operationSpec);\n      if (httpRequest.streamResponseStatusCodes === undefined) {\n        httpRequest.streamResponseStatusCodes = getStreamResponseStatusCodes(operationSpec);\n      }\n      let rawResponse;\n      let sendRequestError;\n      try {\n        rawResponse = await this.sendRequest(httpRequest);\n      } catch (error) {\n        sendRequestError = error;\n      }\n      if (sendRequestError) {\n        if (sendRequestError.response) {\n          sendRequestError.details = flattenResponse(sendRequestError.response, operationSpec.responses[sendRequestError.statusCode] || operationSpec.responses[\"default\"]);\n        }\n        result = Promise.reject(sendRequestError);\n      } else {\n        result = Promise.resolve(flattenResponse(rawResponse, operationSpec.responses[rawResponse.status]));\n      }\n    } catch (error) {\n      result = Promise.reject(error);\n    }\n    const cb = callback;\n    if (cb) {\n      result.then(res => cb(null, res._response.parsedBody, res._response.request, res._response)).catch(err => cb(err));\n    }\n    return result;\n  }\n}\nexport function serializeRequestBody(serviceClient, httpRequest, operationArguments, operationSpec) {\n  var _a, _b, _c, _d, _e, _f;\n  const serializerOptions = (_b = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions) !== null && _b !== void 0 ? _b : {};\n  const updatedOptions = {\n    rootName: (_c = serializerOptions.rootName) !== null && _c !== void 0 ? _c : \"\",\n    includeRoot: (_d = serializerOptions.includeRoot) !== null && _d !== void 0 ? _d : false,\n    xmlCharKey: (_e = serializerOptions.xmlCharKey) !== null && _e !== void 0 ? _e : XML_CHARKEY\n  };\n  const xmlCharKey = serializerOptions.xmlCharKey;\n  if (operationSpec.requestBody && operationSpec.requestBody.mapper) {\n    httpRequest.body = getOperationArgumentValueFromParameter(serviceClient, operationArguments, operationSpec.requestBody, operationSpec.serializer);\n    const bodyMapper = operationSpec.requestBody.mapper;\n    const {\n      required,\n      xmlName,\n      xmlElementName,\n      serializedName,\n      xmlNamespace,\n      xmlNamespacePrefix\n    } = bodyMapper;\n    const typeName = bodyMapper.type.name;\n    try {\n      if (httpRequest.body !== undefined && httpRequest.body !== null || required) {\n        const requestBodyParameterPathString = getPathStringFromParameter(operationSpec.requestBody);\n        httpRequest.body = operationSpec.serializer.serialize(bodyMapper, httpRequest.body, requestBodyParameterPathString, updatedOptions);\n        const isStream = typeName === MapperType.Stream;\n        if (operationSpec.isXML) {\n          const xmlnsKey = xmlNamespacePrefix ? `xmlns:${xmlNamespacePrefix}` : \"xmlns\";\n          const value = getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, httpRequest.body, updatedOptions);\n          if (typeName === MapperType.Sequence) {\n            httpRequest.body = stringifyXML(utils.prepareXMLRootList(value, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), {\n              rootName: xmlName || serializedName,\n              xmlCharKey\n            });\n          } else if (!isStream) {\n            httpRequest.body = stringifyXML(value, {\n              rootName: xmlName || serializedName,\n              xmlCharKey\n            });\n          }\n        } else if (typeName === MapperType.String && (((_f = operationSpec.contentType) === null || _f === void 0 ? void 0 : _f.match(\"text/plain\")) || operationSpec.mediaType === \"text\")) {\n          // the String serializer has validated that request body is a string\n          // so just send the string.\n          return;\n        } else if (!isStream) {\n          httpRequest.body = JSON.stringify(httpRequest.body);\n        }\n      }\n    } catch (error) {\n      throw new Error(`Error \"${error.message}\" occurred in serializing the payload - ${JSON.stringify(serializedName, undefined, \"  \")}.`);\n    }\n  } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {\n    httpRequest.formData = {};\n    for (const formDataParameter of operationSpec.formDataParameters) {\n      const formDataParameterValue = getOperationArgumentValueFromParameter(serviceClient, operationArguments, formDataParameter, operationSpec.serializer);\n      if (formDataParameterValue !== undefined && formDataParameterValue !== null) {\n        const formDataParameterPropertyName = formDataParameter.mapper.serializedName || getPathStringFromParameter(formDataParameter);\n        httpRequest.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, getPathStringFromParameter(formDataParameter), updatedOptions);\n      }\n    }\n  }\n}\n/**\n * Adds an xml namespace to the xml serialized object if needed, otherwise it just returns the value itself\n */\nfunction getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, serializedValue, options) {\n  // Composite and Sequence schemas already got their root namespace set during serialization\n  // We just need to add xmlns to the other schema types\n  if (xmlNamespace && ![\"Composite\", \"Sequence\", \"Dictionary\"].includes(typeName)) {\n    const result = {};\n    result[options.xmlCharKey] = serializedValue;\n    result[XML_ATTRKEY] = {\n      [xmlnsKey]: xmlNamespace\n    };\n    return result;\n  }\n  return serializedValue;\n}\nfunction getValueOrFunctionResult(value, defaultValueCreator) {\n  let result;\n  if (typeof value === \"string\") {\n    result = value;\n  } else {\n    result = defaultValueCreator();\n    if (typeof value === \"function\") {\n      result = value(result);\n    }\n  }\n  return result;\n}\nfunction createDefaultRequestPolicyFactories(authPolicyFactory, options) {\n  const factories = [];\n  if (options.generateClientRequestIdHeader) {\n    factories.push(generateClientRequestIdPolicy(options.clientRequestIdHeaderName));\n  }\n  if (authPolicyFactory) {\n    factories.push(authPolicyFactory);\n  }\n  const userAgentHeaderName = getValueOrFunctionResult(options.userAgentHeaderName, getDefaultUserAgentHeaderName);\n  const userAgentHeaderValue = getValueOrFunctionResult(options.userAgent, getDefaultUserAgentValue);\n  if (userAgentHeaderName && userAgentHeaderValue) {\n    factories.push(userAgentPolicy({\n      key: userAgentHeaderName,\n      value: userAgentHeaderValue\n    }));\n  }\n  factories.push(redirectPolicy());\n  factories.push(rpRegistrationPolicy(options.rpRegistrationRetryTimeout));\n  if (!options.noRetryPolicy) {\n    factories.push(exponentialRetryPolicy());\n    factories.push(systemErrorRetryPolicy());\n    factories.push(throttlingRetryPolicy());\n  }\n  factories.push(deserializationPolicy(options.deserializationContentTypes));\n  if (isNode) {\n    factories.push(proxyPolicy(options.proxySettings));\n  }\n  factories.push(logPolicy({\n    logger: logger.info\n  }));\n  return factories;\n}\n/**\n * Creates an HTTP pipeline based on the given options.\n * @param pipelineOptions - Defines options that are used to configure policies in the HTTP pipeline for an SDK client.\n * @param authPolicyFactory - An optional authentication policy factory to use for signing requests.\n * @returns A set of options that can be passed to create a new {@link ServiceClient}.\n */\nexport function createPipelineFromOptions(pipelineOptions, authPolicyFactory) {\n  const requestPolicyFactories = [];\n  if (pipelineOptions.sendStreamingJson) {\n    requestPolicyFactories.push(ndJsonPolicy());\n  }\n  let userAgentValue = undefined;\n  if (pipelineOptions.userAgentOptions && pipelineOptions.userAgentOptions.userAgentPrefix) {\n    const userAgentInfo = [];\n    userAgentInfo.push(pipelineOptions.userAgentOptions.userAgentPrefix);\n    // Add the default user agent value if it isn't already specified\n    // by the userAgentPrefix option.\n    const defaultUserAgentInfo = getDefaultUserAgentValue();\n    if (userAgentInfo.indexOf(defaultUserAgentInfo) === -1) {\n      userAgentInfo.push(defaultUserAgentInfo);\n    }\n    userAgentValue = userAgentInfo.join(\" \");\n  }\n  const keepAliveOptions = Object.assign(Object.assign({}, DefaultKeepAliveOptions), pipelineOptions.keepAliveOptions);\n  const retryOptions = Object.assign(Object.assign({}, DefaultRetryOptions), pipelineOptions.retryOptions);\n  const redirectOptions = Object.assign(Object.assign({}, DefaultRedirectOptions), pipelineOptions.redirectOptions);\n  if (isNode) {\n    requestPolicyFactories.push(proxyPolicy(pipelineOptions.proxyOptions));\n  }\n  const deserializationOptions = Object.assign(Object.assign({}, DefaultDeserializationOptions), pipelineOptions.deserializationOptions);\n  const loggingOptions = Object.assign({}, pipelineOptions.loggingOptions);\n  requestPolicyFactories.push(tracingPolicy({\n    userAgent: userAgentValue\n  }), keepAlivePolicy(keepAliveOptions), userAgentPolicy({\n    value: userAgentValue\n  }), generateClientRequestIdPolicy(), deserializationPolicy(deserializationOptions.expectedContentTypes), throttlingRetryPolicy(), systemErrorRetryPolicy(), exponentialRetryPolicy(retryOptions.maxRetries, retryOptions.retryDelayInMs, retryOptions.maxRetryDelayInMs));\n  if (redirectOptions.handleRedirects) {\n    requestPolicyFactories.push(redirectPolicy(redirectOptions.maxRetries));\n  }\n  if (authPolicyFactory) {\n    requestPolicyFactories.push(authPolicyFactory);\n  }\n  requestPolicyFactories.push(logPolicy(loggingOptions));\n  if (isNode && pipelineOptions.decompressResponse === false) {\n    requestPolicyFactories.push(disableResponseDecompressionPolicy());\n  }\n  return {\n    httpClient: pipelineOptions.httpClient,\n    requestPolicyFactories\n  };\n}\n/**\n * Get the property parent for the property at the provided path when starting with the provided\n * parent object.\n */\nexport function getPropertyParent(parent, propertyPath) {\n  if (parent && propertyPath) {\n    const propertyPathLength = propertyPath.length;\n    for (let i = 0; i < propertyPathLength - 1; ++i) {\n      const propertyName = propertyPath[i];\n      if (!parent[propertyName]) {\n        parent[propertyName] = {};\n      }\n      parent = parent[propertyName];\n    }\n  }\n  return parent;\n}\nfunction getOperationArgumentValueFromParameter(serviceClient, operationArguments, parameter, serializer) {\n  return getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, parameter.parameterPath, parameter.mapper, serializer);\n}\nexport function getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, parameterPath, parameterMapper, serializer) {\n  var _a;\n  let value;\n  if (typeof parameterPath === \"string\") {\n    parameterPath = [parameterPath];\n  }\n  const serializerOptions = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions;\n  if (Array.isArray(parameterPath)) {\n    if (parameterPath.length > 0) {\n      if (parameterMapper.isConstant) {\n        value = parameterMapper.defaultValue;\n      } else {\n        let propertySearchResult = getPropertyFromParameterPath(operationArguments, parameterPath);\n        if (!propertySearchResult.propertyFound) {\n          propertySearchResult = getPropertyFromParameterPath(serviceClient, parameterPath);\n        }\n        let useDefaultValue = false;\n        if (!propertySearchResult.propertyFound) {\n          useDefaultValue = parameterMapper.required || parameterPath[0] === \"options\" && parameterPath.length === 2;\n        }\n        value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;\n      }\n      // Serialize just for validation purposes.\n      const parameterPathString = getPathStringFromParameterPath(parameterPath, parameterMapper);\n      serializer.serialize(parameterMapper, value, parameterPathString, serializerOptions);\n    }\n  } else {\n    if (parameterMapper.required) {\n      value = {};\n    }\n    for (const propertyName in parameterPath) {\n      const propertyMapper = parameterMapper.type.modelProperties[propertyName];\n      const propertyPath = parameterPath[propertyName];\n      const propertyValue = getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, propertyPath, propertyMapper, serializer);\n      // Serialize just for validation purposes.\n      const propertyPathString = getPathStringFromParameterPath(propertyPath, propertyMapper);\n      serializer.serialize(propertyMapper, propertyValue, propertyPathString, serializerOptions);\n      if (propertyValue !== undefined && propertyValue !== null) {\n        if (!value) {\n          value = {};\n        }\n        value[propertyName] = propertyValue;\n      }\n    }\n  }\n  return value;\n}\nfunction getPropertyFromParameterPath(parent, parameterPath) {\n  const result = {\n    propertyFound: false\n  };\n  let i = 0;\n  for (; i < parameterPath.length; ++i) {\n    const parameterPathPart = parameterPath[i];\n    // Make sure to check inherited properties too, so don't use hasOwnProperty().\n    if (parent !== undefined && parent !== null && parameterPathPart in parent) {\n      parent = parent[parameterPathPart];\n    } else {\n      break;\n    }\n  }\n  if (i === parameterPath.length) {\n    result.propertyValue = parent;\n    result.propertyFound = true;\n  }\n  return result;\n}\n/**\n * Parses an {@link HttpOperationResponse} into a normalized HTTP response object ({@link RestResponse}).\n * @param _response - Wrapper object for http response.\n * @param responseSpec - Mappers for how to parse the response properties.\n * @returns - A normalized response object.\n */\nexport function flattenResponse(_response, responseSpec) {\n  const parsedHeaders = _response.parsedHeaders;\n  const bodyMapper = responseSpec && responseSpec.bodyMapper;\n  const addOperationResponse = obj => {\n    return Object.defineProperty(obj, \"_response\", {\n      value: _response\n    });\n  };\n  if (bodyMapper) {\n    const typeName = bodyMapper.type.name;\n    if (typeName === \"Stream\") {\n      return addOperationResponse(Object.assign(Object.assign({}, parsedHeaders), {\n        blobBody: _response.blobBody,\n        readableStreamBody: _response.readableStreamBody\n      }));\n    }\n    const modelProperties = typeName === \"Composite\" && bodyMapper.type.modelProperties || {};\n    const isPageableResponse = Object.keys(modelProperties).some(k => modelProperties[k].serializedName === \"\");\n    if (typeName === \"Sequence\" || isPageableResponse) {\n      const arrayResponse = [...(_response.parsedBody || [])];\n      for (const key of Object.keys(modelProperties)) {\n        if (modelProperties[key].serializedName) {\n          arrayResponse[key] = _response.parsedBody[key];\n        }\n      }\n      if (parsedHeaders) {\n        for (const key of Object.keys(parsedHeaders)) {\n          arrayResponse[key] = parsedHeaders[key];\n        }\n      }\n      addOperationResponse(arrayResponse);\n      return arrayResponse;\n    }\n    if (typeName === \"Composite\" || typeName === \"Dictionary\") {\n      return addOperationResponse(Object.assign(Object.assign({}, parsedHeaders), _response.parsedBody));\n    }\n  }\n  if (bodyMapper || _response.request.method === \"HEAD\" || utils.isPrimitiveType(_response.parsedBody)) {\n    // primitive body types and HEAD booleans\n    return addOperationResponse(Object.assign(Object.assign({}, parsedHeaders), {\n      body: _response.parsedBody\n    }));\n  }\n  return addOperationResponse(Object.assign(Object.assign({}, parsedHeaders), _response.parsedBody));\n}\nfunction getCredentialScopes(options, baseUri) {\n  if (options === null || options === void 0 ? void 0 : options.credentialScopes) {\n    const scopes = options.credentialScopes;\n    return Array.isArray(scopes) ? scopes.map(scope => new URL(scope).toString()) : new URL(scopes).toString();\n  }\n  if (baseUri) {\n    return `${baseUri}/.default`;\n  }\n  return undefined;\n}","map":{"version":3,"mappings":"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","names":["utils","MapperType","DefaultDeserializationOptions","deserializationPolicy","DefaultKeepAliveOptions","keepAlivePolicy","DefaultRedirectOptions","redirectPolicy","DefaultRetryOptions","exponentialRetryPolicy","logPolicy","getPathStringFromParameter","getPathStringFromParameterPath","getStreamResponseStatusCodes","WebResource","isWebResourceLike","RequestPolicyOptions","XML_ATTRKEY","XML_CHARKEY","isNode","isTokenCredential","getDefaultUserAgentHeaderName","getDefaultUserAgentValue","userAgentPolicy","QueryCollectionFormat","URLBuilder","bearerTokenAuthenticationPolicy","disableResponseDecompressionPolicy","generateClientRequestIdPolicy","getCachedDefaultHttpClient","logger","ndJsonPolicy","proxyPolicy","rpRegistrationPolicy","signingPolicy","stringifyXML","systemErrorRetryPolicy","throttlingRetryPolicy","tracingPolicy","ServiceClient","constructor","credentials","options","_withCredentials","withCredentials","_httpClient","httpClient","_requestPolicyOptions","httpPipelineLogger","requestPolicyFactories","Array","isArray","info","authPolicyFactory","undefined","wrappedPolicyFactory","bearerTokenPolicyFactory","serviceClient","serviceClientOptions","create","nextPolicy","createOptions","credentialScopes","getCredentialScopes","baseUri","Error","signRequest","createDefaultRequestPolicyFactories","newRequestPolicyFactories","_requestPolicyFactories","sendRequest","httpRequest","validateRequestProperties","prepare","error","Promise","reject","httpPipeline","length","i","sendOperationRequest","operationArguments","operationSpec","callback","serializerOptions","result","baseUrl","method","httpMethod","requestUrl","parse","path","appendPath","urlParameters","urlParameter","urlParameterValue","getOperationArgumentValueFromParameter","serializer","serialize","mapper","skipEncoding","encodeURIComponent","replaceAll","serializedName","queryParameters","queryParameter","queryParameterValue","collectionFormat","Multi","index","item","toString","Ssv","Tsv","join","setQueryParameter","url","contentType","requestContentType","requestBody","headers","set","headerParameters","headerParameter","headerValue","headerCollectionPrefix","key","Object","keys","customHeaders","customHeaderName","abortSignal","timeout","onUploadProgress","onDownloadProgress","spanOptions","tracingContext","shouldDeserialize","serializeRequestBody","streamResponseStatusCodes","rawResponse","sendRequestError","response","details","flattenResponse","responses","statusCode","resolve","status","cb","then","res","_response","parsedBody","request","catch","err","updatedOptions","rootName","includeRoot","xmlCharKey","body","bodyMapper","required","xmlName","xmlElementName","xmlNamespace","xmlNamespacePrefix","typeName","type","name","requestBodyParameterPathString","isStream","Stream","isXML","xmlnsKey","value","getXmlValueWithNamespace","Sequence","prepareXMLRootList","String","match","mediaType","JSON","stringify","message","formDataParameters","formData","formDataParameter","formDataParameterValue","formDataParameterPropertyName","serializedValue","includes","getValueOrFunctionResult","defaultValueCreator","factories","generateClientRequestIdHeader","push","clientRequestIdHeaderName","userAgentHeaderName","userAgentHeaderValue","userAgent","rpRegistrationRetryTimeout","noRetryPolicy","deserializationContentTypes","proxySettings","createPipelineFromOptions","pipelineOptions","sendStreamingJson","userAgentValue","userAgentOptions","userAgentPrefix","userAgentInfo","defaultUserAgentInfo","indexOf","keepAliveOptions","retryOptions","redirectOptions","proxyOptions","deserializationOptions","loggingOptions","expectedContentTypes","maxRetries","retryDelayInMs","maxRetryDelayInMs","handleRedirects","decompressResponse","getPropertyParent","parent","propertyPath","propertyPathLength","propertyName","parameter","getOperationArgumentValueFromParameterPath","parameterPath","parameterMapper","isConstant","defaultValue","propertySearchResult","getPropertyFromParameterPath","propertyFound","useDefaultValue","propertyValue","parameterPathString","propertyMapper","modelProperties","propertyPathString","parameterPathPart","responseSpec","parsedHeaders","addOperationResponse","obj","defineProperty","blobBody","readableStreamBody","isPageableResponse","some","k","arrayResponse","isPrimitiveType","scopes","map","scope","URL"],"sources":["/Users/yupenglei/Documents/geo-react/node_modules/@azure/core-http/src/serviceClient.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport * as utils from \"./util/utils\";\nimport { CompositeMapper, DictionaryMapper, Mapper, MapperType, Serializer } from \"./serializer\";\nimport {\n  DefaultDeserializationOptions,\n  DeserializationContentTypes,\n  deserializationPolicy,\n} from \"./policies/deserializationPolicy\";\nimport { DefaultKeepAliveOptions, keepAlivePolicy } from \"./policies/keepAlivePolicy\";\nimport { DefaultRedirectOptions, redirectPolicy } from \"./policies/redirectPolicy\";\nimport { DefaultRetryOptions, exponentialRetryPolicy } from \"./policies/exponentialRetryPolicy\";\nimport { HttpOperationResponse, RestResponse } from \"./httpOperationResponse\";\nimport { LogPolicyOptions, logPolicy } from \"./policies/logPolicy\";\nimport {\n  OperationParameter,\n  ParameterPath,\n  getPathStringFromParameter,\n  getPathStringFromParameterPath,\n} from \"./operationParameter\";\nimport { OperationSpec, getStreamResponseStatusCodes } from \"./operationSpec\";\nimport {\n  RequestOptionsBase,\n  RequestPrepareOptions,\n  WebResource,\n  WebResourceLike,\n  isWebResourceLike,\n} from \"./webResource\";\nimport {\n  RequestPolicy,\n  RequestPolicyFactory,\n  RequestPolicyOptions,\n} from \"./policies/requestPolicy\";\nimport { SerializerOptions, XML_ATTRKEY, XML_CHARKEY } from \"./util/serializer.common\";\nimport { ServiceCallback, isNode } from \"./util/utils\";\nimport { TokenCredential, isTokenCredential } from \"@azure/core-auth\";\nimport {\n  getDefaultUserAgentHeaderName,\n  getDefaultUserAgentValue,\n  userAgentPolicy,\n} from \"./policies/userAgentPolicy\";\nimport { HttpClient } from \"./httpClient\";\nimport { HttpPipelineLogger } from \"./httpPipelineLogger\";\nimport { InternalPipelineOptions } from \"./pipelineOptions\";\nimport { OperationArguments } from \"./operationArguments\";\nimport { OperationResponse } from \"./operationResponse\";\nimport { QueryCollectionFormat } from \"./queryCollectionFormat\";\nimport { ServiceClientCredentials } from \"./credentials/serviceClientCredentials\";\nimport { URLBuilder } from \"./url\";\nimport { bearerTokenAuthenticationPolicy } from \"./policies/bearerTokenAuthenticationPolicy\";\nimport { disableResponseDecompressionPolicy } from \"./policies/disableResponseDecompressionPolicy\";\nimport { generateClientRequestIdPolicy } from \"./policies/generateClientRequestIdPolicy\";\nimport { getCachedDefaultHttpClient } from \"./httpClientCache\";\nimport { logger } from \"./log\";\nimport { ndJsonPolicy } from \"./policies/ndJsonPolicy\";\nimport { proxyPolicy } from \"./policies/proxyPolicy\";\nimport { rpRegistrationPolicy } from \"./policies/rpRegistrationPolicy\";\nimport { signingPolicy } from \"./policies/signingPolicy\";\nimport { stringifyXML } from \"./util/xml\";\nimport { systemErrorRetryPolicy } from \"./policies/systemErrorRetryPolicy\";\nimport { throttlingRetryPolicy } from \"./policies/throttlingRetryPolicy\";\nimport { tracingPolicy } from \"./policies/tracingPolicy\";\n\n/**\n * Options to configure a proxy for outgoing requests (Node.js only).\n */\nexport interface ProxySettings {\n  /**\n   * The proxy's host address.\n   */\n  host: string;\n\n  /**\n   * The proxy host's port.\n   */\n  port: number;\n\n  /**\n   * The user name to authenticate with the proxy, if required.\n   */\n  username?: string;\n\n  /**\n   * The password to authenticate with the proxy, if required.\n   */\n  password?: string;\n}\n\n/**\n * An alias of {@link ProxySettings} for future use.\n */\nexport type ProxyOptions = ProxySettings;\n\n/**\n * Options to be provided while creating the client.\n */\nexport interface ServiceClientOptions {\n  /**\n   * An array of factories which get called to create the RequestPolicy pipeline used to send a HTTP\n   * request on the wire, or a function that takes in the defaultRequestPolicyFactories and returns\n   * the requestPolicyFactories that will be used.\n   */\n  requestPolicyFactories?:\n    | RequestPolicyFactory[]\n    | ((defaultRequestPolicyFactories: RequestPolicyFactory[]) => void | RequestPolicyFactory[]);\n  /**\n   * The HttpClient that will be used to send HTTP requests.\n   */\n  httpClient?: HttpClient;\n  /**\n   * The HttpPipelineLogger that can be used to debug RequestPolicies within the HTTP pipeline.\n   */\n  httpPipelineLogger?: HttpPipelineLogger;\n  /**\n   * If set to true, turn off the default retry policy.\n   */\n  noRetryPolicy?: boolean;\n  /**\n   * Gets or sets the retry timeout in seconds for AutomaticRPRegistration. Default value is 30.\n   */\n  rpRegistrationRetryTimeout?: number;\n  /**\n   * Whether or not to generate a client request ID header for each HTTP request.\n   */\n  generateClientRequestIdHeader?: boolean;\n  /**\n   * Whether to include credentials in CORS requests in the browser.\n   * See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials for more information.\n   */\n  withCredentials?: boolean;\n  /**\n   * If specified, a GenerateRequestIdPolicy will be added to the HTTP pipeline that will add a\n   * header to all outgoing requests with this header name and a random UUID as the request ID.\n   */\n  clientRequestIdHeaderName?: string;\n  /**\n   * The content-types that will be associated with JSON or XML serialization.\n   */\n  deserializationContentTypes?: DeserializationContentTypes;\n  /**\n   * The header name to use for the telemetry header while sending the request. If this is not\n   * specified, then \"User-Agent\" will be used when running on Node.js and \"x-ms-useragent\" will\n   * be used when running in a browser.\n   */\n  userAgentHeaderName?: string | ((defaultUserAgentHeaderName: string) => string);\n  /**\n   * The string to be set to the telemetry header while sending the request, or a function that\n   * takes in the default user-agent string and returns the user-agent string that will be used.\n   */\n  userAgent?: string | ((defaultUserAgent: string) => string);\n  /**\n   * Proxy settings which will be used for every HTTP request (Node.js only).\n   */\n  proxySettings?: ProxySettings;\n  /**\n   * If specified, will be used to build the BearerTokenAuthenticationPolicy.\n   */\n  credentialScopes?: string | string[];\n}\n\n/**\n * ServiceClient sends service requests and receives responses.\n */\nexport class ServiceClient {\n  /**\n   * If specified, this is the base URI that requests will be made against for this ServiceClient.\n   * If it is not specified, then all OperationSpecs must contain a baseUrl property.\n   */\n  protected baseUri?: string;\n\n  /**\n   * The default request content type for the service.\n   * Used if no requestContentType is present on an OperationSpec.\n   */\n  protected requestContentType?: string;\n\n  /**\n   * The HTTP client that will be used to send requests.\n   */\n  private readonly _httpClient: HttpClient;\n  private readonly _requestPolicyOptions: RequestPolicyOptions;\n\n  private readonly _requestPolicyFactories: RequestPolicyFactory[];\n  private readonly _withCredentials: boolean;\n\n  /**\n   * The ServiceClient constructor\n   * @param credentials - The credentials used for authentication with the service.\n   * @param options - The service client options that govern the behavior of the client.\n   */\n  constructor(\n    credentials?: TokenCredential | ServiceClientCredentials,\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options */\n    options?: ServiceClientOptions\n  ) {\n    if (!options) {\n      options = {};\n    }\n\n    this._withCredentials = options.withCredentials || false;\n    this._httpClient = options.httpClient || getCachedDefaultHttpClient();\n    this._requestPolicyOptions = new RequestPolicyOptions(options.httpPipelineLogger);\n\n    let requestPolicyFactories: RequestPolicyFactory[];\n    if (Array.isArray(options.requestPolicyFactories)) {\n      logger.info(\"ServiceClient: using custom request policies\");\n      requestPolicyFactories = options.requestPolicyFactories;\n    } else {\n      let authPolicyFactory: RequestPolicyFactory | undefined = undefined;\n      if (isTokenCredential(credentials)) {\n        logger.info(\n          \"ServiceClient: creating bearer token authentication policy from provided credentials\"\n        );\n        // Create a wrapped RequestPolicyFactory here so that we can provide the\n        // correct scope to the BearerTokenAuthenticationPolicy at the first time\n        // one is requested.  This is needed because generated ServiceClient\n        // implementations do not set baseUri until after ServiceClient's constructor\n        // is finished, leaving baseUri empty at the time when it is needed to\n        // build the correct scope name.\n        const wrappedPolicyFactory: () => RequestPolicyFactory = () => {\n          let bearerTokenPolicyFactory: RequestPolicyFactory | undefined = undefined;\n          // eslint-disable-next-line @typescript-eslint/no-this-alias\n          const serviceClient = this;\n          const serviceClientOptions = options;\n          return {\n            create(nextPolicy: RequestPolicy, createOptions: RequestPolicyOptions): RequestPolicy {\n              const credentialScopes = getCredentialScopes(\n                serviceClientOptions,\n                serviceClient.baseUri\n              );\n\n              if (!credentialScopes) {\n                throw new Error(\n                  `When using credential, the ServiceClient must contain a baseUri or a credentialScopes in ServiceClientOptions. Unable to create a bearerTokenAuthenticationPolicy`\n                );\n              }\n\n              if (bearerTokenPolicyFactory === undefined || bearerTokenPolicyFactory === null) {\n                bearerTokenPolicyFactory = bearerTokenAuthenticationPolicy(\n                  credentials,\n                  credentialScopes\n                );\n              }\n\n              return bearerTokenPolicyFactory.create(nextPolicy, createOptions);\n            },\n          };\n        };\n\n        authPolicyFactory = wrappedPolicyFactory();\n      } else if (credentials && typeof credentials.signRequest === \"function\") {\n        logger.info(\"ServiceClient: creating signing policy from provided credentials\");\n        authPolicyFactory = signingPolicy(credentials);\n      } else if (credentials !== undefined && credentials !== null) {\n        throw new Error(\"The credentials argument must implement the TokenCredential interface\");\n      }\n\n      logger.info(\"ServiceClient: using default request policies\");\n      requestPolicyFactories = createDefaultRequestPolicyFactories(authPolicyFactory, options);\n      if (options.requestPolicyFactories) {\n        // options.requestPolicyFactories can also be a function that manipulates\n        // the default requestPolicyFactories array\n        const newRequestPolicyFactories: void | RequestPolicyFactory[] =\n          options.requestPolicyFactories(requestPolicyFactories);\n        if (newRequestPolicyFactories) {\n          requestPolicyFactories = newRequestPolicyFactories;\n        }\n      }\n    }\n    this._requestPolicyFactories = requestPolicyFactories;\n  }\n\n  /**\n   * Send the provided httpRequest.\n   */\n  sendRequest(options: RequestPrepareOptions | WebResourceLike): Promise<HttpOperationResponse> {\n    if (options === null || options === undefined || typeof options !== \"object\") {\n      throw new Error(\"options cannot be null or undefined and it must be of type object.\");\n    }\n\n    let httpRequest: WebResourceLike;\n    try {\n      if (isWebResourceLike(options)) {\n        options.validateRequestProperties();\n        httpRequest = options;\n      } else {\n        httpRequest = new WebResource();\n        httpRequest = httpRequest.prepare(options);\n      }\n    } catch (error: any) {\n      return Promise.reject(error);\n    }\n\n    let httpPipeline: RequestPolicy = this._httpClient;\n    if (this._requestPolicyFactories && this._requestPolicyFactories.length > 0) {\n      for (let i = this._requestPolicyFactories.length - 1; i >= 0; --i) {\n        httpPipeline = this._requestPolicyFactories[i].create(\n          httpPipeline,\n          this._requestPolicyOptions\n        );\n      }\n    }\n    return httpPipeline.sendRequest(httpRequest);\n  }\n\n  /**\n   * Send an HTTP request that is populated using the provided OperationSpec.\n   * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.\n   * @param operationSpec - The OperationSpec to use to populate the httpRequest.\n   * @param callback - The callback to call when the response is received.\n   */\n  async sendOperationRequest(\n    operationArguments: OperationArguments,\n    operationSpec: OperationSpec,\n    callback?: ServiceCallback<any>\n  ): Promise<RestResponse> {\n    if (typeof operationArguments.options === \"function\") {\n      callback = operationArguments.options;\n      operationArguments.options = undefined;\n    }\n\n    const serializerOptions = operationArguments.options?.serializerOptions;\n    const httpRequest: WebResourceLike = new WebResource();\n\n    let result: Promise<RestResponse>;\n    try {\n      const baseUri: string | undefined = operationSpec.baseUrl || this.baseUri;\n      if (!baseUri) {\n        throw new Error(\n          \"If operationSpec.baseUrl is not specified, then the ServiceClient must have a baseUri string property that contains the base URL to use.\"\n        );\n      }\n\n      httpRequest.method = operationSpec.httpMethod;\n      httpRequest.operationSpec = operationSpec;\n\n      const requestUrl: URLBuilder = URLBuilder.parse(baseUri);\n      if (operationSpec.path) {\n        requestUrl.appendPath(operationSpec.path);\n      }\n      if (operationSpec.urlParameters && operationSpec.urlParameters.length > 0) {\n        for (const urlParameter of operationSpec.urlParameters) {\n          let urlParameterValue: string = getOperationArgumentValueFromParameter(\n            this,\n            operationArguments,\n            urlParameter,\n            operationSpec.serializer\n          );\n          urlParameterValue = operationSpec.serializer.serialize(\n            urlParameter.mapper,\n            urlParameterValue,\n            getPathStringFromParameter(urlParameter),\n            serializerOptions\n          );\n          if (!urlParameter.skipEncoding) {\n            urlParameterValue = encodeURIComponent(urlParameterValue);\n          }\n          requestUrl.replaceAll(\n            `{${urlParameter.mapper.serializedName || getPathStringFromParameter(urlParameter)}}`,\n            urlParameterValue\n          );\n        }\n      }\n      if (operationSpec.queryParameters && operationSpec.queryParameters.length > 0) {\n        for (const queryParameter of operationSpec.queryParameters) {\n          let queryParameterValue: any = getOperationArgumentValueFromParameter(\n            this,\n            operationArguments,\n            queryParameter,\n            operationSpec.serializer\n          );\n          if (queryParameterValue !== undefined && queryParameterValue !== null) {\n            queryParameterValue = operationSpec.serializer.serialize(\n              queryParameter.mapper,\n              queryParameterValue,\n              getPathStringFromParameter(queryParameter),\n              serializerOptions\n            );\n            if (\n              queryParameter.collectionFormat !== undefined &&\n              queryParameter.collectionFormat !== null\n            ) {\n              if (queryParameter.collectionFormat === QueryCollectionFormat.Multi) {\n                if (queryParameterValue.length === 0) {\n                  // The collection is empty, no need to try serializing the current queryParam\n                  continue;\n                } else {\n                  for (const index in queryParameterValue) {\n                    const item = queryParameterValue[index];\n                    queryParameterValue[index] =\n                      item === undefined || item === null ? \"\" : item.toString();\n                  }\n                }\n              } else if (\n                queryParameter.collectionFormat === QueryCollectionFormat.Ssv ||\n                queryParameter.collectionFormat === QueryCollectionFormat.Tsv\n              ) {\n                queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);\n              }\n            }\n            if (!queryParameter.skipEncoding) {\n              if (Array.isArray(queryParameterValue)) {\n                for (const index in queryParameterValue) {\n                  if (\n                    queryParameterValue[index] !== undefined &&\n                    queryParameterValue[index] !== null\n                  ) {\n                    queryParameterValue[index] = encodeURIComponent(queryParameterValue[index]);\n                  }\n                }\n              } else {\n                queryParameterValue = encodeURIComponent(queryParameterValue);\n              }\n            }\n            if (\n              queryParameter.collectionFormat !== undefined &&\n              queryParameter.collectionFormat !== null &&\n              queryParameter.collectionFormat !== QueryCollectionFormat.Multi &&\n              queryParameter.collectionFormat !== QueryCollectionFormat.Ssv &&\n              queryParameter.collectionFormat !== QueryCollectionFormat.Tsv\n            ) {\n              queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);\n            }\n            requestUrl.setQueryParameter(\n              queryParameter.mapper.serializedName || getPathStringFromParameter(queryParameter),\n              queryParameterValue\n            );\n          }\n        }\n      }\n      httpRequest.url = requestUrl.toString();\n\n      const contentType = operationSpec.contentType || this.requestContentType;\n      if (contentType && operationSpec.requestBody) {\n        httpRequest.headers.set(\"Content-Type\", contentType);\n      }\n\n      if (operationSpec.headerParameters) {\n        for (const headerParameter of operationSpec.headerParameters) {\n          let headerValue: any = getOperationArgumentValueFromParameter(\n            this,\n            operationArguments,\n            headerParameter,\n            operationSpec.serializer\n          );\n          if (headerValue !== undefined && headerValue !== null) {\n            headerValue = operationSpec.serializer.serialize(\n              headerParameter.mapper,\n              headerValue,\n              getPathStringFromParameter(headerParameter),\n              serializerOptions\n            );\n            const headerCollectionPrefix = (headerParameter.mapper as DictionaryMapper)\n              .headerCollectionPrefix;\n            if (headerCollectionPrefix) {\n              for (const key of Object.keys(headerValue)) {\n                httpRequest.headers.set(headerCollectionPrefix + key, headerValue[key]);\n              }\n            } else {\n              httpRequest.headers.set(\n                headerParameter.mapper.serializedName ||\n                  getPathStringFromParameter(headerParameter),\n                headerValue\n              );\n            }\n          }\n        }\n      }\n\n      const options: RequestOptionsBase | undefined = operationArguments.options;\n      if (options) {\n        if (options.customHeaders) {\n          for (const customHeaderName in options.customHeaders) {\n            httpRequest.headers.set(customHeaderName, options.customHeaders[customHeaderName]);\n          }\n        }\n\n        if (options.abortSignal) {\n          httpRequest.abortSignal = options.abortSignal;\n        }\n\n        if (options.timeout) {\n          httpRequest.timeout = options.timeout;\n        }\n\n        if (options.onUploadProgress) {\n          httpRequest.onUploadProgress = options.onUploadProgress;\n        }\n\n        if (options.onDownloadProgress) {\n          httpRequest.onDownloadProgress = options.onDownloadProgress;\n        }\n\n        if (options.spanOptions) {\n          // By passing spanOptions if they exist at runtime, we're backwards compatible with @azure/core-tracing@preview.13 and earlier.\n          (httpRequest as any).spanOptions = options.spanOptions;\n        }\n\n        if (options.tracingContext) {\n          httpRequest.tracingContext = options.tracingContext;\n        }\n\n        if (options.shouldDeserialize !== undefined && options.shouldDeserialize !== null) {\n          httpRequest.shouldDeserialize = options.shouldDeserialize;\n        }\n      }\n\n      httpRequest.withCredentials = this._withCredentials;\n\n      serializeRequestBody(this, httpRequest, operationArguments, operationSpec);\n\n      if (httpRequest.streamResponseStatusCodes === undefined) {\n        httpRequest.streamResponseStatusCodes = getStreamResponseStatusCodes(operationSpec);\n      }\n\n      let rawResponse: HttpOperationResponse;\n      let sendRequestError;\n      try {\n        rawResponse = await this.sendRequest(httpRequest);\n      } catch (error: any) {\n        sendRequestError = error;\n      }\n      if (sendRequestError) {\n        if (sendRequestError.response) {\n          sendRequestError.details = flattenResponse(\n            sendRequestError.response,\n            operationSpec.responses[sendRequestError.statusCode] ||\n              operationSpec.responses[\"default\"]\n          );\n        }\n        result = Promise.reject(sendRequestError);\n      } else {\n        result = Promise.resolve(\n          flattenResponse(rawResponse!, operationSpec.responses[rawResponse!.status])\n        );\n      }\n    } catch (error: any) {\n      result = Promise.reject(error);\n    }\n\n    const cb = callback;\n    if (cb) {\n      result\n        .then((res) => cb(null, res._response.parsedBody, res._response.request, res._response))\n        .catch((err) => cb(err));\n    }\n\n    return result;\n  }\n}\n\nexport function serializeRequestBody(\n  serviceClient: ServiceClient,\n  httpRequest: WebResourceLike,\n  operationArguments: OperationArguments,\n  operationSpec: OperationSpec\n): void {\n  const serializerOptions = operationArguments.options?.serializerOptions ?? {};\n  const updatedOptions: Required<SerializerOptions> = {\n    rootName: serializerOptions.rootName ?? \"\",\n    includeRoot: serializerOptions.includeRoot ?? false,\n    xmlCharKey: serializerOptions.xmlCharKey ?? XML_CHARKEY,\n  };\n\n  const xmlCharKey = serializerOptions.xmlCharKey;\n  if (operationSpec.requestBody && operationSpec.requestBody.mapper) {\n    httpRequest.body = getOperationArgumentValueFromParameter(\n      serviceClient,\n      operationArguments,\n      operationSpec.requestBody,\n      operationSpec.serializer\n    );\n\n    const bodyMapper = operationSpec.requestBody.mapper;\n    const { required, xmlName, xmlElementName, serializedName, xmlNamespace, xmlNamespacePrefix } =\n      bodyMapper;\n    const typeName = bodyMapper.type.name;\n\n    try {\n      if ((httpRequest.body !== undefined && httpRequest.body !== null) || required) {\n        const requestBodyParameterPathString: string = getPathStringFromParameter(\n          operationSpec.requestBody\n        );\n        httpRequest.body = operationSpec.serializer.serialize(\n          bodyMapper,\n          httpRequest.body,\n          requestBodyParameterPathString,\n          updatedOptions\n        );\n\n        const isStream = typeName === MapperType.Stream;\n\n        if (operationSpec.isXML) {\n          const xmlnsKey = xmlNamespacePrefix ? `xmlns:${xmlNamespacePrefix}` : \"xmlns\";\n          const value = getXmlValueWithNamespace(\n            xmlNamespace,\n            xmlnsKey,\n            typeName,\n            httpRequest.body,\n            updatedOptions\n          );\n          if (typeName === MapperType.Sequence) {\n            httpRequest.body = stringifyXML(\n              utils.prepareXMLRootList(\n                value,\n                xmlElementName || xmlName || serializedName!,\n                xmlnsKey,\n                xmlNamespace\n              ),\n              {\n                rootName: xmlName || serializedName,\n                xmlCharKey,\n              }\n            );\n          } else if (!isStream) {\n            httpRequest.body = stringifyXML(value, {\n              rootName: xmlName || serializedName,\n              xmlCharKey,\n            });\n          }\n        } else if (\n          typeName === MapperType.String &&\n          (operationSpec.contentType?.match(\"text/plain\") || operationSpec.mediaType === \"text\")\n        ) {\n          // the String serializer has validated that request body is a string\n          // so just send the string.\n          return;\n        } else if (!isStream) {\n          httpRequest.body = JSON.stringify(httpRequest.body);\n        }\n      }\n    } catch (error: any) {\n      throw new Error(\n        `Error \"${error.message}\" occurred in serializing the payload - ${JSON.stringify(\n          serializedName,\n          undefined,\n          \"  \"\n        )}.`\n      );\n    }\n  } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {\n    httpRequest.formData = {};\n    for (const formDataParameter of operationSpec.formDataParameters) {\n      const formDataParameterValue: any = getOperationArgumentValueFromParameter(\n        serviceClient,\n        operationArguments,\n        formDataParameter,\n        operationSpec.serializer\n      );\n      if (formDataParameterValue !== undefined && formDataParameterValue !== null) {\n        const formDataParameterPropertyName: string =\n          formDataParameter.mapper.serializedName || getPathStringFromParameter(formDataParameter);\n        httpRequest.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(\n          formDataParameter.mapper,\n          formDataParameterValue,\n          getPathStringFromParameter(formDataParameter),\n          updatedOptions\n        );\n      }\n    }\n  }\n}\n\n/**\n * Adds an xml namespace to the xml serialized object if needed, otherwise it just returns the value itself\n */\nfunction getXmlValueWithNamespace(\n  xmlNamespace: string | undefined,\n  xmlnsKey: string,\n  typeName: string,\n  serializedValue: any,\n  options: Required<SerializerOptions>\n): any {\n  // Composite and Sequence schemas already got their root namespace set during serialization\n  // We just need to add xmlns to the other schema types\n  if (xmlNamespace && ![\"Composite\", \"Sequence\", \"Dictionary\"].includes(typeName)) {\n    const result: any = {};\n    result[options.xmlCharKey] = serializedValue;\n    result[XML_ATTRKEY] = { [xmlnsKey]: xmlNamespace };\n    return result;\n  }\n\n  return serializedValue;\n}\n\nfunction getValueOrFunctionResult(\n  value: undefined | string | ((defaultValue: string) => string),\n  defaultValueCreator: () => string\n): string {\n  let result: string;\n  if (typeof value === \"string\") {\n    result = value;\n  } else {\n    result = defaultValueCreator();\n    if (typeof value === \"function\") {\n      result = value(result);\n    }\n  }\n  return result;\n}\n\nfunction createDefaultRequestPolicyFactories(\n  authPolicyFactory: RequestPolicyFactory | undefined,\n  options: ServiceClientOptions\n): RequestPolicyFactory[] {\n  const factories: RequestPolicyFactory[] = [];\n\n  if (options.generateClientRequestIdHeader) {\n    factories.push(generateClientRequestIdPolicy(options.clientRequestIdHeaderName));\n  }\n\n  if (authPolicyFactory) {\n    factories.push(authPolicyFactory);\n  }\n\n  const userAgentHeaderName: string = getValueOrFunctionResult(\n    options.userAgentHeaderName,\n    getDefaultUserAgentHeaderName\n  );\n  const userAgentHeaderValue: string = getValueOrFunctionResult(\n    options.userAgent,\n    getDefaultUserAgentValue\n  );\n  if (userAgentHeaderName && userAgentHeaderValue) {\n    factories.push(userAgentPolicy({ key: userAgentHeaderName, value: userAgentHeaderValue }));\n  }\n  factories.push(redirectPolicy());\n  factories.push(rpRegistrationPolicy(options.rpRegistrationRetryTimeout));\n\n  if (!options.noRetryPolicy) {\n    factories.push(exponentialRetryPolicy());\n    factories.push(systemErrorRetryPolicy());\n    factories.push(throttlingRetryPolicy());\n  }\n\n  factories.push(deserializationPolicy(options.deserializationContentTypes));\n\n  if (isNode) {\n    factories.push(proxyPolicy(options.proxySettings));\n  }\n\n  factories.push(logPolicy({ logger: logger.info }));\n\n  return factories;\n}\n\n/**\n * Creates an HTTP pipeline based on the given options.\n * @param pipelineOptions - Defines options that are used to configure policies in the HTTP pipeline for an SDK client.\n * @param authPolicyFactory - An optional authentication policy factory to use for signing requests.\n * @returns A set of options that can be passed to create a new {@link ServiceClient}.\n */\nexport function createPipelineFromOptions(\n  pipelineOptions: InternalPipelineOptions,\n  authPolicyFactory?: RequestPolicyFactory\n): ServiceClientOptions {\n  const requestPolicyFactories: RequestPolicyFactory[] = [];\n\n  if (pipelineOptions.sendStreamingJson) {\n    requestPolicyFactories.push(ndJsonPolicy());\n  }\n\n  let userAgentValue = undefined;\n  if (pipelineOptions.userAgentOptions && pipelineOptions.userAgentOptions.userAgentPrefix) {\n    const userAgentInfo: string[] = [];\n    userAgentInfo.push(pipelineOptions.userAgentOptions.userAgentPrefix);\n\n    // Add the default user agent value if it isn't already specified\n    // by the userAgentPrefix option.\n    const defaultUserAgentInfo = getDefaultUserAgentValue();\n    if (userAgentInfo.indexOf(defaultUserAgentInfo) === -1) {\n      userAgentInfo.push(defaultUserAgentInfo);\n    }\n\n    userAgentValue = userAgentInfo.join(\" \");\n  }\n\n  const keepAliveOptions = {\n    ...DefaultKeepAliveOptions,\n    ...pipelineOptions.keepAliveOptions,\n  };\n\n  const retryOptions = {\n    ...DefaultRetryOptions,\n    ...pipelineOptions.retryOptions,\n  };\n\n  const redirectOptions = {\n    ...DefaultRedirectOptions,\n    ...pipelineOptions.redirectOptions,\n  };\n\n  if (isNode) {\n    requestPolicyFactories.push(proxyPolicy(pipelineOptions.proxyOptions));\n  }\n\n  const deserializationOptions = {\n    ...DefaultDeserializationOptions,\n    ...pipelineOptions.deserializationOptions,\n  };\n\n  const loggingOptions: LogPolicyOptions = {\n    ...pipelineOptions.loggingOptions,\n  };\n\n  requestPolicyFactories.push(\n    tracingPolicy({ userAgent: userAgentValue }),\n    keepAlivePolicy(keepAliveOptions),\n    userAgentPolicy({ value: userAgentValue }),\n    generateClientRequestIdPolicy(),\n    deserializationPolicy(deserializationOptions.expectedContentTypes),\n    throttlingRetryPolicy(),\n    systemErrorRetryPolicy(),\n    exponentialRetryPolicy(\n      retryOptions.maxRetries,\n      retryOptions.retryDelayInMs,\n      retryOptions.maxRetryDelayInMs\n    )\n  );\n\n  if (redirectOptions.handleRedirects) {\n    requestPolicyFactories.push(redirectPolicy(redirectOptions.maxRetries));\n  }\n\n  if (authPolicyFactory) {\n    requestPolicyFactories.push(authPolicyFactory);\n  }\n\n  requestPolicyFactories.push(logPolicy(loggingOptions));\n\n  if (isNode && pipelineOptions.decompressResponse === false) {\n    requestPolicyFactories.push(disableResponseDecompressionPolicy());\n  }\n\n  return {\n    httpClient: pipelineOptions.httpClient,\n    requestPolicyFactories,\n  };\n}\n\nexport type PropertyParent = { [propertyName: string]: any };\n\n/**\n * Get the property parent for the property at the provided path when starting with the provided\n * parent object.\n */\nexport function getPropertyParent(parent: PropertyParent, propertyPath: string[]): PropertyParent {\n  if (parent && propertyPath) {\n    const propertyPathLength: number = propertyPath.length;\n    for (let i = 0; i < propertyPathLength - 1; ++i) {\n      const propertyName: string = propertyPath[i];\n      if (!parent[propertyName]) {\n        parent[propertyName] = {};\n      }\n      parent = parent[propertyName];\n    }\n  }\n  return parent;\n}\n\nfunction getOperationArgumentValueFromParameter(\n  serviceClient: ServiceClient,\n  operationArguments: OperationArguments,\n  parameter: OperationParameter,\n  serializer: Serializer\n): any {\n  return getOperationArgumentValueFromParameterPath(\n    serviceClient,\n    operationArguments,\n    parameter.parameterPath,\n    parameter.mapper,\n    serializer\n  );\n}\n\nexport function getOperationArgumentValueFromParameterPath(\n  serviceClient: ServiceClient,\n  operationArguments: OperationArguments,\n  parameterPath: ParameterPath,\n  parameterMapper: Mapper,\n  serializer: Serializer\n): any {\n  let value: any;\n  if (typeof parameterPath === \"string\") {\n    parameterPath = [parameterPath];\n  }\n  const serializerOptions = operationArguments.options?.serializerOptions;\n  if (Array.isArray(parameterPath)) {\n    if (parameterPath.length > 0) {\n      if (parameterMapper.isConstant) {\n        value = parameterMapper.defaultValue;\n      } else {\n        let propertySearchResult: PropertySearchResult = getPropertyFromParameterPath(\n          operationArguments,\n          parameterPath\n        );\n        if (!propertySearchResult.propertyFound) {\n          propertySearchResult = getPropertyFromParameterPath(serviceClient, parameterPath);\n        }\n\n        let useDefaultValue = false;\n        if (!propertySearchResult.propertyFound) {\n          useDefaultValue =\n            parameterMapper.required ||\n            (parameterPath[0] === \"options\" && parameterPath.length === 2);\n        }\n        value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;\n      }\n\n      // Serialize just for validation purposes.\n      const parameterPathString: string = getPathStringFromParameterPath(\n        parameterPath,\n        parameterMapper\n      );\n      serializer.serialize(parameterMapper, value, parameterPathString, serializerOptions);\n    }\n  } else {\n    if (parameterMapper.required) {\n      value = {};\n    }\n\n    for (const propertyName in parameterPath) {\n      const propertyMapper: Mapper = (parameterMapper as CompositeMapper).type.modelProperties![\n        propertyName\n      ];\n      const propertyPath: ParameterPath = parameterPath[propertyName];\n      const propertyValue: any = getOperationArgumentValueFromParameterPath(\n        serviceClient,\n        operationArguments,\n        propertyPath,\n        propertyMapper,\n        serializer\n      );\n      // Serialize just for validation purposes.\n      const propertyPathString: string = getPathStringFromParameterPath(\n        propertyPath,\n        propertyMapper\n      );\n      serializer.serialize(propertyMapper, propertyValue, propertyPathString, serializerOptions);\n      if (propertyValue !== undefined && propertyValue !== null) {\n        if (!value) {\n          value = {};\n        }\n        value[propertyName] = propertyValue;\n      }\n    }\n  }\n  return value;\n}\n\ninterface PropertySearchResult {\n  propertyValue?: any;\n  propertyFound: boolean;\n}\n\nfunction getPropertyFromParameterPath(\n  parent: { [parameterName: string]: any },\n  parameterPath: string[]\n): PropertySearchResult {\n  const result: PropertySearchResult = { propertyFound: false };\n  let i = 0;\n  for (; i < parameterPath.length; ++i) {\n    const parameterPathPart: string = parameterPath[i];\n    // Make sure to check inherited properties too, so don't use hasOwnProperty().\n    if (parent !== undefined && parent !== null && parameterPathPart in parent) {\n      parent = parent[parameterPathPart];\n    } else {\n      break;\n    }\n  }\n  if (i === parameterPath.length) {\n    result.propertyValue = parent;\n    result.propertyFound = true;\n  }\n  return result;\n}\n\n/**\n * Parses an {@link HttpOperationResponse} into a normalized HTTP response object ({@link RestResponse}).\n * @param _response - Wrapper object for http response.\n * @param responseSpec - Mappers for how to parse the response properties.\n * @returns - A normalized response object.\n */\nexport function flattenResponse(\n  _response: HttpOperationResponse,\n  responseSpec: OperationResponse | undefined\n): RestResponse {\n  const parsedHeaders = _response.parsedHeaders;\n  const bodyMapper = responseSpec && responseSpec.bodyMapper;\n\n  const addOperationResponse = <T extends Record<string, unknown>>(\n    obj: T\n  ): T & {\n    _response: HttpOperationResponse;\n  } => {\n    return Object.defineProperty(obj, \"_response\", {\n      value: _response,\n    }) as T & {\n      _response: HttpOperationResponse;\n    };\n  };\n\n  if (bodyMapper) {\n    const typeName = bodyMapper.type.name;\n    if (typeName === \"Stream\") {\n      return addOperationResponse({\n        ...parsedHeaders,\n        blobBody: _response.blobBody,\n        readableStreamBody: _response.readableStreamBody,\n      });\n    }\n\n    const modelProperties =\n      (typeName === \"Composite\" && (bodyMapper as CompositeMapper).type.modelProperties) || {};\n    const isPageableResponse = Object.keys(modelProperties).some(\n      (k) => modelProperties[k].serializedName === \"\"\n    );\n    if (typeName === \"Sequence\" || isPageableResponse) {\n      const arrayResponse = [...(_response.parsedBody || [])] as RestResponse & any[];\n\n      for (const key of Object.keys(modelProperties)) {\n        if (modelProperties[key].serializedName) {\n          arrayResponse[key] = _response.parsedBody[key];\n        }\n      }\n\n      if (parsedHeaders) {\n        for (const key of Object.keys(parsedHeaders)) {\n          arrayResponse[key] = parsedHeaders[key];\n        }\n      }\n      addOperationResponse(arrayResponse);\n      return arrayResponse;\n    }\n\n    if (typeName === \"Composite\" || typeName === \"Dictionary\") {\n      return addOperationResponse({\n        ...parsedHeaders,\n        ..._response.parsedBody,\n      });\n    }\n  }\n\n  if (\n    bodyMapper ||\n    _response.request.method === \"HEAD\" ||\n    utils.isPrimitiveType(_response.parsedBody)\n  ) {\n    // primitive body types and HEAD booleans\n    return addOperationResponse({\n      ...parsedHeaders,\n      body: _response.parsedBody,\n    });\n  }\n\n  return addOperationResponse({\n    ...parsedHeaders,\n    ..._response.parsedBody,\n  });\n}\n\nfunction getCredentialScopes(\n  options?: ServiceClientOptions,\n  baseUri?: string\n): string | string[] | undefined {\n  if (options?.credentialScopes) {\n    const scopes = options.credentialScopes;\n    return Array.isArray(scopes)\n      ? scopes.map((scope) => new URL(scope).toString())\n      : new URL(scopes).toString();\n  }\n\n  if (baseUri) {\n    return `${baseUri}/.default`;\n  }\n  return undefined;\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}