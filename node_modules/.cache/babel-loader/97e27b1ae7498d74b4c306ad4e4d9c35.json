{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { BaseRequestPolicy } from \"./requestPolicy\";\nimport { SpanKind, SpanStatusCode, createSpanFunction, getTraceParentHeader, isSpanContextValid } from \"@azure/core-tracing\";\nimport { logger } from \"../log\";\nconst createSpan = createSpanFunction({\n  packagePrefix: \"\",\n  namespace: \"\"\n});\n/**\n * Creates a policy that wraps outgoing requests with a tracing span.\n * @param tracingOptions - Tracing options.\n * @returns An instance of the {@link TracingPolicy} class.\n */\nexport function tracingPolicy() {\n  let tracingOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return {\n    create(nextPolicy, options) {\n      return new TracingPolicy(nextPolicy, options, tracingOptions);\n    }\n  };\n}\n/**\n * A policy that wraps outgoing requests with a tracing span.\n */\nexport class TracingPolicy extends BaseRequestPolicy {\n  constructor(nextPolicy, options, tracingOptions) {\n    super(nextPolicy, options);\n    this.userAgent = tracingOptions.userAgent;\n  }\n  async sendRequest(request) {\n    if (!request.tracingContext) {\n      return this._nextPolicy.sendRequest(request);\n    }\n    const span = this.tryCreateSpan(request);\n    if (!span) {\n      return this._nextPolicy.sendRequest(request);\n    }\n    try {\n      const response = await this._nextPolicy.sendRequest(request);\n      this.tryProcessResponse(span, response);\n      return response;\n    } catch (err) {\n      this.tryProcessError(span, err);\n      throw err;\n    }\n  }\n  tryCreateSpan(request) {\n    var _a;\n    try {\n      // Passing spanOptions as part of tracingOptions to maintain compatibility @azure/core-tracing@preview.13 and earlier.\n      // We can pass this as a separate parameter once we upgrade to the latest core-tracing.\n      const {\n        span\n      } = createSpan(`HTTP ${request.method}`, {\n        tracingOptions: {\n          spanOptions: Object.assign(Object.assign({}, request.spanOptions), {\n            kind: SpanKind.CLIENT\n          }),\n          tracingContext: request.tracingContext\n        }\n      });\n      // If the span is not recording, don't do any more work.\n      if (!span.isRecording()) {\n        span.end();\n        return undefined;\n      }\n      const namespaceFromContext = (_a = request.tracingContext) === null || _a === void 0 ? void 0 : _a.getValue(Symbol.for(\"az.namespace\"));\n      if (typeof namespaceFromContext === \"string\") {\n        span.setAttribute(\"az.namespace\", namespaceFromContext);\n      }\n      span.setAttributes({\n        \"http.method\": request.method,\n        \"http.url\": request.url,\n        requestId: request.requestId\n      });\n      if (this.userAgent) {\n        span.setAttribute(\"http.user_agent\", this.userAgent);\n      }\n      // set headers\n      const spanContext = span.spanContext();\n      const traceParentHeader = getTraceParentHeader(spanContext);\n      if (traceParentHeader && isSpanContextValid(spanContext)) {\n        request.headers.set(\"traceparent\", traceParentHeader);\n        const traceState = spanContext.traceState && spanContext.traceState.serialize();\n        // if tracestate is set, traceparent MUST be set, so only set tracestate after traceparent\n        if (traceState) {\n          request.headers.set(\"tracestate\", traceState);\n        }\n      }\n      return span;\n    } catch (error) {\n      logger.warning(`Skipping creating a tracing span due to an error: ${error.message}`);\n      return undefined;\n    }\n  }\n  tryProcessError(span, err) {\n    try {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: err.message\n      });\n      if (err.statusCode) {\n        span.setAttribute(\"http.status_code\", err.statusCode);\n      }\n      span.end();\n    } catch (error) {\n      logger.warning(`Skipping tracing span processing due to an error: ${error.message}`);\n    }\n  }\n  tryProcessResponse(span, response) {\n    try {\n      span.setAttribute(\"http.status_code\", response.status);\n      const serviceRequestId = response.headers.get(\"x-ms-request-id\");\n      if (serviceRequestId) {\n        span.setAttribute(\"serviceRequestId\", serviceRequestId);\n      }\n      span.setStatus({\n        code: SpanStatusCode.OK\n      });\n      span.end();\n    } catch (error) {\n      logger.warning(`Skipping tracing span processing due to an error: ${error.message}`);\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["BaseRequestPolicy","SpanKind","SpanStatusCode","createSpanFunction","getTraceParentHeader","isSpanContextValid","logger","createSpan","packagePrefix","namespace","tracingPolicy","tracingOptions","create","nextPolicy","options","TracingPolicy","constructor","userAgent","sendRequest","request","tracingContext","_nextPolicy","span","tryCreateSpan","response","tryProcessResponse","err","tryProcessError","method","spanOptions","kind","CLIENT","isRecording","end","undefined","namespaceFromContext","getValue","Symbol","for","setAttribute","setAttributes","url","requestId","spanContext","traceParentHeader","headers","set","traceState","serialize","error","warning","message","setStatus","code","ERROR","statusCode","status","serviceRequestId","get","OK"],"sourceRoot":"","sources":["../../../src/policies/tracingPolicy.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  BaseRequestPolicy,\n  RequestPolicy,\n  RequestPolicyFactory,\n  RequestPolicyOptions,\n} from \"./requestPolicy\";\nimport {\n  Span,\n  SpanKind,\n  SpanStatusCode,\n  createSpanFunction,\n  getTraceParentHeader,\n  isSpanContextValid,\n} from \"@azure/core-tracing\";\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport { WebResourceLike } from \"../webResource\";\nimport { logger } from \"../log\";\n\nconst createSpan = createSpanFunction({\n  packagePrefix: \"\",\n  namespace: \"\",\n});\n\n/**\n * Options to customize the tracing policy.\n */\nexport interface TracingPolicyOptions {\n  /**\n   * User agent used to better identify the outgoing requests traced by the tracing policy.\n   */\n  userAgent?: string;\n}\n\n/**\n * Creates a policy that wraps outgoing requests with a tracing span.\n * @param tracingOptions - Tracing options.\n * @returns An instance of the {@link TracingPolicy} class.\n */\nexport function tracingPolicy(tracingOptions: TracingPolicyOptions = {}): RequestPolicyFactory {\n  return {\n    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions) {\n      return new TracingPolicy(nextPolicy, options, tracingOptions);\n    },\n  };\n}\n\n/**\n * A policy that wraps outgoing requests with a tracing span.\n */\nexport class TracingPolicy extends BaseRequestPolicy {\n  private userAgent?: string;\n\n  constructor(\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptions,\n    tracingOptions: TracingPolicyOptions\n  ) {\n    super(nextPolicy, options);\n    this.userAgent = tracingOptions.userAgent;\n  }\n\n  public async sendRequest(request: WebResourceLike): Promise<HttpOperationResponse> {\n    if (!request.tracingContext) {\n      return this._nextPolicy.sendRequest(request);\n    }\n\n    const span = this.tryCreateSpan(request);\n\n    if (!span) {\n      return this._nextPolicy.sendRequest(request);\n    }\n\n    try {\n      const response = await this._nextPolicy.sendRequest(request);\n      this.tryProcessResponse(span, response);\n      return response;\n    } catch (err: any) {\n      this.tryProcessError(span, err);\n      throw err;\n    }\n  }\n\n  tryCreateSpan(request: WebResourceLike): Span | undefined {\n    try {\n      // Passing spanOptions as part of tracingOptions to maintain compatibility @azure/core-tracing@preview.13 and earlier.\n      // We can pass this as a separate parameter once we upgrade to the latest core-tracing.\n      const { span } = createSpan(`HTTP ${request.method}`, {\n        tracingOptions: {\n          spanOptions: {\n            ...(request as any).spanOptions,\n            kind: SpanKind.CLIENT,\n          },\n          tracingContext: request.tracingContext,\n        },\n      });\n\n      // If the span is not recording, don't do any more work.\n      if (!span.isRecording()) {\n        span.end();\n        return undefined;\n      }\n\n      const namespaceFromContext = request.tracingContext?.getValue(Symbol.for(\"az.namespace\"));\n\n      if (typeof namespaceFromContext === \"string\") {\n        span.setAttribute(\"az.namespace\", namespaceFromContext);\n      }\n\n      span.setAttributes({\n        \"http.method\": request.method,\n        \"http.url\": request.url,\n        requestId: request.requestId,\n      });\n\n      if (this.userAgent) {\n        span.setAttribute(\"http.user_agent\", this.userAgent);\n      }\n\n      // set headers\n      const spanContext = span.spanContext();\n      const traceParentHeader = getTraceParentHeader(spanContext);\n      if (traceParentHeader && isSpanContextValid(spanContext)) {\n        request.headers.set(\"traceparent\", traceParentHeader);\n        const traceState = spanContext.traceState && spanContext.traceState.serialize();\n        // if tracestate is set, traceparent MUST be set, so only set tracestate after traceparent\n        if (traceState) {\n          request.headers.set(\"tracestate\", traceState);\n        }\n      }\n      return span;\n    } catch (error: any) {\n      logger.warning(`Skipping creating a tracing span due to an error: ${error.message}`);\n      return undefined;\n    }\n  }\n\n  private tryProcessError(span: Span, err: any): void {\n    try {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: err.message,\n      });\n\n      if (err.statusCode) {\n        span.setAttribute(\"http.status_code\", err.statusCode);\n      }\n      span.end();\n    } catch (error: any) {\n      logger.warning(`Skipping tracing span processing due to an error: ${error.message}`);\n    }\n  }\n\n  private tryProcessResponse(span: Span, response: HttpOperationResponse): void {\n    try {\n      span.setAttribute(\"http.status_code\", response.status);\n      const serviceRequestId = response.headers.get(\"x-ms-request-id\");\n      if (serviceRequestId) {\n        span.setAttribute(\"serviceRequestId\", serviceRequestId);\n      }\n      span.setStatus({\n        code: SpanStatusCode.OK,\n      });\n      span.end();\n    } catch (error: any) {\n      logger.warning(`Skipping tracing span processing due to an error: ${error.message}`);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}