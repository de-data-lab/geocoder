{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/tbeckett/Documents/TI - Project Info/JavaScript_end_to_end_client_file_upload_to_Azure_Storage_Blobs/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _asyncToGenerator from \"/Users/tbeckett/Documents/TI - Project Info/JavaScript_end_to_end_client_file_upload_to_Azure_Storage_Blobs/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/tbeckett/Documents/TI - Project Info/JavaScript_end_to_end_client_file_upload_to_Azure_Storage_Blobs/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/tbeckett/Documents/TI - Project Info/JavaScript_end_to_end_client_file_upload_to_Azure_Storage_Blobs/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { HttpHeaders } from \"@azure/core-http\";\nimport { HTTP_VERSION_1_1, HTTP_LINE_ENDING, HeaderConstants, HTTPURLConnection } from \"./utils/constants\";\nimport { getBodyAsText } from \"./BatchUtils\";\nimport { logger } from \"./log\";\nvar HTTP_HEADER_DELIMITER = \": \";\nvar SPACE_DELIMITER = \" \";\nvar NOT_FOUND = -1;\n/**\n * Util class for parsing batch response.\n */\nexport var BatchResponseParser = /*#__PURE__*/function () {\n  function BatchResponseParser(batchResponse, subRequests) {\n    _classCallCheck(this, BatchResponseParser);\n    if (!batchResponse || !batchResponse.contentType) {\n      // In special case(reported), server may return invalid content-type which could not be parsed.\n      throw new RangeError(\"batchResponse is malformed or doesn't contain valid content-type.\");\n    }\n    if (!subRequests || subRequests.size === 0) {\n      // This should be prevent during coding.\n      throw new RangeError(\"Invalid state: subRequests is not provided or size is 0.\");\n    }\n    this.batchResponse = batchResponse;\n    this.subRequests = subRequests;\n    this.responseBatchBoundary = this.batchResponse.contentType.split(\"=\")[1];\n    this.perResponsePrefix = \"--\".concat(this.responseBatchBoundary).concat(HTTP_LINE_ENDING);\n    this.batchResponseEnding = \"--\".concat(this.responseBatchBoundary, \"--\");\n  }\n  // For example of response, please refer to https://docs.microsoft.com/en-us/rest/api/storageservices/blob-batch#response\n  _createClass(BatchResponseParser, [{\n    key: \"parseBatchResponse\",\n    value: function () {\n      var _parseBatchResponse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var responseBodyAsText, subResponses, subResponseCount, deserializedSubResponses, subResponsesSucceededCount, subResponsesFailedCount, index, subResponse, deserializedSubResponse, responseLines, subRespHeaderStartFound, subRespHeaderEndFound, subRespFailed, contentId, _iterator, _step, responseLine, tokens, _tokens;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(this.batchResponse._response.status !== HTTPURLConnection.HTTP_ACCEPTED)) {\n                  _context.next = 2;\n                  break;\n                }\n                throw new Error(\"Invalid state: batch request failed with status: '\".concat(this.batchResponse._response.status, \"'.\"));\n              case 2:\n                _context.next = 4;\n                return getBodyAsText(this.batchResponse);\n              case 4:\n                responseBodyAsText = _context.sent;\n                subResponses = responseBodyAsText.split(this.batchResponseEnding)[0] // string after ending is useless\n                .split(this.perResponsePrefix).slice(1); // string before first response boundary is useless\n                subResponseCount = subResponses.length; // Defensive coding in case of potential error parsing.\n                // Note: subResponseCount == 1 is special case where sub request is invalid.\n                // We try to prevent such cases through early validation, e.g. validate sub request count >= 1.\n                // While in unexpected sub request invalid case, we allow sub response to be parsed and return to user.\n                if (!(subResponseCount !== this.subRequests.size && subResponseCount !== 1)) {\n                  _context.next = 9;\n                  break;\n                }\n                throw new Error(\"Invalid state: sub responses' count is not equal to sub requests' count.\");\n              case 9:\n                deserializedSubResponses = new Array(subResponseCount);\n                subResponsesSucceededCount = 0;\n                subResponsesFailedCount = 0; // Parse sub subResponses.\n                index = 0;\n              case 13:\n                if (!(index < subResponseCount)) {\n                  _context.next = 59;\n                  break;\n                }\n                subResponse = subResponses[index];\n                deserializedSubResponse = {};\n                deserializedSubResponse.headers = new HttpHeaders();\n                responseLines = subResponse.split(\"\".concat(HTTP_LINE_ENDING));\n                subRespHeaderStartFound = false;\n                subRespHeaderEndFound = false;\n                subRespFailed = false;\n                contentId = NOT_FOUND;\n                _iterator = _createForOfIteratorHelper(responseLines);\n                _context.prev = 23;\n                _iterator.s();\n              case 25:\n                if ((_step = _iterator.n()).done) {\n                  _context.next = 46;\n                  break;\n                }\n                responseLine = _step.value;\n                if (subRespHeaderStartFound) {\n                  _context.next = 31;\n                  break;\n                }\n                // Convention line to indicate content ID\n                if (responseLine.startsWith(HeaderConstants.CONTENT_ID)) {\n                  contentId = parseInt(responseLine.split(HTTP_HEADER_DELIMITER)[1]);\n                }\n                // Http version line with status code indicates the start of sub request's response.\n                // Example: HTTP/1.1 202 Accepted\n                if (responseLine.startsWith(HTTP_VERSION_1_1)) {\n                  subRespHeaderStartFound = true;\n                  tokens = responseLine.split(SPACE_DELIMITER);\n                  deserializedSubResponse.status = parseInt(tokens[1]);\n                  deserializedSubResponse.statusMessage = tokens.slice(2).join(SPACE_DELIMITER);\n                }\n                return _context.abrupt(\"continue\", 44);\n              case 31:\n                if (!(responseLine.trim() === \"\")) {\n                  _context.next = 34;\n                  break;\n                }\n                // Sub response's header start line already found, and the first empty line indicates header end line found.\n                if (!subRespHeaderEndFound) {\n                  subRespHeaderEndFound = true;\n                }\n                return _context.abrupt(\"continue\", 44);\n              case 34:\n                if (subRespHeaderEndFound) {\n                  _context.next = 42;\n                  break;\n                }\n                if (!(responseLine.indexOf(HTTP_HEADER_DELIMITER) === -1)) {\n                  _context.next = 37;\n                  break;\n                }\n                throw new Error(\"Invalid state: find non-empty line '\".concat(responseLine, \"' without HTTP header delimiter '\").concat(HTTP_HEADER_DELIMITER, \"'.\"));\n              case 37:\n                // Parse headers of sub response.\n                _tokens = responseLine.split(HTTP_HEADER_DELIMITER);\n                deserializedSubResponse.headers.set(_tokens[0], _tokens[1]);\n                if (_tokens[0] === HeaderConstants.X_MS_ERROR_CODE) {\n                  deserializedSubResponse.errorCode = _tokens[1];\n                  subRespFailed = true;\n                }\n                _context.next = 44;\n                break;\n              case 42:\n                // Assemble body of sub response.\n                if (!deserializedSubResponse.bodyAsText) {\n                  deserializedSubResponse.bodyAsText = \"\";\n                }\n                deserializedSubResponse.bodyAsText += responseLine;\n              case 44:\n                _context.next = 25;\n                break;\n              case 46:\n                _context.next = 51;\n                break;\n              case 48:\n                _context.prev = 48;\n                _context.t0 = _context[\"catch\"](23);\n                _iterator.e(_context.t0);\n              case 51:\n                _context.prev = 51;\n                _iterator.f();\n                return _context.finish(51);\n              case 54:\n                // Inner for end\n                // The response will contain the Content-ID header for each corresponding subrequest response to use for tracking.\n                // The Content-IDs are set to a valid index in the subrequests we sent. In the status code 202 path, we could expect it\n                // to be 1-1 mapping from the [0, subRequests.size) to the Content-IDs returned. If not, we simply don't return that\n                // unexpected subResponse in the parsed reponse and we can always look it up in the raw response for debugging purpose.\n                if (contentId !== NOT_FOUND && Number.isInteger(contentId) && contentId >= 0 && contentId < this.subRequests.size && deserializedSubResponses[contentId] === undefined) {\n                  deserializedSubResponse._request = this.subRequests.get(contentId);\n                  deserializedSubResponses[contentId] = deserializedSubResponse;\n                } else {\n                  logger.error(\"subResponses[\".concat(index, \"] is dropped as the Content-ID is not found or invalid, Content-ID: \").concat(contentId));\n                }\n                if (subRespFailed) {\n                  subResponsesFailedCount++;\n                } else {\n                  subResponsesSucceededCount++;\n                }\n              case 56:\n                index++;\n                _context.next = 13;\n                break;\n              case 59:\n                return _context.abrupt(\"return\", {\n                  subResponses: deserializedSubResponses,\n                  subResponsesSucceededCount: subResponsesSucceededCount,\n                  subResponsesFailedCount: subResponsesFailedCount\n                });\n              case 60:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[23, 48, 51, 54]]);\n      }));\n      function parseBatchResponse() {\n        return _parseBatchResponse.apply(this, arguments);\n      }\n      return parseBatchResponse;\n    }()\n  }]);\n  return BatchResponseParser;\n}();","map":{"version":3,"mappings":";;;;+CACA;AADA;AACA;AAEA,SAASA,WAAW,QAAQ,kBAAkB;AAG9C,SACEC,gBAAgB,EAChBC,gBAAgB,EAChBC,eAAe,EACfC,iBAAiB,QACZ,mBAAmB;AAC1B,SAASC,aAAa,QAAQ,cAAc;AAG5C,SAASC,MAAM,QAAQ,OAAO;AAE9B,IAAMC,qBAAqB,GAAG,IAAI;AAClC,IAAMC,eAAe,GAAG,GAAG;AAC3B,IAAMC,SAAS,GAAG,CAAC,CAAC;AAEpB;;;AAGA,WAAaC,mBAAmB;EAO9B,6BACEC,aAA8C,EAC9CC,WAAyC;IAAA;IAEzC,IAAI,CAACD,aAAa,IAAI,CAACA,aAAa,CAACE,WAAW,EAAE;MAChD;MACA,MAAM,IAAIC,UAAU,CAAC,mEAAmE,CAAC;;IAG3F,IAAI,CAACF,WAAW,IAAIA,WAAW,CAACG,IAAI,KAAK,CAAC,EAAE;MAC1C;MACA,MAAM,IAAID,UAAU,CAAC,0DAA0D,CAAC;;IAGlF,IAAI,CAACH,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACC,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACI,qBAAqB,GAAG,IAAI,CAACL,aAAa,CAACE,WAAY,CAACI,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;IAC1E,IAAI,CAACC,iBAAiB,eAAQ,IAAI,CAACF,qBAAqB,SAAGd,gBAAgB,CAAE;IAC7E,IAAI,CAACiB,mBAAmB,eAAQ,IAAI,CAACH,qBAAqB,OAAI;EAChE;EAEA;EAAA;IAAA;IAAA;MAAA,qFACO;QAAA;QAAA;UAAA;YAAA;cAAA;gBAAA,MAGD,IAAI,CAACL,aAAa,CAACS,SAAS,CAACC,MAAM,KAAKjB,iBAAiB,CAACkB,aAAa;kBAAA;kBAAA;gBAAA;gBAAA,MACnE,IAAIC,KAAK,6DACwC,IAAI,CAACZ,aAAa,CAACS,SAAS,CAACC,MAAM,QACzF;cAAA;gBAAA;gBAAA,OAG8BhB,aAAa,CAAC,IAAI,CAACM,aAAa,CAAC;cAAA;gBAA5Da,kBAAkB;gBAElBC,YAAY,GAAGD,kBAAkB,CACpCP,KAAK,CAAC,IAAI,CAACE,mBAAmB,CAAC,CAAC,CAAC,CAAC,CAAC;gBAAA,CACnCF,KAAK,CAAC,IAAI,CAACC,iBAAiB,CAAC,CAC7BQ,KAAK,CAAC,CAAC,CAAC,EAAE;gBACPC,gBAAgB,GAAGF,YAAY,CAACG,MAAM,EAE5C;gBACA;gBACA;gBACA;gBAAA,MACID,gBAAgB,KAAK,IAAI,CAACf,WAAW,CAACG,IAAI,IAAIY,gBAAgB,KAAK,CAAC;kBAAA;kBAAA;gBAAA;gBAAA,MAChE,IAAIJ,KAAK,CAAC,0EAA0E,CAAC;cAAA;gBAGvFM,wBAAwB,GAA4B,IAAIC,KAAK,CAACH,gBAAgB,CAAC;gBACjFI,0BAA0B,GAAW,CAAC;gBACtCC,uBAAuB,GAAW,CAAC,EAEvC;gBACSC,KAAK,GAAG,CAAC;cAAA;gBAAA,MAAEA,KAAK,GAAGN,gBAAgB;kBAAA;kBAAA;gBAAA;gBACpCO,WAAW,GAAGT,YAAY,CAACQ,KAAK,CAAC;gBACjCE,uBAAuB,GAAG,EAAsB;gBACtDA,uBAAuB,CAACC,OAAO,GAAG,IAAIpC,WAAW,EAAE;gBAE7CqC,aAAa,GAAGH,WAAW,CAACjB,KAAK,WAAIf,gBAAgB,EAAG;gBAC1DoC,uBAAuB,GAAG,KAAK;gBAC/BC,qBAAqB,GAAG,KAAK;gBAC7BC,aAAa,GAAG,KAAK;gBACrBC,SAAS,GAAGhC,SAAS;gBAAA,uCAEE4B,aAAa;gBAAA;gBAAA;cAAA;gBAAA;kBAAA;kBAAA;gBAAA;gBAA7BK,YAAY;gBAAA,IAChBJ,uBAAuB;kBAAA;kBAAA;gBAAA;gBAC1B;gBACA,IAAII,YAAY,CAACC,UAAU,CAACxC,eAAe,CAACyC,UAAU,CAAC,EAAE;kBACvDH,SAAS,GAAGI,QAAQ,CAACH,YAAY,CAACzB,KAAK,CAACV,qBAAqB,CAAC,CAAC,CAAC,CAAC,CAAC;;gBAGpE;gBACA;gBACA,IAAImC,YAAY,CAACC,UAAU,CAAC1C,gBAAgB,CAAC,EAAE;kBAC7CqC,uBAAuB,GAAG,IAAI;kBAExBQ,MAAM,GAAGJ,YAAY,CAACzB,KAAK,CAACT,eAAe,CAAC;kBAClD2B,uBAAuB,CAACd,MAAM,GAAGwB,QAAQ,CAACC,MAAM,CAAC,CAAC,CAAC,CAAC;kBACpDX,uBAAuB,CAACY,aAAa,GAAGD,MAAM,CAACpB,KAAK,CAAC,CAAC,CAAC,CAACsB,IAAI,CAACxC,eAAe,CAAC;;gBAC9E;cAAA;gBAAA,MAKCkC,YAAY,CAACO,IAAI,EAAE,KAAK,EAAE;kBAAA;kBAAA;gBAAA;gBAC5B;gBACA,IAAI,CAACV,qBAAqB,EAAE;kBAC1BA,qBAAqB,GAAG,IAAI;;gBAC7B;cAAA;gBAAA,IAMEA,qBAAqB;kBAAA;kBAAA;gBAAA;gBAAA,MACpBG,YAAY,CAACQ,OAAO,CAAC3C,qBAAqB,CAAC,KAAK,CAAC,CAAC;kBAAA;kBAAA;gBAAA;gBAAA,MAE9C,IAAIgB,KAAK,+CAC0BmB,YAAY,8CAAoCnC,qBAAqB,QAC7G;cAAA;gBAGH;gBACMuC,OAAM,GAAGJ,YAAY,CAACzB,KAAK,CAACV,qBAAqB,CAAC;gBACxD4B,uBAAuB,CAACC,OAAO,CAACe,GAAG,CAACL,OAAM,CAAC,CAAC,CAAC,EAAEA,OAAM,CAAC,CAAC,CAAC,CAAC;gBACzD,IAAIA,OAAM,CAAC,CAAC,CAAC,KAAK3C,eAAe,CAACiD,eAAe,EAAE;kBACjDjB,uBAAuB,CAACkB,SAAS,GAAGP,OAAM,CAAC,CAAC,CAAC;kBAC7CN,aAAa,GAAG,IAAI;;gBACrB;gBAAA;cAAA;gBAED;gBACA,IAAI,CAACL,uBAAuB,CAACmB,UAAU,EAAE;kBACvCnB,uBAAuB,CAACmB,UAAU,GAAG,EAAE;;gBAGzCnB,uBAAuB,CAACmB,UAAU,IAAIZ,YAAY;cAAC;gBAAA;gBAAA;cAAA;gBAAA;gBAAA;cAAA;gBAAA;gBAAA;gBAAA;cAAA;gBAAA;gBAAA;gBAAA;cAAA;gBAErD;gBAEF;gBACA;gBACA;gBACA;gBACA,IACED,SAAS,KAAKhC,SAAS,IACvB8C,MAAM,CAACC,SAAS,CAACf,SAAS,CAAC,IAC3BA,SAAS,IAAI,CAAC,IACdA,SAAS,GAAG,IAAI,CAAC7B,WAAW,CAACG,IAAI,IACjCc,wBAAwB,CAACY,SAAS,CAAC,KAAKgB,SAAS,EACjD;kBACAtB,uBAAuB,CAACuB,QAAQ,GAAG,IAAI,CAAC9C,WAAW,CAAC+C,GAAG,CAAClB,SAAS,CAAE;kBACnEZ,wBAAwB,CAACY,SAAS,CAAC,GAAGN,uBAAuB;iBAC9D,MAAM;kBACL7B,MAAM,CAACsD,KAAK,wBACM3B,KAAK,iFAAuEQ,SAAS,EACtG;;gBAGH,IAAID,aAAa,EAAE;kBACjBR,uBAAuB,EAAE;iBAC1B,MAAM;kBACLD,0BAA0B,EAAE;;cAC7B;gBAzF2CE,KAAK,EAAE;gBAAA;gBAAA;cAAA;gBAAA,iCA4F9C;kBACLR,YAAY,EAAEI,wBAAwB;kBACtCE,0BAA0B,EAAEA,0BAA0B;kBACtDC,uBAAuB,EAAEA;iBAC1B;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CACF;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;EAAA;AAAA","names":["HttpHeaders","HTTP_VERSION_1_1","HTTP_LINE_ENDING","HeaderConstants","HTTPURLConnection","getBodyAsText","logger","HTTP_HEADER_DELIMITER","SPACE_DELIMITER","NOT_FOUND","BatchResponseParser","batchResponse","subRequests","contentType","RangeError","size","responseBatchBoundary","split","perResponsePrefix","batchResponseEnding","_response","status","HTTP_ACCEPTED","Error","responseBodyAsText","subResponses","slice","subResponseCount","length","deserializedSubResponses","Array","subResponsesSucceededCount","subResponsesFailedCount","index","subResponse","deserializedSubResponse","headers","responseLines","subRespHeaderStartFound","subRespHeaderEndFound","subRespFailed","contentId","responseLine","startsWith","CONTENT_ID","parseInt","tokens","statusMessage","join","trim","indexOf","set","X_MS_ERROR_CODE","errorCode","bodyAsText","Number","isInteger","undefined","_request","get","error"],"sourceRoot":"","sources":["../../../src/BatchResponseParser.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { HttpHeaders } from \"@azure/core-http\";\n\nimport { ServiceSubmitBatchResponseModel } from \"./generatedModels\";\nimport {\n  HTTP_VERSION_1_1,\n  HTTP_LINE_ENDING,\n  HeaderConstants,\n  HTTPURLConnection,\n} from \"./utils/constants\";\nimport { getBodyAsText } from \"./BatchUtils\";\nimport { BatchSubRequest } from \"./BlobBatch\";\nimport { BatchSubResponse, ParsedBatchResponse } from \"./BatchResponse\";\nimport { logger } from \"./log\";\n\nconst HTTP_HEADER_DELIMITER = \": \";\nconst SPACE_DELIMITER = \" \";\nconst NOT_FOUND = -1;\n\n/**\n * Util class for parsing batch response.\n */\nexport class BatchResponseParser {\n  private readonly batchResponse: ServiceSubmitBatchResponseModel;\n  private readonly responseBatchBoundary: string;\n  private readonly perResponsePrefix: string;\n  private readonly batchResponseEnding: string;\n  private readonly subRequests: Map<number, BatchSubRequest>;\n\n  constructor(\n    batchResponse: ServiceSubmitBatchResponseModel,\n    subRequests: Map<number, BatchSubRequest>\n  ) {\n    if (!batchResponse || !batchResponse.contentType) {\n      // In special case(reported), server may return invalid content-type which could not be parsed.\n      throw new RangeError(\"batchResponse is malformed or doesn't contain valid content-type.\");\n    }\n\n    if (!subRequests || subRequests.size === 0) {\n      // This should be prevent during coding.\n      throw new RangeError(\"Invalid state: subRequests is not provided or size is 0.\");\n    }\n\n    this.batchResponse = batchResponse;\n    this.subRequests = subRequests;\n    this.responseBatchBoundary = this.batchResponse.contentType!.split(\"=\")[1];\n    this.perResponsePrefix = `--${this.responseBatchBoundary}${HTTP_LINE_ENDING}`;\n    this.batchResponseEnding = `--${this.responseBatchBoundary}--`;\n  }\n\n  // For example of response, please refer to https://docs.microsoft.com/en-us/rest/api/storageservices/blob-batch#response\n  public async parseBatchResponse(): Promise<ParsedBatchResponse> {\n    // When logic reach here, suppose batch request has already succeeded with 202, so we can further parse\n    // sub request's response.\n    if (this.batchResponse._response.status !== HTTPURLConnection.HTTP_ACCEPTED) {\n      throw new Error(\n        `Invalid state: batch request failed with status: '${this.batchResponse._response.status}'.`\n      );\n    }\n\n    const responseBodyAsText = await getBodyAsText(this.batchResponse);\n\n    const subResponses = responseBodyAsText\n      .split(this.batchResponseEnding)[0] // string after ending is useless\n      .split(this.perResponsePrefix)\n      .slice(1); // string before first response boundary is useless\n    const subResponseCount = subResponses.length;\n\n    // Defensive coding in case of potential error parsing.\n    // Note: subResponseCount == 1 is special case where sub request is invalid.\n    // We try to prevent such cases through early validation, e.g. validate sub request count >= 1.\n    // While in unexpected sub request invalid case, we allow sub response to be parsed and return to user.\n    if (subResponseCount !== this.subRequests.size && subResponseCount !== 1) {\n      throw new Error(\"Invalid state: sub responses' count is not equal to sub requests' count.\");\n    }\n\n    const deserializedSubResponses: Array<BatchSubResponse> = new Array(subResponseCount);\n    let subResponsesSucceededCount: number = 0;\n    let subResponsesFailedCount: number = 0;\n\n    // Parse sub subResponses.\n    for (let index = 0; index < subResponseCount; index++) {\n      const subResponse = subResponses[index];\n      const deserializedSubResponse = {} as BatchSubResponse;\n      deserializedSubResponse.headers = new HttpHeaders();\n\n      const responseLines = subResponse.split(`${HTTP_LINE_ENDING}`);\n      let subRespHeaderStartFound = false;\n      let subRespHeaderEndFound = false;\n      let subRespFailed = false;\n      let contentId = NOT_FOUND;\n\n      for (const responseLine of responseLines) {\n        if (!subRespHeaderStartFound) {\n          // Convention line to indicate content ID\n          if (responseLine.startsWith(HeaderConstants.CONTENT_ID)) {\n            contentId = parseInt(responseLine.split(HTTP_HEADER_DELIMITER)[1]);\n          }\n\n          // Http version line with status code indicates the start of sub request's response.\n          // Example: HTTP/1.1 202 Accepted\n          if (responseLine.startsWith(HTTP_VERSION_1_1)) {\n            subRespHeaderStartFound = true;\n\n            const tokens = responseLine.split(SPACE_DELIMITER);\n            deserializedSubResponse.status = parseInt(tokens[1]);\n            deserializedSubResponse.statusMessage = tokens.slice(2).join(SPACE_DELIMITER);\n          }\n\n          continue; // Skip convention headers not specifically for sub request i.e. Content-Type: application/http and Content-ID: *\n        }\n\n        if (responseLine.trim() === \"\") {\n          // Sub response's header start line already found, and the first empty line indicates header end line found.\n          if (!subRespHeaderEndFound) {\n            subRespHeaderEndFound = true;\n          }\n\n          continue; // Skip empty line\n        }\n\n        // Note: when code reach here, it indicates subRespHeaderStartFound == true\n        if (!subRespHeaderEndFound) {\n          if (responseLine.indexOf(HTTP_HEADER_DELIMITER) === -1) {\n            // Defensive coding to prevent from missing valuable lines.\n            throw new Error(\n              `Invalid state: find non-empty line '${responseLine}' without HTTP header delimiter '${HTTP_HEADER_DELIMITER}'.`\n            );\n          }\n\n          // Parse headers of sub response.\n          const tokens = responseLine.split(HTTP_HEADER_DELIMITER);\n          deserializedSubResponse.headers.set(tokens[0], tokens[1]);\n          if (tokens[0] === HeaderConstants.X_MS_ERROR_CODE) {\n            deserializedSubResponse.errorCode = tokens[1];\n            subRespFailed = true;\n          }\n        } else {\n          // Assemble body of sub response.\n          if (!deserializedSubResponse.bodyAsText) {\n            deserializedSubResponse.bodyAsText = \"\";\n          }\n\n          deserializedSubResponse.bodyAsText += responseLine;\n        }\n      } // Inner for end\n\n      // The response will contain the Content-ID header for each corresponding subrequest response to use for tracking.\n      // The Content-IDs are set to a valid index in the subrequests we sent. In the status code 202 path, we could expect it\n      // to be 1-1 mapping from the [0, subRequests.size) to the Content-IDs returned. If not, we simply don't return that\n      // unexpected subResponse in the parsed reponse and we can always look it up in the raw response for debugging purpose.\n      if (\n        contentId !== NOT_FOUND &&\n        Number.isInteger(contentId) &&\n        contentId >= 0 &&\n        contentId < this.subRequests.size &&\n        deserializedSubResponses[contentId] === undefined\n      ) {\n        deserializedSubResponse._request = this.subRequests.get(contentId)!;\n        deserializedSubResponses[contentId] = deserializedSubResponse;\n      } else {\n        logger.error(\n          `subResponses[${index}] is dropped as the Content-ID is not found or invalid, Content-ID: ${contentId}`\n        );\n      }\n\n      if (subRespFailed) {\n        subResponsesFailedCount++;\n      } else {\n        subResponsesSucceededCount++;\n      }\n    }\n\n    return {\n      subResponses: deserializedSubResponses,\n      subResponsesSucceededCount: subResponsesSucceededCount,\n      subResponsesFailedCount: subResponsesFailedCount,\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}