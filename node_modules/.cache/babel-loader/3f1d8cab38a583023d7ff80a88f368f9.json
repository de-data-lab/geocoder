{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { AbortController } from \"@azure/abort-controller\";\nimport { deserializeState, initOperation, pollOperation } from \"./operation\";\nimport { POLL_INTERVAL_IN_MS } from \"./constants\";\nimport { delayMs } from \"./util/delayMs\";\nconst createStateProxy = () => ({\n  /**\n   * The state at this point is created to be of type OperationState<TResult>.\n   * It will be updated later to be of type TState when the\n   * customer-provided callback, `updateState`, is called during polling.\n   */\n  initState: config => ({\n    status: \"running\",\n    config\n  }),\n  setCanceled: state => state.status = \"canceled\",\n  setError: (state, error) => state.error = error,\n  setResult: (state, result) => state.result = result,\n  setRunning: state => state.status = \"running\",\n  setSucceeded: state => state.status = \"succeeded\",\n  setFailed: state => state.status = \"failed\",\n  getError: state => state.error,\n  getResult: state => state.result,\n  isCanceled: state => state.status === \"canceled\",\n  isFailed: state => state.status === \"failed\",\n  isRunning: state => state.status === \"running\",\n  isSucceeded: state => state.status === \"succeeded\"\n});\n/**\n * Returns a poller factory.\n */\nexport function buildCreatePoller(inputs) {\n  const {\n    getOperationLocation,\n    getStatusFromInitialResponse,\n    getStatusFromPollResponse,\n    getResourceLocation,\n    getPollingInterval,\n    resolveOnUnsuccessful\n  } = inputs;\n  return async (_ref, options) => {\n    let {\n      init,\n      poll\n    } = _ref;\n    const {\n      processResult,\n      updateState,\n      withOperationLocation: withOperationLocationCallback,\n      intervalInMs = POLL_INTERVAL_IN_MS,\n      restoreFrom\n    } = options || {};\n    const stateProxy = createStateProxy();\n    const withOperationLocation = withOperationLocationCallback ? (() => {\n      let called = false;\n      return (operationLocation, isUpdated) => {\n        if (isUpdated) withOperationLocationCallback(operationLocation);else if (!called) withOperationLocationCallback(operationLocation);\n        called = true;\n      };\n    })() : undefined;\n    const state = restoreFrom ? deserializeState(restoreFrom) : await initOperation({\n      init,\n      stateProxy,\n      processResult,\n      getOperationStatus: getStatusFromInitialResponse,\n      withOperationLocation,\n      setErrorAsResult: !resolveOnUnsuccessful\n    });\n    let resultPromise;\n    let cancelJob;\n    const abortController = new AbortController();\n    const handlers = new Map();\n    const handleProgressEvents = async () => handlers.forEach(h => h(state));\n    let currentPollIntervalInMs = intervalInMs;\n    const poller = {\n      getOperationState: () => state,\n      getResult: () => state.result,\n      isDone: () => [\"succeeded\", \"failed\", \"canceled\"].includes(state.status),\n      isStopped: () => resultPromise === undefined,\n      stopPolling: () => {\n        abortController.abort();\n        cancelJob === null || cancelJob === void 0 ? void 0 : cancelJob();\n      },\n      toString: () => JSON.stringify({\n        state\n      }),\n      onProgress: callback => {\n        const s = Symbol();\n        handlers.set(s, callback);\n        return () => handlers.delete(s);\n      },\n      pollUntilDone: pollOptions => resultPromise !== null && resultPromise !== void 0 ? resultPromise : resultPromise = (async () => {\n        const {\n          abortSignal: inputAbortSignal\n        } = pollOptions || {};\n        const {\n          signal: abortSignal\n        } = inputAbortSignal ? new AbortController([inputAbortSignal, abortController.signal]) : abortController;\n        if (!poller.isDone()) {\n          await poller.poll({\n            abortSignal\n          });\n          while (!poller.isDone()) {\n            const delay = delayMs(currentPollIntervalInMs);\n            cancelJob = delay.cancel;\n            await delay;\n            await poller.poll({\n              abortSignal\n            });\n          }\n        }\n        switch (state.status) {\n          case \"succeeded\":\n            {\n              return poller.getResult();\n            }\n          case \"canceled\":\n            {\n              if (!resolveOnUnsuccessful) throw new Error(\"Operation was canceled\");\n              return poller.getResult();\n            }\n          case \"failed\":\n            {\n              if (!resolveOnUnsuccessful) throw state.error;\n              return poller.getResult();\n            }\n          case \"notStarted\":\n          case \"running\":\n            {\n              // Unreachable\n              throw new Error(`polling completed without succeeding or failing`);\n            }\n        }\n      })().finally(() => {\n        resultPromise = undefined;\n      }),\n      async poll(pollOptions) {\n        await pollOperation({\n          poll,\n          state,\n          stateProxy,\n          getOperationLocation,\n          withOperationLocation,\n          getPollingInterval,\n          getOperationStatus: getStatusFromPollResponse,\n          getResourceLocation,\n          processResult,\n          updateState,\n          options: pollOptions,\n          setDelay: pollIntervalInMs => {\n            currentPollIntervalInMs = pollIntervalInMs;\n          },\n          setErrorAsResult: !resolveOnUnsuccessful\n        });\n        await handleProgressEvents();\n        if (state.status === \"canceled\" && !resolveOnUnsuccessful) {\n          throw new Error(\"Operation was canceled\");\n        }\n        if (state.status === \"failed\" && !resolveOnUnsuccessful) {\n          throw state.error;\n        }\n      }\n    };\n    return poller;\n  };\n}","map":{"version":3,"mappings":"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","names":["AbortController","deserializeState","initOperation","pollOperation","POLL_INTERVAL_IN_MS","delayMs","createStateProxy","initState","config","status","setCanceled","state","setError","error","setResult","result","setRunning","setSucceeded","setFailed","getError","getResult","isCanceled","isFailed","isRunning","isSucceeded","buildCreatePoller","inputs","getOperationLocation","getStatusFromInitialResponse","getStatusFromPollResponse","getResourceLocation","getPollingInterval","resolveOnUnsuccessful","options","init","poll","processResult","updateState","withOperationLocation","withOperationLocationCallback","intervalInMs","restoreFrom","stateProxy","called","operationLocation","isUpdated","undefined","getOperationStatus","setErrorAsResult","resultPromise","cancelJob","abortController","handlers","Map","handleProgressEvents","forEach","h","currentPollIntervalInMs","poller","getOperationState","isDone","includes","isStopped","stopPolling","abort","toString","JSON","stringify","onProgress","callback","s","Symbol","set","delete","pollUntilDone","pollOptions","abortSignal","inputAbortSignal","signal","delay","cancel","Error","finally","setDelay","pollIntervalInMs"],"sourceRoot":"","sources":["../../../src/poller/poller.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortController, AbortSignalLike } from \"@azure/abort-controller\";\nimport {\n  BuildCreatePollerOptions,\n  CreatePollerOptions,\n  Operation,\n  OperationState,\n  RestorableOperationState,\n  SimplePollerLike,\n  StateProxy,\n} from \"./models\";\nimport { deserializeState, initOperation, pollOperation } from \"./operation\";\nimport { POLL_INTERVAL_IN_MS } from \"./constants\";\nimport { delayMs } from \"./util/delayMs\";\n\nconst createStateProxy: <TResult, TState extends OperationState<TResult>>() => StateProxy<\n  TState,\n  TResult\n> = () => ({\n  /**\n   * The state at this point is created to be of type OperationState<TResult>.\n   * It will be updated later to be of type TState when the\n   * customer-provided callback, `updateState`, is called during polling.\n   */\n  initState: (config) => ({ status: \"running\", config } as any),\n  setCanceled: (state) => (state.status = \"canceled\"),\n  setError: (state, error) => (state.error = error),\n  setResult: (state, result) => (state.result = result),\n  setRunning: (state) => (state.status = \"running\"),\n  setSucceeded: (state) => (state.status = \"succeeded\"),\n  setFailed: (state) => (state.status = \"failed\"),\n\n  getError: (state) => state.error,\n  getResult: (state) => state.result,\n  isCanceled: (state) => state.status === \"canceled\",\n  isFailed: (state) => state.status === \"failed\",\n  isRunning: (state) => state.status === \"running\",\n  isSucceeded: (state) => state.status === \"succeeded\",\n});\n\n/**\n * Returns a poller factory.\n */\nexport function buildCreatePoller<TResponse, TResult, TState extends OperationState<TResult>>(\n  inputs: BuildCreatePollerOptions<TResponse, TState>\n): (\n  lro: Operation<TResponse, { abortSignal?: AbortSignalLike }>,\n  options?: CreatePollerOptions<TResponse, TResult, TState>\n) => Promise<SimplePollerLike<TState, TResult>> {\n  const {\n    getOperationLocation,\n    getStatusFromInitialResponse,\n    getStatusFromPollResponse,\n    getResourceLocation,\n    getPollingInterval,\n    resolveOnUnsuccessful,\n  } = inputs;\n  return async (\n    { init, poll }: Operation<TResponse, { abortSignal?: AbortSignalLike }>,\n    options?: CreatePollerOptions<TResponse, TResult, TState>\n  ) => {\n    const {\n      processResult,\n      updateState,\n      withOperationLocation: withOperationLocationCallback,\n      intervalInMs = POLL_INTERVAL_IN_MS,\n      restoreFrom,\n    } = options || {};\n    const stateProxy = createStateProxy<TResult, TState>();\n    const withOperationLocation = withOperationLocationCallback\n      ? (() => {\n          let called = false;\n          return (operationLocation: string, isUpdated: boolean) => {\n            if (isUpdated) withOperationLocationCallback(operationLocation);\n            else if (!called) withOperationLocationCallback(operationLocation);\n            called = true;\n          };\n        })()\n      : undefined;\n    const state: RestorableOperationState<TState> = restoreFrom\n      ? deserializeState(restoreFrom)\n      : await initOperation({\n          init,\n          stateProxy,\n          processResult,\n          getOperationStatus: getStatusFromInitialResponse,\n          withOperationLocation,\n          setErrorAsResult: !resolveOnUnsuccessful,\n        });\n    let resultPromise: Promise<TResult> | undefined;\n    let cancelJob: (() => void) | undefined;\n    const abortController = new AbortController();\n    // Progress handlers\n    type Handler = (state: TState) => void;\n    const handlers = new Map<symbol, Handler>();\n    const handleProgressEvents = async (): Promise<void> => handlers.forEach((h) => h(state));\n\n    let currentPollIntervalInMs = intervalInMs;\n\n    const poller: SimplePollerLike<TState, TResult> = {\n      getOperationState: () => state,\n      getResult: () => state.result,\n      isDone: () => [\"succeeded\", \"failed\", \"canceled\"].includes(state.status),\n      isStopped: () => resultPromise === undefined,\n      stopPolling: () => {\n        abortController.abort();\n        cancelJob?.();\n      },\n      toString: () =>\n        JSON.stringify({\n          state,\n        }),\n      onProgress: (callback: (state: TState) => void) => {\n        const s = Symbol();\n        handlers.set(s, callback);\n        return () => handlers.delete(s);\n      },\n      pollUntilDone: (pollOptions?: { abortSignal?: AbortSignalLike }) =>\n        (resultPromise ??= (async () => {\n          const { abortSignal: inputAbortSignal } = pollOptions || {};\n          const { signal: abortSignal } = inputAbortSignal\n            ? new AbortController([inputAbortSignal, abortController.signal])\n            : abortController;\n          if (!poller.isDone()) {\n            await poller.poll({ abortSignal });\n            while (!poller.isDone()) {\n              const delay = delayMs(currentPollIntervalInMs);\n              cancelJob = delay.cancel;\n              await delay;\n              await poller.poll({ abortSignal });\n            }\n          }\n          switch (state.status) {\n            case \"succeeded\": {\n              return poller.getResult() as TResult;\n            }\n            case \"canceled\": {\n              if (!resolveOnUnsuccessful) throw new Error(\"Operation was canceled\");\n              return poller.getResult() as TResult;\n            }\n            case \"failed\": {\n              if (!resolveOnUnsuccessful) throw state.error;\n              return poller.getResult() as TResult;\n            }\n            case \"notStarted\":\n            case \"running\": {\n              // Unreachable\n              throw new Error(`polling completed without succeeding or failing`);\n            }\n          }\n        })().finally(() => {\n          resultPromise = undefined;\n        })),\n      async poll(pollOptions?: { abortSignal?: AbortSignalLike }): Promise<void> {\n        await pollOperation({\n          poll,\n          state,\n          stateProxy,\n          getOperationLocation,\n          withOperationLocation,\n          getPollingInterval,\n          getOperationStatus: getStatusFromPollResponse,\n          getResourceLocation,\n          processResult,\n          updateState,\n          options: pollOptions,\n          setDelay: (pollIntervalInMs) => {\n            currentPollIntervalInMs = pollIntervalInMs;\n          },\n          setErrorAsResult: !resolveOnUnsuccessful,\n        });\n        await handleProgressEvents();\n        if (state.status === \"canceled\" && !resolveOnUnsuccessful) {\n          throw new Error(\"Operation was canceled\");\n        }\n        if (state.status === \"failed\" && !resolveOnUnsuccessful) {\n          throw state.error;\n        }\n      },\n    };\n    return poller;\n  };\n}\n"]},"metadata":{},"sourceType":"module"}