{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n// In browser, during webpack or browserify bundling, this module will be replaced by 'events'\n// https://github.com/Gozala/events\nimport { EventEmitter } from \"events\";\n/**\n * States for Batch.\n */\nvar BatchStates;\n(function (BatchStates) {\n  BatchStates[BatchStates[\"Good\"] = 0] = \"Good\";\n  BatchStates[BatchStates[\"Error\"] = 1] = \"Error\";\n})(BatchStates || (BatchStates = {}));\n/**\n * Batch provides basic parallel execution with concurrency limits.\n * Will stop execute left operations when one of the executed operation throws an error.\n * But Batch cannot cancel ongoing operations, you need to cancel them by yourself.\n */\nexport class Batch {\n  /**\n   * Creates an instance of Batch.\n   * @param concurrency -\n   */\n  constructor() {\n    let concurrency = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;\n    /**\n     * Number of active operations under execution.\n     */\n    this.actives = 0;\n    /**\n     * Number of completed operations under execution.\n     */\n    this.completed = 0;\n    /**\n     * Offset of next operation to be executed.\n     */\n    this.offset = 0;\n    /**\n     * Operation array to be executed.\n     */\n    this.operations = [];\n    /**\n     * States of Batch. When an error happens, state will turn into error.\n     * Batch will stop execute left operations.\n     */\n    this.state = BatchStates.Good;\n    if (concurrency < 1) {\n      throw new RangeError(\"concurrency must be larger than 0\");\n    }\n    this.concurrency = concurrency;\n    this.emitter = new EventEmitter();\n  }\n  /**\n   * Add a operation into queue.\n   *\n   * @param operation -\n   */\n  addOperation(operation) {\n    this.operations.push(async () => {\n      try {\n        this.actives++;\n        await operation();\n        this.actives--;\n        this.completed++;\n        this.parallelExecute();\n      } catch (error) {\n        this.emitter.emit(\"error\", error);\n      }\n    });\n  }\n  /**\n   * Start execute operations in the queue.\n   *\n   */\n  async do() {\n    if (this.operations.length === 0) {\n      return Promise.resolve();\n    }\n    this.parallelExecute();\n    return new Promise((resolve, reject) => {\n      this.emitter.on(\"finish\", resolve);\n      this.emitter.on(\"error\", error => {\n        this.state = BatchStates.Error;\n        reject(error);\n      });\n    });\n  }\n  /**\n   * Get next operation to be executed. Return null when reaching ends.\n   *\n   */\n  nextOperation() {\n    if (this.offset < this.operations.length) {\n      return this.operations[this.offset++];\n    }\n    return null;\n  }\n  /**\n   * Start execute operations. One one the most important difference between\n   * this method with do() is that do() wraps as an sync method.\n   *\n   */\n  parallelExecute() {\n    if (this.state === BatchStates.Error) {\n      return;\n    }\n    if (this.completed >= this.operations.length) {\n      this.emitter.emit(\"finish\");\n      return;\n    }\n    while (this.actives < this.concurrency) {\n      const operation = this.nextOperation();\n      if (operation) {\n        operation();\n      } else {\n        return;\n      }\n    }\n  }\n}","map":{"version":3,"mappings":"AAAA;AACA;AAEA;AACA;AACA,SAASA,YAAY,QAAQ,QAAQ;AAOrC;;;AAGA,IAAKC,WAGJ;AAHD,WAAKA,WAAW;EACdA,6CAAI;EACJA,+CAAK;AACP,CAAC,EAHIA,WAAW,KAAXA,WAAW;AAKhB;;;;;AAKA,OAAM,MAAOC,KAAK;EAqChB;;;;EAIAC,cAA0C;IAAA,IAAvBC,kFAAsB,CAAC;IAnC1C;;;IAGQ,YAAO,GAAW,CAAC;IAE3B;;;IAGQ,cAAS,GAAW,CAAC;IAE7B;;;IAGQ,WAAM,GAAW,CAAC;IAE1B;;;IAGQ,eAAU,GAAgB,EAAE;IAEpC;;;;IAIQ,UAAK,GAAgBH,WAAW,CAACI,IAAI;IAY3C,IAAID,WAAW,GAAG,CAAC,EAAE;MACnB,MAAM,IAAIE,UAAU,CAAC,mCAAmC,CAAC;;IAE3D,IAAI,CAACF,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACG,OAAO,GAAG,IAAIP,YAAY,EAAE;EACnC;EAEA;;;;;EAKOQ,YAAY,CAACC,SAAoB;IACtC,IAAI,CAACC,UAAU,CAACC,IAAI,CAAC,YAAW;MAC9B,IAAI;QACF,IAAI,CAACC,OAAO,EAAE;QACd,MAAMH,SAAS,EAAE;QACjB,IAAI,CAACG,OAAO,EAAE;QACd,IAAI,CAACC,SAAS,EAAE;QAChB,IAAI,CAACC,eAAe,EAAE;OACvB,CAAC,OAAOC,KAAU,EAAE;QACnB,IAAI,CAACR,OAAO,CAACS,IAAI,CAAC,OAAO,EAAED,KAAK,CAAC;;IAErC,CAAC,CAAC;EACJ;EAEA;;;;EAIO,MAAME,EAAE;IACb,IAAI,IAAI,CAACP,UAAU,CAACQ,MAAM,KAAK,CAAC,EAAE;MAChC,OAAOC,OAAO,CAACC,OAAO,EAAE;;IAG1B,IAAI,CAACN,eAAe,EAAE;IAEtB,OAAO,IAAIK,OAAO,CAAO,CAACC,OAAO,EAAEC,MAAM,KAAI;MAC3C,IAAI,CAACd,OAAO,CAACe,EAAE,CAAC,QAAQ,EAAEF,OAAO,CAAC;MAElC,IAAI,CAACb,OAAO,CAACe,EAAE,CAAC,OAAO,EAAGP,KAAK,IAAI;QACjC,IAAI,CAACQ,KAAK,GAAGtB,WAAW,CAACuB,KAAK;QAC9BH,MAAM,CAACN,KAAK,CAAC;MACf,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ;EAEA;;;;EAIQU,aAAa;IACnB,IAAI,IAAI,CAACC,MAAM,GAAG,IAAI,CAAChB,UAAU,CAACQ,MAAM,EAAE;MACxC,OAAO,IAAI,CAACR,UAAU,CAAC,IAAI,CAACgB,MAAM,EAAE,CAAC;;IAEvC,OAAO,IAAI;EACb;EAEA;;;;;EAKQZ,eAAe;IACrB,IAAI,IAAI,CAACS,KAAK,KAAKtB,WAAW,CAACuB,KAAK,EAAE;MACpC;;IAGF,IAAI,IAAI,CAACX,SAAS,IAAI,IAAI,CAACH,UAAU,CAACQ,MAAM,EAAE;MAC5C,IAAI,CAACX,OAAO,CAACS,IAAI,CAAC,QAAQ,CAAC;MAC3B;;IAGF,OAAO,IAAI,CAACJ,OAAO,GAAG,IAAI,CAACR,WAAW,EAAE;MACtC,MAAMK,SAAS,GAAG,IAAI,CAACgB,aAAa,EAAE;MACtC,IAAIhB,SAAS,EAAE;QACbA,SAAS,EAAE;OACZ,MAAM;QACL;;;EAGN","names":["EventEmitter","BatchStates","Batch","constructor","concurrency","Good","RangeError","emitter","addOperation","operation","operations","push","actives","completed","parallelExecute","error","emit","do","length","Promise","resolve","reject","on","state","Error","nextOperation","offset"],"sources":["/Users/yupenglei/Documents/geo-react/node_modules/@azure/storage-blob/src/utils/Batch.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n// In browser, during webpack or browserify bundling, this module will be replaced by 'events'\n// https://github.com/Gozala/events\nimport { EventEmitter } from \"events\";\n\n/**\n * Operation is an async function to be executed and managed by Batch.\n */\nexport declare type Operation = () => Promise<any>;\n\n/**\n * States for Batch.\n */\nenum BatchStates {\n  Good,\n  Error,\n}\n\n/**\n * Batch provides basic parallel execution with concurrency limits.\n * Will stop execute left operations when one of the executed operation throws an error.\n * But Batch cannot cancel ongoing operations, you need to cancel them by yourself.\n */\nexport class Batch {\n  /**\n   * Concurrency. Must be lager than 0.\n   */\n  private concurrency: number;\n\n  /**\n   * Number of active operations under execution.\n   */\n  private actives: number = 0;\n\n  /**\n   * Number of completed operations under execution.\n   */\n  private completed: number = 0;\n\n  /**\n   * Offset of next operation to be executed.\n   */\n  private offset: number = 0;\n\n  /**\n   * Operation array to be executed.\n   */\n  private operations: Operation[] = [];\n\n  /**\n   * States of Batch. When an error happens, state will turn into error.\n   * Batch will stop execute left operations.\n   */\n  private state: BatchStates = BatchStates.Good;\n\n  /**\n   * A private emitter used to pass events inside this class.\n   */\n  private emitter: EventEmitter;\n\n  /**\n   * Creates an instance of Batch.\n   * @param concurrency -\n   */\n  public constructor(concurrency: number = 5) {\n    if (concurrency < 1) {\n      throw new RangeError(\"concurrency must be larger than 0\");\n    }\n    this.concurrency = concurrency;\n    this.emitter = new EventEmitter();\n  }\n\n  /**\n   * Add a operation into queue.\n   *\n   * @param operation -\n   */\n  public addOperation(operation: Operation): void {\n    this.operations.push(async () => {\n      try {\n        this.actives++;\n        await operation();\n        this.actives--;\n        this.completed++;\n        this.parallelExecute();\n      } catch (error: any) {\n        this.emitter.emit(\"error\", error);\n      }\n    });\n  }\n\n  /**\n   * Start execute operations in the queue.\n   *\n   */\n  public async do(): Promise<void> {\n    if (this.operations.length === 0) {\n      return Promise.resolve();\n    }\n\n    this.parallelExecute();\n\n    return new Promise<void>((resolve, reject) => {\n      this.emitter.on(\"finish\", resolve);\n\n      this.emitter.on(\"error\", (error) => {\n        this.state = BatchStates.Error;\n        reject(error);\n      });\n    });\n  }\n\n  /**\n   * Get next operation to be executed. Return null when reaching ends.\n   *\n   */\n  private nextOperation(): Operation | null {\n    if (this.offset < this.operations.length) {\n      return this.operations[this.offset++];\n    }\n    return null;\n  }\n\n  /**\n   * Start execute operations. One one the most important difference between\n   * this method with do() is that do() wraps as an sync method.\n   *\n   */\n  private parallelExecute(): void {\n    if (this.state === BatchStates.Error) {\n      return;\n    }\n\n    if (this.completed >= this.operations.length) {\n      this.emitter.emit(\"finish\");\n      return;\n    }\n\n    while (this.actives < this.concurrency) {\n      const operation = this.nextOperation();\n      if (operation) {\n        operation();\n      } else {\n        return;\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}