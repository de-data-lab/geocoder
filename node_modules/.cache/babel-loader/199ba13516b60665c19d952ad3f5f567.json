{"ast":null,"code":"import _inherits from \"/Users/tbeckett/Documents/geo-react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/tbeckett/Documents/geo-react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _createForOfIteratorHelper from \"/Users/tbeckett/Documents/geo-react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _asyncToGenerator from \"/Users/tbeckett/Documents/geo-react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/tbeckett/Documents/geo-react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/tbeckett/Documents/geo-react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { BaseRequestPolicy, deserializationPolicy, generateUuid, HttpHeaders, WebResource, isTokenCredential, bearerTokenAuthenticationPolicy, isNode } from \"@azure/core-http\";\nimport { SpanStatusCode } from \"@azure/core-tracing\";\nimport { AnonymousCredential } from \"./credentials/AnonymousCredential\";\nimport { BlobClient } from \"./Clients\";\nimport { Mutex } from \"./utils/Mutex\";\nimport { Pipeline } from \"./Pipeline\";\nimport { attachCredential, getURLPath, getURLPathAndQuery, iEqual } from \"./utils/utils.common\";\nimport { HeaderConstants, BATCH_MAX_REQUEST, HTTP_VERSION_1_1, HTTP_LINE_ENDING, StorageOAuthScopes } from \"./utils/constants\";\nimport { StorageSharedKeyCredential } from \"./credentials/StorageSharedKeyCredential\";\nimport { createSpan } from \"./utils/tracing\";\n/**\n * A BlobBatch represents an aggregated set of operations on blobs.\n * Currently, only `delete` and `setAccessTier` are supported.\n */\nexport var BlobBatch = /*#__PURE__*/function () {\n  function BlobBatch() {\n    _classCallCheck(this, BlobBatch);\n    this.batch = \"batch\";\n    this.batchRequest = new InnerBatchRequest();\n  }\n  /**\n   * Get the value of Content-Type for a batch request.\n   * The value must be multipart/mixed with a batch boundary.\n   * Example: multipart/mixed; boundary=batch_a81786c8-e301-4e42-a729-a32ca24ae252\n   */\n  _createClass(BlobBatch, [{\n    key: \"getMultiPartContentType\",\n    value: function getMultiPartContentType() {\n      return this.batchRequest.getMultipartContentType();\n    }\n    /**\n     * Get assembled HTTP request body for sub requests.\n     */\n  }, {\n    key: \"getHttpRequestBody\",\n    value: function getHttpRequestBody() {\n      return this.batchRequest.getHttpRequestBody();\n    }\n    /**\n     * Get sub requests that are added into the batch request.\n     */\n  }, {\n    key: \"getSubRequests\",\n    value: function getSubRequests() {\n      return this.batchRequest.getSubRequests();\n    }\n  }, {\n    key: \"addSubRequestInternal\",\n    value: function () {\n      var _addSubRequestInternal = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(subRequest, assembleSubRequestFunc) {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return Mutex.lock(this.batch);\n              case 2:\n                _context.prev = 2;\n                this.batchRequest.preAddSubRequest(subRequest);\n                _context.next = 6;\n                return assembleSubRequestFunc();\n              case 6:\n                this.batchRequest.postAddSubRequest(subRequest);\n              case 7:\n                _context.prev = 7;\n                _context.next = 10;\n                return Mutex.unlock(this.batch);\n              case 10:\n                return _context.finish(7);\n              case 11:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[2,, 7, 11]]);\n      }));\n      function addSubRequestInternal(_x, _x2) {\n        return _addSubRequestInternal.apply(this, arguments);\n      }\n      return addSubRequestInternal;\n    }()\n  }, {\n    key: \"setBatchType\",\n    value: function setBatchType(batchType) {\n      if (!this.batchType) {\n        this.batchType = batchType;\n      }\n      if (this.batchType !== batchType) {\n        throw new RangeError(\"BlobBatch only supports one operation type per batch and it already is being used for \".concat(this.batchType, \" operations.\"));\n      }\n    }\n  }, {\n    key: \"deleteBlob\",\n    value: function () {\n      var _deleteBlob = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(urlOrBlobClient, credentialOrOptions, options) {\n        var _this = this;\n        var url, credential, _createSpan, span, updatedOptions;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!(typeof urlOrBlobClient === \"string\" && (isNode && credentialOrOptions instanceof StorageSharedKeyCredential || credentialOrOptions instanceof AnonymousCredential || isTokenCredential(credentialOrOptions)))) {\n                  _context3.next = 5;\n                  break;\n                }\n                // First overload\n                url = urlOrBlobClient;\n                credential = credentialOrOptions;\n                _context3.next = 12;\n                break;\n              case 5:\n                if (!(urlOrBlobClient instanceof BlobClient)) {\n                  _context3.next = 11;\n                  break;\n                }\n                // Second overload\n                url = urlOrBlobClient.url;\n                credential = urlOrBlobClient.credential;\n                options = credentialOrOptions;\n                _context3.next = 12;\n                break;\n              case 11:\n                throw new RangeError(\"Invalid arguments. Either url and credential, or BlobClient need be provided.\");\n              case 12:\n                if (!options) {\n                  options = {};\n                }\n                _createSpan = createSpan(\"BatchDeleteRequest-addSubRequest\", options), span = _createSpan.span, updatedOptions = _createSpan.updatedOptions;\n                _context3.prev = 14;\n                this.setBatchType(\"delete\");\n                _context3.next = 18;\n                return this.addSubRequestInternal({\n                  url: url,\n                  credential: credential\n                }, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n                  return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                    while (1) {\n                      switch (_context2.prev = _context2.next) {\n                        case 0:\n                          _context2.next = 2;\n                          return new BlobClient(url, _this.batchRequest.createPipeline(credential)).delete(updatedOptions);\n                        case 2:\n                        case \"end\":\n                          return _context2.stop();\n                      }\n                    }\n                  }, _callee2);\n                })));\n              case 18:\n                _context3.next = 24;\n                break;\n              case 20:\n                _context3.prev = 20;\n                _context3.t0 = _context3[\"catch\"](14);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context3.t0.message\n                });\n                throw _context3.t0;\n              case 24:\n                _context3.prev = 24;\n                span.end();\n                return _context3.finish(24);\n              case 27:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[14, 20, 24, 27]]);\n      }));\n      function deleteBlob(_x3, _x4, _x5) {\n        return _deleteBlob.apply(this, arguments);\n      }\n      return deleteBlob;\n    }()\n  }, {\n    key: \"setBlobAccessTier\",\n    value: function () {\n      var _setBlobAccessTier = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(urlOrBlobClient, credentialOrTier, tierOrOptions, options) {\n        var _this2 = this;\n        var url, credential, tier, _createSpan2, span, updatedOptions;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (!(typeof urlOrBlobClient === \"string\" && (isNode && credentialOrTier instanceof StorageSharedKeyCredential || credentialOrTier instanceof AnonymousCredential || isTokenCredential(credentialOrTier)))) {\n                  _context5.next = 6;\n                  break;\n                }\n                // First overload\n                url = urlOrBlobClient;\n                credential = credentialOrTier;\n                tier = tierOrOptions;\n                _context5.next = 14;\n                break;\n              case 6:\n                if (!(urlOrBlobClient instanceof BlobClient)) {\n                  _context5.next = 13;\n                  break;\n                }\n                // Second overload\n                url = urlOrBlobClient.url;\n                credential = urlOrBlobClient.credential;\n                tier = credentialOrTier;\n                options = tierOrOptions;\n                _context5.next = 14;\n                break;\n              case 13:\n                throw new RangeError(\"Invalid arguments. Either url and credential, or BlobClient need be provided.\");\n              case 14:\n                if (!options) {\n                  options = {};\n                }\n                _createSpan2 = createSpan(\"BatchSetTierRequest-addSubRequest\", options), span = _createSpan2.span, updatedOptions = _createSpan2.updatedOptions;\n                _context5.prev = 16;\n                this.setBatchType(\"setAccessTier\");\n                _context5.next = 20;\n                return this.addSubRequestInternal({\n                  url: url,\n                  credential: credential\n                }, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n                  return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n                    while (1) {\n                      switch (_context4.prev = _context4.next) {\n                        case 0:\n                          _context4.next = 2;\n                          return new BlobClient(url, _this2.batchRequest.createPipeline(credential)).setAccessTier(tier, updatedOptions);\n                        case 2:\n                        case \"end\":\n                          return _context4.stop();\n                      }\n                    }\n                  }, _callee4);\n                })));\n              case 20:\n                _context5.next = 26;\n                break;\n              case 22:\n                _context5.prev = 22;\n                _context5.t0 = _context5[\"catch\"](16);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context5.t0.message\n                });\n                throw _context5.t0;\n              case 26:\n                _context5.prev = 26;\n                span.end();\n                return _context5.finish(26);\n              case 29:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[16, 22, 26, 29]]);\n      }));\n      function setBlobAccessTier(_x6, _x7, _x8, _x9) {\n        return _setBlobAccessTier.apply(this, arguments);\n      }\n      return setBlobAccessTier;\n    }()\n  }]);\n  return BlobBatch;\n}();\n/**\n * Inner batch request class which is responsible for assembling and serializing sub requests.\n * See https://docs.microsoft.com/en-us/rest/api/storageservices/blob-batch#request-body for how requests are assembled.\n */\nvar InnerBatchRequest = /*#__PURE__*/function () {\n  function InnerBatchRequest() {\n    _classCallCheck(this, InnerBatchRequest);\n    this.operationCount = 0;\n    this.body = \"\";\n    var tempGuid = generateUuid();\n    // batch_{batchid}\n    this.boundary = \"batch_\".concat(tempGuid);\n    // --batch_{batchid}\n    // Content-Type: application/http\n    // Content-Transfer-Encoding: binary\n    this.subRequestPrefix = \"--\".concat(this.boundary).concat(HTTP_LINE_ENDING).concat(HeaderConstants.CONTENT_TYPE, \": application/http\").concat(HTTP_LINE_ENDING).concat(HeaderConstants.CONTENT_TRANSFER_ENCODING, \": binary\");\n    // multipart/mixed; boundary=batch_{batchid}\n    this.multipartContentType = \"multipart/mixed; boundary=\".concat(this.boundary);\n    // --batch_{batchid}--\n    this.batchRequestEnding = \"--\".concat(this.boundary, \"--\");\n    this.subRequests = new Map();\n  }\n  /**\n   * Create pipeline to assemble sub requests. The idea here is to use existing\n   * credential and serialization/deserialization components, with additional policies to\n   * filter unnecessary headers, assemble sub requests into request's body\n   * and intercept request from going to wire.\n   * @param credential -  Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.\n   */\n  _createClass(InnerBatchRequest, [{\n    key: \"createPipeline\",\n    value: function createPipeline(credential) {\n      var isAnonymousCreds = credential instanceof AnonymousCredential;\n      var policyFactoryLength = 3 + (isAnonymousCreds ? 0 : 1); // [deserializationPolicy, BatchHeaderFilterPolicyFactory, (Optional)Credential, BatchRequestAssemblePolicyFactory]\n      var factories = new Array(policyFactoryLength);\n      factories[0] = deserializationPolicy(); // Default deserializationPolicy is provided by protocol layer\n      factories[1] = new BatchHeaderFilterPolicyFactory(); // Use batch header filter policy to exclude unnecessary headers\n      if (!isAnonymousCreds) {\n        factories[2] = isTokenCredential(credential) ? attachCredential(bearerTokenAuthenticationPolicy(credential, StorageOAuthScopes), credential) : credential;\n      }\n      factories[policyFactoryLength - 1] = new BatchRequestAssemblePolicyFactory(this); // Use batch assemble policy to assemble request and intercept request from going to wire\n      return new Pipeline(factories, {});\n    }\n  }, {\n    key: \"appendSubRequestToBody\",\n    value: function appendSubRequestToBody(request) {\n      // Start to assemble sub request\n      this.body += [this.subRequestPrefix, \"\".concat(HeaderConstants.CONTENT_ID, \": \").concat(this.operationCount), \"\", \"\".concat(request.method.toString(), \" \").concat(getURLPathAndQuery(request.url), \" \").concat(HTTP_VERSION_1_1).concat(HTTP_LINE_ENDING) // sub request start line with method\n      ].join(HTTP_LINE_ENDING);\n      var _iterator = _createForOfIteratorHelper(request.headers.headersArray()),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var header = _step.value;\n          this.body += \"\".concat(header.name, \": \").concat(header.value).concat(HTTP_LINE_ENDING);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      this.body += HTTP_LINE_ENDING; // sub request's headers need be ending with an empty line\n      // No body to assemble for current batch request support\n      // End to assemble sub request\n    }\n  }, {\n    key: \"preAddSubRequest\",\n    value: function preAddSubRequest(subRequest) {\n      if (this.operationCount >= BATCH_MAX_REQUEST) {\n        throw new RangeError(\"Cannot exceed \".concat(BATCH_MAX_REQUEST, \" sub requests in a single batch\"));\n      }\n      // Fast fail if url for sub request is invalid\n      var path = getURLPath(subRequest.url);\n      if (!path || path === \"\") {\n        throw new RangeError(\"Invalid url for sub request: '\".concat(subRequest.url, \"'\"));\n      }\n    }\n  }, {\n    key: \"postAddSubRequest\",\n    value: function postAddSubRequest(subRequest) {\n      this.subRequests.set(this.operationCount, subRequest);\n      this.operationCount++;\n    }\n    // Return the http request body with assembling the ending line to the sub request body.\n  }, {\n    key: \"getHttpRequestBody\",\n    value: function getHttpRequestBody() {\n      return \"\".concat(this.body).concat(this.batchRequestEnding).concat(HTTP_LINE_ENDING);\n    }\n  }, {\n    key: \"getMultipartContentType\",\n    value: function getMultipartContentType() {\n      return this.multipartContentType;\n    }\n  }, {\n    key: \"getSubRequests\",\n    value: function getSubRequests() {\n      return this.subRequests;\n    }\n  }]);\n  return InnerBatchRequest;\n}();\nvar BatchRequestAssemblePolicy = /*#__PURE__*/function (_BaseRequestPolicy) {\n  _inherits(BatchRequestAssemblePolicy, _BaseRequestPolicy);\n  var _super = _createSuper(BatchRequestAssemblePolicy);\n  function BatchRequestAssemblePolicy(batchRequest, nextPolicy, options) {\n    var _this3;\n    _classCallCheck(this, BatchRequestAssemblePolicy);\n    _this3 = _super.call(this, nextPolicy, options);\n    _this3.dummyResponse = {\n      request: new WebResource(),\n      status: 200,\n      headers: new HttpHeaders()\n    };\n    _this3.batchRequest = batchRequest;\n    return _this3;\n  }\n  _createClass(BatchRequestAssemblePolicy, [{\n    key: \"sendRequest\",\n    value: function () {\n      var _sendRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(request) {\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return this.batchRequest.appendSubRequestToBody(request);\n              case 2:\n                return _context6.abrupt(\"return\", this.dummyResponse);\n              case 3:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n      function sendRequest(_x10) {\n        return _sendRequest.apply(this, arguments);\n      }\n      return sendRequest;\n    }()\n  }]);\n  return BatchRequestAssemblePolicy;\n}(BaseRequestPolicy);\nvar BatchRequestAssemblePolicyFactory = /*#__PURE__*/function () {\n  function BatchRequestAssemblePolicyFactory(batchRequest) {\n    _classCallCheck(this, BatchRequestAssemblePolicyFactory);\n    this.batchRequest = batchRequest;\n  }\n  _createClass(BatchRequestAssemblePolicyFactory, [{\n    key: \"create\",\n    value: function create(nextPolicy, options) {\n      return new BatchRequestAssemblePolicy(this.batchRequest, nextPolicy, options);\n    }\n  }]);\n  return BatchRequestAssemblePolicyFactory;\n}();\nvar BatchHeaderFilterPolicy = /*#__PURE__*/function (_BaseRequestPolicy2) {\n  _inherits(BatchHeaderFilterPolicy, _BaseRequestPolicy2);\n  var _super2 = _createSuper(BatchHeaderFilterPolicy);\n  // The base class has a protected constructor. Adding a public one to enable constructing of this class.\n  /* eslint-disable-next-line @typescript-eslint/no-useless-constructor*/\n  function BatchHeaderFilterPolicy(nextPolicy, options) {\n    _classCallCheck(this, BatchHeaderFilterPolicy);\n    return _super2.call(this, nextPolicy, options);\n  }\n  _createClass(BatchHeaderFilterPolicy, [{\n    key: \"sendRequest\",\n    value: function () {\n      var _sendRequest2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(request) {\n        var xMsHeaderName, _iterator2, _step2, header;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                xMsHeaderName = \"\";\n                _iterator2 = _createForOfIteratorHelper(request.headers.headersArray());\n                try {\n                  for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                    header = _step2.value;\n                    if (iEqual(header.name, HeaderConstants.X_MS_VERSION)) {\n                      xMsHeaderName = header.name;\n                    }\n                  }\n                } catch (err) {\n                  _iterator2.e(err);\n                } finally {\n                  _iterator2.f();\n                }\n                if (xMsHeaderName !== \"\") {\n                  request.headers.remove(xMsHeaderName); // The subrequests should not have the x-ms-version header.\n                }\n                return _context7.abrupt(\"return\", this._nextPolicy.sendRequest(request));\n              case 5:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n      function sendRequest(_x11) {\n        return _sendRequest2.apply(this, arguments);\n      }\n      return sendRequest;\n    }()\n  }]);\n  return BatchHeaderFilterPolicy;\n}(BaseRequestPolicy);\nvar BatchHeaderFilterPolicyFactory = /*#__PURE__*/function () {\n  function BatchHeaderFilterPolicyFactory() {\n    _classCallCheck(this, BatchHeaderFilterPolicyFactory);\n  }\n  _createClass(BatchHeaderFilterPolicyFactory, [{\n    key: \"create\",\n    value: function create(nextPolicy, options) {\n      return new BatchHeaderFilterPolicy(nextPolicy, options);\n    }\n  }]);\n  return BatchHeaderFilterPolicyFactory;\n}();","map":{"version":3,"mappings":";;;;;;+CACA;AADA;AACA;AAEA,SACEA,iBAAiB,EACjBC,qBAAqB,EACrBC,YAAY,EACZC,WAAW,EAKXC,WAAW,EAEXC,iBAAiB,EACjBC,+BAA+B,EAC/BC,MAAM,QACD,kBAAkB;AACzB,SAASC,cAAc,QAAQ,qBAAqB;AACpD,SAASC,mBAAmB,QAAQ,mCAAmC;AACvE,SAASC,UAAU,QAA+C,WAAW;AAE7E,SAASC,KAAK,QAAQ,eAAe;AACrC,SAASC,QAAQ,QAAQ,YAAY;AACrC,SAASC,gBAAgB,EAAEC,UAAU,EAAEC,kBAAkB,EAAEC,MAAM,QAAQ,sBAAsB;AAC/F,SACEC,eAAe,EACfC,iBAAiB,EACjBC,gBAAgB,EAChBC,gBAAgB,EAChBC,kBAAkB,QACb,mBAAmB;AAC1B,SAASC,0BAA0B,QAAQ,0CAA0C;AACrF,SAASC,UAAU,QAAQ,iBAAiB;AAmB5C;;;;AAIA,WAAaC,SAAS;EAKpB;IAAA;IAHiB,UAAK,GAAW,OAAO;IAItC,IAAI,CAACC,YAAY,GAAG,IAAIC,iBAAiB,EAAE;EAC7C;EAEA;;;;;EAAA;IAAA;IAAA,OAKO,mCAAuB;MAC5B,OAAO,IAAI,CAACD,YAAY,CAACE,uBAAuB,EAAE;IACpD;IAEA;;;EAAA;IAAA;IAAA,OAGO,8BAAkB;MACvB,OAAO,IAAI,CAACF,YAAY,CAACG,kBAAkB,EAAE;IAC/C;IAEA;;;EAAA;IAAA;IAAA,OAGO,0BAAc;MACnB,OAAO,IAAI,CAACH,YAAY,CAACI,cAAc,EAAE;IAC3C;EAAC;IAAA;IAAA;MAAA,wFAEO,iBACNC,UAA2B,EAC3BC,sBAA2C;QAAA;UAAA;YAAA;cAAA;gBAAA;gBAAA,OAErCpB,KAAK,CAACqB,IAAI,CAAC,IAAI,CAACC,KAAK,CAAC;cAAA;gBAAA;gBAG1B,IAAI,CAACR,YAAY,CAACS,gBAAgB,CAACJ,UAAU,CAAC;gBAAC;gBAAA,OACzCC,sBAAsB,EAAE;cAAA;gBAC9B,IAAI,CAACN,YAAY,CAACU,iBAAiB,CAACL,UAAU,CAAC;cAAC;gBAAA;gBAAA;gBAAA,OAE1CnB,KAAK,CAACyB,MAAM,CAAC,IAAI,CAACH,KAAK,CAAC;cAAA;gBAAA;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAEjC;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;IAAA;IAAA,OAEO,sBAAaI,SAAqC;MACxD,IAAI,CAAC,IAAI,CAACA,SAAS,EAAE;QACnB,IAAI,CAACA,SAAS,GAAGA,SAAS;;MAE5B,IAAI,IAAI,CAACA,SAAS,KAAKA,SAAS,EAAE;QAChC,MAAM,IAAIC,UAAU,iGACuE,IAAI,CAACD,SAAS,kBACxG;;IAEL;EAAC;IAAA;IAAA;MAAA,6EAqCM,kBACLE,eAAoC,EACpCC,mBAKa,EACbC,OAA2B;QAAA;QAAA;QAAA;UAAA;YAAA;cAAA;gBAAA,MAMzB,OAAOF,eAAe,KAAK,QAAQ,KACjChC,MAAM,IAAIiC,mBAAmB,YAAYlB,0BAA0B,IACnEkB,mBAAmB,YAAY/B,mBAAmB,IAClDJ,iBAAiB,CAACmC,mBAAmB,CAAC,CAAC;kBAAA;kBAAA;gBAAA;gBAEzC;gBACAE,GAAG,GAAGH,eAAe;gBACrBI,UAAU,GAAGH,mBAAmB;gBAAC;gBAAA;cAAA;gBAAA,MACxBD,eAAe,YAAY7B,UAAU;kBAAA;kBAAA;gBAAA;gBAC9C;gBACAgC,GAAG,GAAGH,eAAe,CAACG,GAAG;gBACzBC,UAAU,GAAGJ,eAAe,CAACI,UAAU;gBACvCF,OAAO,GAAGD,mBAAwC;gBAAC;gBAAA;cAAA;gBAAA,MAE7C,IAAIF,UAAU,CAClB,+EAA+E,CAChF;cAAA;gBAGH,IAAI,CAACG,OAAO,EAAE;kBACZA,OAAO,GAAG,EAAE;;gBACb,cAEgClB,UAAU,CAAC,kCAAkC,EAAEkB,OAAO,CAAC,EAAhFG,IAAI,eAAJA,IAAI,EAAEC,cAAc,eAAdA,cAAc;gBAAA;gBAG1B,IAAI,CAACC,YAAY,CAAC,QAAQ,CAAC;gBAAC;gBAAA,OACtB,IAAI,CAACC,qBAAqB,CAC9B;kBACEL,GAAG,EAAEA,GAAG;kBACRC,UAAU,EAAEA;iBACb,0EACD;kBAAA;oBAAA;sBAAA;wBAAA;0BAAA;0BAAA,OACQ,IAAIjC,UAAU,CAACgC,GAAG,EAAE,KAAI,CAACjB,YAAY,CAACuB,cAAc,CAACL,UAAU,CAAC,CAAC,CAACM,MAAM,CAC5EJ,cAAc,CACf;wBAAA;wBAAA;0BAAA;sBAAA;oBAAA;kBAAA;gBAAA,CACF,GACF;cAAA;gBAAA;gBAAA;cAAA;gBAAA;gBAAA;gBAEDD,IAAI,CAACM,SAAS,CAAC;kBACbC,IAAI,EAAE3C,cAAc,CAAC4C,KAAK;kBAC1BC,OAAO,EAAE,aAAEA;iBACZ,CAAC;gBAAC;cAAA;gBAAA;gBAGHT,IAAI,CAACU,GAAG,EAAE;gBAAC;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAEd;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;IAAA;IAAA;MAAA,oFAgDM,kBACLf,eAAoC,EACpCgB,gBAIc,EACdC,aAA+C,EAC/Cf,OAA4B;QAAA;QAAA;QAAA;UAAA;YAAA;cAAA;gBAAA,MAO1B,OAAOF,eAAe,KAAK,QAAQ,KACjChC,MAAM,IAAIgD,gBAAgB,YAAYjC,0BAA0B,IAChEiC,gBAAgB,YAAY9C,mBAAmB,IAC/CJ,iBAAiB,CAACkD,gBAAgB,CAAC,CAAC;kBAAA;kBAAA;gBAAA;gBAEtC;gBACAb,GAAG,GAAGH,eAAe;gBACrBI,UAAU,GAAGY,gBAGM;gBACnBE,IAAI,GAAGD,aAA2B;gBAAC;gBAAA;cAAA;gBAAA,MAC1BjB,eAAe,YAAY7B,UAAU;kBAAA;kBAAA;gBAAA;gBAC9C;gBACAgC,GAAG,GAAGH,eAAe,CAACG,GAAG;gBACzBC,UAAU,GAAGJ,eAAe,CAACI,UAAU;gBACvCc,IAAI,GAAGF,gBAA8B;gBACrCd,OAAO,GAAGe,aAAmC;gBAAC;gBAAA;cAAA;gBAAA,MAExC,IAAIlB,UAAU,CAClB,+EAA+E,CAChF;cAAA;gBAGH,IAAI,CAACG,OAAO,EAAE;kBACZA,OAAO,GAAG,EAAE;;gBACb,eAEgClB,UAAU,CAAC,mCAAmC,EAAEkB,OAAO,CAAC,EAAjFG,IAAI,gBAAJA,IAAI,EAAEC,cAAc,gBAAdA,cAAc;gBAAA;gBAG1B,IAAI,CAACC,YAAY,CAAC,eAAe,CAAC;gBAAC;gBAAA,OAC7B,IAAI,CAACC,qBAAqB,CAC9B;kBACEL,GAAG,EAAEA,GAAG;kBACRC,UAAU,EAAEA;iBACb,0EACD;kBAAA;oBAAA;sBAAA;wBAAA;0BAAA;0BAAA,OACQ,IAAIjC,UAAU,CAACgC,GAAG,EAAE,MAAI,CAACjB,YAAY,CAACuB,cAAc,CAACL,UAAU,CAAC,CAAC,CAACe,aAAa,CACnFD,IAAI,EACJZ,cAAc,CACf;wBAAA;wBAAA;0BAAA;sBAAA;oBAAA;kBAAA;gBAAA,CACF,GACF;cAAA;gBAAA;gBAAA;cAAA;gBAAA;gBAAA;gBAEDD,IAAI,CAACM,SAAS,CAAC;kBACbC,IAAI,EAAE3C,cAAc,CAAC4C,KAAK;kBAC1BC,OAAO,EAAE,aAAEA;iBACZ,CAAC;gBAAC;cAAA;gBAAA;gBAGHT,IAAI,CAACU,GAAG,EAAE;gBAAC;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAEd;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;EAAA;AAAA;AAGH;;;;AAAA,IAIM5B,iBAAiB;EASrB;IAAA;IACE,IAAI,CAACiC,cAAc,GAAG,CAAC;IACvB,IAAI,CAACC,IAAI,GAAG,EAAE;IAEd,IAAMC,QAAQ,GAAG3D,YAAY,EAAE;IAE/B;IACA,IAAI,CAAC4D,QAAQ,mBAAYD,QAAQ,CAAE;IACnC;IACA;IACA;IACA,IAAI,CAACE,gBAAgB,eAAQ,IAAI,CAACD,QAAQ,SAAG1C,gBAAgB,SAAGH,eAAe,CAAC+C,YAAY,+BAAqB5C,gBAAgB,SAAGH,eAAe,CAACgD,yBAAyB,aAAU;IACvL;IACA,IAAI,CAACC,oBAAoB,uCAAgC,IAAI,CAACJ,QAAQ,CAAE;IACxE;IACA,IAAI,CAACK,kBAAkB,eAAQ,IAAI,CAACL,QAAQ,OAAI;IAEhD,IAAI,CAACM,WAAW,GAAG,IAAIC,GAAG,EAAE;EAC9B;EAEA;;;;;;;EAAA;IAAA;IAAA,OAOO,wBACL1B,UAA8E;MAE9E,IAAM2B,gBAAgB,GAAG3B,UAAU,YAAYlC,mBAAmB;MAClE,IAAM8D,mBAAmB,GAAG,CAAC,IAAID,gBAAgB,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;MAC5D,IAAME,SAAS,GAA2B,IAAIC,KAAK,CAACF,mBAAmB,CAAC;MAExEC,SAAS,CAAC,CAAC,CAAC,GAAGvE,qBAAqB,EAAE,CAAC,CAAC;MACxCuE,SAAS,CAAC,CAAC,CAAC,GAAG,IAAIE,8BAA8B,EAAE,CAAC,CAAC;MACrD,IAAI,CAACJ,gBAAgB,EAAE;QACrBE,SAAS,CAAC,CAAC,CAAC,GAAGnE,iBAAiB,CAACsC,UAAU,CAAC,GACxC9B,gBAAgB,CACdP,+BAA+B,CAACqC,UAAU,EAAEtB,kBAAkB,CAAC,EAC/DsB,UAAU,CACX,GACDA,UAAU;;MAEhB6B,SAAS,CAACD,mBAAmB,GAAG,CAAC,CAAC,GAAG,IAAII,iCAAiC,CAAC,IAAI,CAAC,CAAC,CAAC;MAElF,OAAO,IAAI/D,QAAQ,CAAC4D,SAAS,EAAE,EAAE,CAAC;IACpC;EAAC;IAAA;IAAA,OAEM,gCAAuBI,OAAoB;MAChD;MACA,IAAI,CAAChB,IAAI,IAAI,CACX,IAAI,CAACG,gBAAgB,YAClB9C,eAAe,CAAC4D,UAAU,eAAK,IAAI,CAAClB,cAAc,GACrD,EAAE,YACCiB,OAAO,CAACE,MAAM,CAACC,QAAQ,EAAE,cAAIhE,kBAAkB,CAChD6D,OAAO,CAAClC,GAAG,CACZ,cAAIvB,gBAAgB,SAAGC,gBAAgB,EAAI;MAAA,CAC7C,CAAC4D,IAAI,CAAC5D,gBAAgB,CAAC;MAAC,2CAEJwD,OAAO,CAACK,OAAO,CAACC,YAAY,EAAE;QAAA;MAAA;QAAnD,oDAAqD;UAAA,IAA1CC,MAAM;UACf,IAAI,CAACvB,IAAI,cAAOuB,MAAM,CAACC,IAAI,eAAKD,MAAM,CAACE,KAAK,SAAGjE,gBAAgB,CAAE;;MAClE;QAAA;MAAA;QAAA;MAAA;MAED,IAAI,CAACwC,IAAI,IAAIxC,gBAAgB,CAAC,CAAC;MAC/B;MACA;IACF;EAAC;IAAA;IAAA,OAEM,0BAAiBU,UAA2B;MACjD,IAAI,IAAI,CAAC6B,cAAc,IAAIzC,iBAAiB,EAAE;QAC5C,MAAM,IAAIoB,UAAU,yBAAkBpB,iBAAiB,qCAAkC;;MAG3F;MACA,IAAMoE,IAAI,GAAGxE,UAAU,CAACgB,UAAU,CAACY,GAAG,CAAC;MACvC,IAAI,CAAC4C,IAAI,IAAIA,IAAI,KAAK,EAAE,EAAE;QACxB,MAAM,IAAIhD,UAAU,yCAAkCR,UAAU,CAACY,GAAG,OAAI;;IAE5E;EAAC;IAAA;IAAA,OAEM,2BAAkBZ,UAA2B;MAClD,IAAI,CAACsC,WAAW,CAACmB,GAAG,CAAC,IAAI,CAAC5B,cAAc,EAAE7B,UAAU,CAAC;MACrD,IAAI,CAAC6B,cAAc,EAAE;IACvB;IAEA;EAAA;IAAA;IAAA,OACO,8BAAkB;MACvB,iBAAU,IAAI,CAACC,IAAI,SAAG,IAAI,CAACO,kBAAkB,SAAG/C,gBAAgB;IAClE;EAAC;IAAA;IAAA,OAEM,mCAAuB;MAC5B,OAAO,IAAI,CAAC8C,oBAAoB;IAClC;EAAC;IAAA;IAAA,OAEM,0BAAc;MACnB,OAAO,IAAI,CAACE,WAAW;IACzB;EAAC;EAAA;AAAA;AAAA,IAGGoB,0BAA2B;EAAA;EAAA;EAQ/B,oCACE/D,YAA+B,EAC/BgE,UAAyB,EACzBhD,OAA6B;IAAA;IAAA;IAE7B,2BAAMgD,UAAU,EAAEhD,OAAO;IAXV,oBAAa,GAA0B;MACtDmC,OAAO,EAAE,IAAIxE,WAAW,EAAE;MAC1BsF,MAAM,EAAE,GAAG;MACXT,OAAO,EAAE,IAAI9E,WAAW;KACzB;IASC,OAAKsB,YAAY,GAAGA,YAAY;IAAC;EACnC;EAAC;IAAA;IAAA;MAAA,8EAEM,kBAAkBmD,OAAoB;QAAA;UAAA;YAAA;cAAA;gBAAA;gBAAA,OACrC,IAAI,CAACnD,YAAY,CAACkE,sBAAsB,CAACf,OAAO,CAAC;cAAA;gBAAA,kCAEhD,IAAI,CAACgB,aAAa;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAC1B;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;EAAA;AAAA,EAtBsC5F,iBAAiB;AAAA,IAyBpD2E,iCAAiC;EAGrC,2CAAYlD,YAA+B;IAAA;IACzC,IAAI,CAACA,YAAY,GAAGA,YAAY;EAClC;EAAC;IAAA;IAAA,OAEM,gBACLgE,UAAyB,EACzBhD,OAA6B;MAE7B,OAAO,IAAI+C,0BAA0B,CAAC,IAAI,CAAC/D,YAAY,EAAEgE,UAAU,EAAEhD,OAAO,CAAC;IAC/E;EAAC;EAAA;AAAA;AAAA,IAGGoD,uBAAwB;EAAA;EAAA;EAC5B;EACA;EACA,iCAAYJ,UAAyB,EAAEhD,OAA6B;IAAA;IAAA,0BAC5DgD,UAAU,EAAEhD,OAAO;EAC3B;EAAC;IAAA;IAAA;MAAA,+EAEM,kBAAkBmC,OAAoB;QAAA;QAAA;UAAA;YAAA;cAAA;gBACvCkB,aAAa,GAAG,EAAE;gBAAA,wCAEDlB,OAAO,CAACK,OAAO,CAACC,YAAY,EAAE;gBAAA;kBAAnD,uDAAqD;oBAA1CC,MAAM;oBACf,IAAInE,MAAM,CAACmE,MAAM,CAACC,IAAI,EAAEnE,eAAe,CAAC8E,YAAY,CAAC,EAAE;sBACrDD,aAAa,GAAGX,MAAM,CAACC,IAAI;;;gBAE9B;kBAAA;gBAAA;kBAAA;gBAAA;gBAED,IAAIU,aAAa,KAAK,EAAE,EAAE;kBACxBlB,OAAO,CAACK,OAAO,CAACe,MAAM,CAACF,aAAa,CAAC,CAAC,CAAC;;gBACxC,kCAEM,IAAI,CAACG,WAAW,CAACC,WAAW,CAACtB,OAAO,CAAC;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAC7C;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;EAAA;AAAA,EArBmC5E,iBAAiB;AAAA,IAwBjD0E,8BAA8B;EAAA;IAAA;EAAA;EAAA;IAAA;IAAA,OAC3B,gBAAOe,UAAyB,EAAEhD,OAA6B;MACpE,OAAO,IAAIoD,uBAAuB,CAACJ,UAAU,EAAEhD,OAAO,CAAC;IACzD;EAAC;EAAA;AAAA","names":["BaseRequestPolicy","deserializationPolicy","generateUuid","HttpHeaders","WebResource","isTokenCredential","bearerTokenAuthenticationPolicy","isNode","SpanStatusCode","AnonymousCredential","BlobClient","Mutex","Pipeline","attachCredential","getURLPath","getURLPathAndQuery","iEqual","HeaderConstants","BATCH_MAX_REQUEST","HTTP_VERSION_1_1","HTTP_LINE_ENDING","StorageOAuthScopes","StorageSharedKeyCredential","createSpan","BlobBatch","batchRequest","InnerBatchRequest","getMultipartContentType","getHttpRequestBody","getSubRequests","subRequest","assembleSubRequestFunc","lock","batch","preAddSubRequest","postAddSubRequest","unlock","batchType","RangeError","urlOrBlobClient","credentialOrOptions","options","url","credential","span","updatedOptions","setBatchType","addSubRequestInternal","createPipeline","delete","setStatus","code","ERROR","message","end","credentialOrTier","tierOrOptions","tier","setAccessTier","operationCount","body","tempGuid","boundary","subRequestPrefix","CONTENT_TYPE","CONTENT_TRANSFER_ENCODING","multipartContentType","batchRequestEnding","subRequests","Map","isAnonymousCreds","policyFactoryLength","factories","Array","BatchHeaderFilterPolicyFactory","BatchRequestAssemblePolicyFactory","request","CONTENT_ID","method","toString","join","headers","headersArray","header","name","value","path","set","BatchRequestAssemblePolicy","nextPolicy","status","appendSubRequestToBody","dummyResponse","BatchHeaderFilterPolicy","xMsHeaderName","X_MS_VERSION","remove","_nextPolicy","sendRequest"],"sourceRoot":"","sources":["../../../src/BlobBatch.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  BaseRequestPolicy,\n  deserializationPolicy,\n  generateUuid,\n  HttpHeaders,\n  HttpOperationResponse,\n  RequestPolicy,\n  RequestPolicyFactory,\n  RequestPolicyOptions,\n  WebResource,\n  TokenCredential,\n  isTokenCredential,\n  bearerTokenAuthenticationPolicy,\n  isNode,\n} from \"@azure/core-http\";\nimport { SpanStatusCode } from \"@azure/core-tracing\";\nimport { AnonymousCredential } from \"./credentials/AnonymousCredential\";\nimport { BlobClient, BlobDeleteOptions, BlobSetTierOptions } from \"./Clients\";\nimport { AccessTier } from \"./generatedModels\";\nimport { Mutex } from \"./utils/Mutex\";\nimport { Pipeline } from \"./Pipeline\";\nimport { attachCredential, getURLPath, getURLPathAndQuery, iEqual } from \"./utils/utils.common\";\nimport {\n  HeaderConstants,\n  BATCH_MAX_REQUEST,\n  HTTP_VERSION_1_1,\n  HTTP_LINE_ENDING,\n  StorageOAuthScopes,\n} from \"./utils/constants\";\nimport { StorageSharedKeyCredential } from \"./credentials/StorageSharedKeyCredential\";\nimport { createSpan } from \"./utils/tracing\";\n\n/**\n * A request associated with a batch operation.\n */\nexport interface BatchSubRequest {\n  /**\n   * The URL of the resource to request operation.\n   */\n  url: string;\n\n  /**\n   * The credential used for sub request.\n   * Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service.\n   * You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.\n   */\n  credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential;\n}\n\n/**\n * A BlobBatch represents an aggregated set of operations on blobs.\n * Currently, only `delete` and `setAccessTier` are supported.\n */\nexport class BlobBatch {\n  private batchRequest: InnerBatchRequest;\n  private readonly batch: string = \"batch\";\n  private batchType: \"delete\" | \"setAccessTier\" | undefined;\n\n  constructor() {\n    this.batchRequest = new InnerBatchRequest();\n  }\n\n  /**\n   * Get the value of Content-Type for a batch request.\n   * The value must be multipart/mixed with a batch boundary.\n   * Example: multipart/mixed; boundary=batch_a81786c8-e301-4e42-a729-a32ca24ae252\n   */\n  public getMultiPartContentType(): string {\n    return this.batchRequest.getMultipartContentType();\n  }\n\n  /**\n   * Get assembled HTTP request body for sub requests.\n   */\n  public getHttpRequestBody(): string {\n    return this.batchRequest.getHttpRequestBody();\n  }\n\n  /**\n   * Get sub requests that are added into the batch request.\n   */\n  public getSubRequests(): Map<number, BatchSubRequest> {\n    return this.batchRequest.getSubRequests();\n  }\n\n  private async addSubRequestInternal(\n    subRequest: BatchSubRequest,\n    assembleSubRequestFunc: () => Promise<void>\n  ): Promise<void> {\n    await Mutex.lock(this.batch);\n\n    try {\n      this.batchRequest.preAddSubRequest(subRequest);\n      await assembleSubRequestFunc();\n      this.batchRequest.postAddSubRequest(subRequest);\n    } finally {\n      await Mutex.unlock(this.batch);\n    }\n  }\n\n  private setBatchType(batchType: \"delete\" | \"setAccessTier\"): void {\n    if (!this.batchType) {\n      this.batchType = batchType;\n    }\n    if (this.batchType !== batchType) {\n      throw new RangeError(\n        `BlobBatch only supports one operation type per batch and it already is being used for ${this.batchType} operations.`\n      );\n    }\n  }\n\n  /**\n   * The deleteBlob operation marks the specified blob or snapshot for deletion.\n   * The blob is later deleted during garbage collection.\n   * Only one kind of operation is allowed per batch request.\n   *\n   * Note that in order to delete a blob, you must delete all of its snapshots.\n   * You can delete both at the same time. See [delete operation details](https://docs.microsoft.com/en-us/rest/api/storageservices/delete-blob).\n   * The operation will be authenticated and authorized with specified credential.\n   * See [blob batch authorization details](https://docs.microsoft.com/en-us/rest/api/storageservices/blob-batch#authorization).\n   *\n   * @param url - The url of the blob resource to delete.\n   * @param credential - Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.\n   * @param options -\n   */\n  public async deleteBlob(\n    url: string,\n    credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential,\n    options?: BlobDeleteOptions\n  ): Promise<void>;\n\n  /**\n   * The deleteBlob operation marks the specified blob or snapshot for deletion.\n   * The blob is later deleted during garbage collection.\n   * Only one kind of operation is allowed per batch request.\n   *\n   * Note that in order to delete a blob, you must delete all of its snapshots.\n   * You can delete both at the same time. See [delete operation details](https://docs.microsoft.com/en-us/rest/api/storageservices/delete-blob).\n   * The operation will be authenticated and authorized with specified credential.\n   * See [blob batch authorization details](https://docs.microsoft.com/en-us/rest/api/storageservices/blob-batch#authorization).\n   *\n   * @param blobClient - The BlobClient.\n   * @param options -\n   */\n  public async deleteBlob(blobClient: BlobClient, options?: BlobDeleteOptions): Promise<void>;\n\n  public async deleteBlob(\n    urlOrBlobClient: string | BlobClient,\n    credentialOrOptions:\n      | StorageSharedKeyCredential\n      | AnonymousCredential\n      | TokenCredential\n      | BlobDeleteOptions\n      | undefined,\n    options?: BlobDeleteOptions\n  ): Promise<void> {\n    let url: string;\n    let credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential;\n\n    if (\n      typeof urlOrBlobClient === \"string\" &&\n      ((isNode && credentialOrOptions instanceof StorageSharedKeyCredential) ||\n        credentialOrOptions instanceof AnonymousCredential ||\n        isTokenCredential(credentialOrOptions))\n    ) {\n      // First overload\n      url = urlOrBlobClient;\n      credential = credentialOrOptions;\n    } else if (urlOrBlobClient instanceof BlobClient) {\n      // Second overload\n      url = urlOrBlobClient.url;\n      credential = urlOrBlobClient.credential;\n      options = credentialOrOptions as BlobDeleteOptions;\n    } else {\n      throw new RangeError(\n        \"Invalid arguments. Either url and credential, or BlobClient need be provided.\"\n      );\n    }\n\n    if (!options) {\n      options = {};\n    }\n\n    const { span, updatedOptions } = createSpan(\"BatchDeleteRequest-addSubRequest\", options);\n\n    try {\n      this.setBatchType(\"delete\");\n      await this.addSubRequestInternal(\n        {\n          url: url,\n          credential: credential,\n        },\n        async () => {\n          await new BlobClient(url, this.batchRequest.createPipeline(credential)).delete(\n            updatedOptions\n          );\n        }\n      );\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * The setBlobAccessTier operation sets the tier on a blob.\n   * The operation is allowed on block blobs in a blob storage or general purpose v2 account.\n   * Only one kind of operation is allowed per batch request.\n   *\n   * A block blob's tier determines Hot/Cool/Archive storage type.\n   * This operation does not update the blob's ETag.\n   * For detailed information about block blob level tiering\n   * see [hot, cool, and archive access tiers](https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blob-storage-tiers).\n   * The operation will be authenticated and authorized\n   * with specified credential. See [blob batch authorization details](https://docs.microsoft.com/en-us/rest/api/storageservices/blob-batch#authorization).\n   *\n   * @param url - The url of the blob resource to delete.\n   * @param credential - Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.\n   * @param tier -\n   * @param options -\n   */\n  public async setBlobAccessTier(\n    url: string,\n    credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential,\n    tier: AccessTier,\n    options?: BlobSetTierOptions\n  ): Promise<void>;\n\n  /**\n   * The setBlobAccessTier operation sets the tier on a blob.\n   * The operation is allowed on block blobs in a blob storage or general purpose v2 account.\n   * Only one kind of operation is allowed per batch request.\n   *\n   * A block blob's tier determines Hot/Cool/Archive storage type.\n   * This operation does not update the blob's ETag.\n   * For detailed information about block blob level tiering\n   * see [hot, cool, and archive access tiers](https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blob-storage-tiers).\n   * The operation will be authenticated and authorized\n   * with specified credential. See [blob batch authorization details](https://docs.microsoft.com/en-us/rest/api/storageservices/blob-batch#authorization).\n   *\n   * @param blobClient - The BlobClient.\n   * @param tier -\n   * @param options -\n   */\n  public async setBlobAccessTier(\n    blobClient: BlobClient,\n    tier: AccessTier,\n    options?: BlobSetTierOptions\n  ): Promise<void>;\n\n  public async setBlobAccessTier(\n    urlOrBlobClient: string | BlobClient,\n    credentialOrTier:\n      | StorageSharedKeyCredential\n      | AnonymousCredential\n      | TokenCredential\n      | AccessTier,\n    tierOrOptions?: AccessTier | BlobSetTierOptions,\n    options?: BlobSetTierOptions\n  ): Promise<void> {\n    let url: string;\n    let credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential;\n    let tier: AccessTier;\n\n    if (\n      typeof urlOrBlobClient === \"string\" &&\n      ((isNode && credentialOrTier instanceof StorageSharedKeyCredential) ||\n        credentialOrTier instanceof AnonymousCredential ||\n        isTokenCredential(credentialOrTier))\n    ) {\n      // First overload\n      url = urlOrBlobClient;\n      credential = credentialOrTier as\n        | StorageSharedKeyCredential\n        | AnonymousCredential\n        | TokenCredential;\n      tier = tierOrOptions as AccessTier;\n    } else if (urlOrBlobClient instanceof BlobClient) {\n      // Second overload\n      url = urlOrBlobClient.url;\n      credential = urlOrBlobClient.credential;\n      tier = credentialOrTier as AccessTier;\n      options = tierOrOptions as BlobSetTierOptions;\n    } else {\n      throw new RangeError(\n        \"Invalid arguments. Either url and credential, or BlobClient need be provided.\"\n      );\n    }\n\n    if (!options) {\n      options = {};\n    }\n\n    const { span, updatedOptions } = createSpan(\"BatchSetTierRequest-addSubRequest\", options);\n\n    try {\n      this.setBatchType(\"setAccessTier\");\n      await this.addSubRequestInternal(\n        {\n          url: url,\n          credential: credential,\n        },\n        async () => {\n          await new BlobClient(url, this.batchRequest.createPipeline(credential)).setAccessTier(\n            tier,\n            updatedOptions\n          );\n        }\n      );\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n}\n\n/**\n * Inner batch request class which is responsible for assembling and serializing sub requests.\n * See https://docs.microsoft.com/en-us/rest/api/storageservices/blob-batch#request-body for how requests are assembled.\n */\nclass InnerBatchRequest {\n  private operationCount: number;\n  private body: string;\n  private subRequests: Map<number, BatchSubRequest>;\n  private readonly boundary: string;\n  private readonly subRequestPrefix: string;\n  private readonly multipartContentType: string;\n  private readonly batchRequestEnding: string;\n\n  constructor() {\n    this.operationCount = 0;\n    this.body = \"\";\n\n    const tempGuid = generateUuid();\n\n    // batch_{batchid}\n    this.boundary = `batch_${tempGuid}`;\n    // --batch_{batchid}\n    // Content-Type: application/http\n    // Content-Transfer-Encoding: binary\n    this.subRequestPrefix = `--${this.boundary}${HTTP_LINE_ENDING}${HeaderConstants.CONTENT_TYPE}: application/http${HTTP_LINE_ENDING}${HeaderConstants.CONTENT_TRANSFER_ENCODING}: binary`;\n    // multipart/mixed; boundary=batch_{batchid}\n    this.multipartContentType = `multipart/mixed; boundary=${this.boundary}`;\n    // --batch_{batchid}--\n    this.batchRequestEnding = `--${this.boundary}--`;\n\n    this.subRequests = new Map();\n  }\n\n  /**\n   * Create pipeline to assemble sub requests. The idea here is to use existing\n   * credential and serialization/deserialization components, with additional policies to\n   * filter unnecessary headers, assemble sub requests into request's body\n   * and intercept request from going to wire.\n   * @param credential -  Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.\n   */\n  public createPipeline(\n    credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential\n  ): Pipeline {\n    const isAnonymousCreds = credential instanceof AnonymousCredential;\n    const policyFactoryLength = 3 + (isAnonymousCreds ? 0 : 1); // [deserializationPolicy, BatchHeaderFilterPolicyFactory, (Optional)Credential, BatchRequestAssemblePolicyFactory]\n    const factories: RequestPolicyFactory[] = new Array(policyFactoryLength);\n\n    factories[0] = deserializationPolicy(); // Default deserializationPolicy is provided by protocol layer\n    factories[1] = new BatchHeaderFilterPolicyFactory(); // Use batch header filter policy to exclude unnecessary headers\n    if (!isAnonymousCreds) {\n      factories[2] = isTokenCredential(credential)\n        ? attachCredential(\n            bearerTokenAuthenticationPolicy(credential, StorageOAuthScopes),\n            credential\n          )\n        : credential;\n    }\n    factories[policyFactoryLength - 1] = new BatchRequestAssemblePolicyFactory(this); // Use batch assemble policy to assemble request and intercept request from going to wire\n\n    return new Pipeline(factories, {});\n  }\n\n  public appendSubRequestToBody(request: WebResource) {\n    // Start to assemble sub request\n    this.body += [\n      this.subRequestPrefix, // sub request constant prefix\n      `${HeaderConstants.CONTENT_ID}: ${this.operationCount}`, // sub request's content ID\n      \"\", // empty line after sub request's content ID\n      `${request.method.toString()} ${getURLPathAndQuery(\n        request.url\n      )} ${HTTP_VERSION_1_1}${HTTP_LINE_ENDING}`, // sub request start line with method\n    ].join(HTTP_LINE_ENDING);\n\n    for (const header of request.headers.headersArray()) {\n      this.body += `${header.name}: ${header.value}${HTTP_LINE_ENDING}`;\n    }\n\n    this.body += HTTP_LINE_ENDING; // sub request's headers need be ending with an empty line\n    // No body to assemble for current batch request support\n    // End to assemble sub request\n  }\n\n  public preAddSubRequest(subRequest: BatchSubRequest) {\n    if (this.operationCount >= BATCH_MAX_REQUEST) {\n      throw new RangeError(`Cannot exceed ${BATCH_MAX_REQUEST} sub requests in a single batch`);\n    }\n\n    // Fast fail if url for sub request is invalid\n    const path = getURLPath(subRequest.url);\n    if (!path || path === \"\") {\n      throw new RangeError(`Invalid url for sub request: '${subRequest.url}'`);\n    }\n  }\n\n  public postAddSubRequest(subRequest: BatchSubRequest) {\n    this.subRequests.set(this.operationCount, subRequest);\n    this.operationCount++;\n  }\n\n  // Return the http request body with assembling the ending line to the sub request body.\n  public getHttpRequestBody(): string {\n    return `${this.body}${this.batchRequestEnding}${HTTP_LINE_ENDING}`;\n  }\n\n  public getMultipartContentType(): string {\n    return this.multipartContentType;\n  }\n\n  public getSubRequests(): Map<number, BatchSubRequest> {\n    return this.subRequests;\n  }\n}\n\nclass BatchRequestAssemblePolicy extends BaseRequestPolicy {\n  private batchRequest: InnerBatchRequest;\n  private readonly dummyResponse: HttpOperationResponse = {\n    request: new WebResource(),\n    status: 200,\n    headers: new HttpHeaders(),\n  };\n\n  constructor(\n    batchRequest: InnerBatchRequest,\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptions\n  ) {\n    super(nextPolicy, options);\n\n    this.batchRequest = batchRequest;\n  }\n\n  public async sendRequest(request: WebResource): Promise<HttpOperationResponse> {\n    await this.batchRequest.appendSubRequestToBody(request);\n\n    return this.dummyResponse; // Intercept request from going to wire\n  }\n}\n\nclass BatchRequestAssemblePolicyFactory implements RequestPolicyFactory {\n  private batchRequest: InnerBatchRequest;\n\n  constructor(batchRequest: InnerBatchRequest) {\n    this.batchRequest = batchRequest;\n  }\n\n  public create(\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptions\n  ): BatchRequestAssemblePolicy {\n    return new BatchRequestAssemblePolicy(this.batchRequest, nextPolicy, options);\n  }\n}\n\nclass BatchHeaderFilterPolicy extends BaseRequestPolicy {\n  // The base class has a protected constructor. Adding a public one to enable constructing of this class.\n  /* eslint-disable-next-line @typescript-eslint/no-useless-constructor*/\n  constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions) {\n    super(nextPolicy, options);\n  }\n\n  public async sendRequest(request: WebResource): Promise<HttpOperationResponse> {\n    let xMsHeaderName = \"\";\n\n    for (const header of request.headers.headersArray()) {\n      if (iEqual(header.name, HeaderConstants.X_MS_VERSION)) {\n        xMsHeaderName = header.name;\n      }\n    }\n\n    if (xMsHeaderName !== \"\") {\n      request.headers.remove(xMsHeaderName); // The subrequests should not have the x-ms-version header.\n    }\n\n    return this._nextPolicy.sendRequest(request);\n  }\n}\n\nclass BatchHeaderFilterPolicyFactory implements RequestPolicyFactory {\n  public create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): BatchHeaderFilterPolicy {\n    return new BatchHeaderFilterPolicy(nextPolicy, options);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}