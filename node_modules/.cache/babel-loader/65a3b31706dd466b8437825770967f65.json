{"ast":null,"code":"import _asyncToGenerator from \"/Users/tbeckett/Documents/TI - Project Info/JavaScript_end_to_end_client_file_upload_to_Azure_Storage_Blobs/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { logger } from \"../logger\";\nimport { terminalStates } from \"./constants\";\n/**\n * Deserializes the state\n */\nexport function deserializeState(serializedState) {\n  try {\n    return JSON.parse(serializedState).state;\n  } catch (e) {\n    throw new Error(\"Unable to deserialize input state: \".concat(serializedState));\n  }\n}\nfunction setStateError(inputs) {\n  var state = inputs.state,\n    stateProxy = inputs.stateProxy;\n  return function (error) {\n    stateProxy.setError(state, error);\n    stateProxy.setFailed(state);\n    throw error;\n  };\n}\nfunction processOperationStatus(result) {\n  var state = result.state,\n    stateProxy = result.stateProxy,\n    status = result.status,\n    isDone = result.isDone,\n    processResult = result.processResult,\n    response = result.response,\n    setErrorAsResult = result.setErrorAsResult;\n  switch (status) {\n    case \"succeeded\":\n      {\n        stateProxy.setSucceeded(state);\n        break;\n      }\n    case \"failed\":\n      {\n        stateProxy.setError(state, new Error(\"The long-running operation has failed\"));\n        stateProxy.setFailed(state);\n        break;\n      }\n    case \"canceled\":\n      {\n        stateProxy.setCanceled(state);\n        break;\n      }\n  }\n  if ((isDone === null || isDone === void 0 ? void 0 : isDone(response, state)) || isDone === undefined && [\"succeeded\", \"canceled\"].concat(setErrorAsResult ? [] : [\"failed\"]).includes(status)) {\n    stateProxy.setResult(state, buildResult({\n      response: response,\n      state: state,\n      processResult: processResult\n    }));\n  }\n}\nfunction buildResult(inputs) {\n  var processResult = inputs.processResult,\n    response = inputs.response,\n    state = inputs.state;\n  return processResult ? processResult(response, state) : response;\n}\n/**\n * Initiates the long-running operation.\n */\nexport function initOperation(_x) {\n  return _initOperation.apply(this, arguments);\n}\nfunction _initOperation() {\n  _initOperation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(inputs) {\n    var init, stateProxy, processResult, getOperationStatus, withOperationLocation, setErrorAsResult, _yield$init, operationLocation, resourceLocation, metadata, response, config, state, status;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            init = inputs.init, stateProxy = inputs.stateProxy, processResult = inputs.processResult, getOperationStatus = inputs.getOperationStatus, withOperationLocation = inputs.withOperationLocation, setErrorAsResult = inputs.setErrorAsResult;\n            _context.next = 3;\n            return init();\n          case 3:\n            _yield$init = _context.sent;\n            operationLocation = _yield$init.operationLocation;\n            resourceLocation = _yield$init.resourceLocation;\n            metadata = _yield$init.metadata;\n            response = _yield$init.response;\n            if (operationLocation) withOperationLocation === null || withOperationLocation === void 0 ? void 0 : withOperationLocation(operationLocation, false);\n            config = {\n              metadata: metadata,\n              operationLocation: operationLocation,\n              resourceLocation: resourceLocation\n            };\n            logger.verbose(\"LRO: Operation description:\", config);\n            state = stateProxy.initState(config);\n            status = getOperationStatus({\n              response: response,\n              state: state,\n              operationLocation: operationLocation\n            });\n            processOperationStatus({\n              state: state,\n              status: status,\n              stateProxy: stateProxy,\n              response: response,\n              setErrorAsResult: setErrorAsResult,\n              processResult: processResult\n            });\n            return _context.abrupt(\"return\", state);\n          case 15:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _initOperation.apply(this, arguments);\n}\nfunction pollOperationHelper(_x2) {\n  return _pollOperationHelper.apply(this, arguments);\n}\n/** Polls the long-running operation. */\nfunction _pollOperationHelper() {\n  _pollOperationHelper = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(inputs) {\n    var poll, state, stateProxy, operationLocation, getOperationStatus, getResourceLocation, options, response, status, resourceLocation;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            poll = inputs.poll, state = inputs.state, stateProxy = inputs.stateProxy, operationLocation = inputs.operationLocation, getOperationStatus = inputs.getOperationStatus, getResourceLocation = inputs.getResourceLocation, options = inputs.options;\n            _context2.next = 3;\n            return poll(operationLocation, options).catch(setStateError({\n              state: state,\n              stateProxy: stateProxy\n            }));\n          case 3:\n            response = _context2.sent;\n            status = getOperationStatus(response, state);\n            logger.verbose(\"LRO: Status:\\n\\tPolling from: \".concat(state.config.operationLocation, \"\\n\\tOperation status: \").concat(status, \"\\n\\tPolling status: \").concat(terminalStates.includes(status) ? \"Stopped\" : \"Running\"));\n            if (!(status === \"succeeded\")) {\n              _context2.next = 14;\n              break;\n            }\n            resourceLocation = getResourceLocation(response, state);\n            if (!(resourceLocation !== undefined)) {\n              _context2.next = 14;\n              break;\n            }\n            _context2.next = 11;\n            return poll(resourceLocation).catch(setStateError({\n              state: state,\n              stateProxy: stateProxy\n            }));\n          case 11:\n            _context2.t0 = _context2.sent;\n            _context2.t1 = status;\n            return _context2.abrupt(\"return\", {\n              response: _context2.t0,\n              status: _context2.t1\n            });\n          case 14:\n            return _context2.abrupt(\"return\", {\n              response: response,\n              status: status\n            });\n          case 15:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _pollOperationHelper.apply(this, arguments);\n}\nexport function pollOperation(_x3) {\n  return _pollOperation.apply(this, arguments);\n}\nfunction _pollOperation() {\n  _pollOperation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(inputs) {\n    var poll, state, stateProxy, options, getOperationStatus, getResourceLocation, getOperationLocation, withOperationLocation, getPollingInterval, processResult, updateState, setDelay, isDone, setErrorAsResult, operationLocation, _yield$pollOperationH, response, status, intervalInMs, location, isUpdated;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            poll = inputs.poll, state = inputs.state, stateProxy = inputs.stateProxy, options = inputs.options, getOperationStatus = inputs.getOperationStatus, getResourceLocation = inputs.getResourceLocation, getOperationLocation = inputs.getOperationLocation, withOperationLocation = inputs.withOperationLocation, getPollingInterval = inputs.getPollingInterval, processResult = inputs.processResult, updateState = inputs.updateState, setDelay = inputs.setDelay, isDone = inputs.isDone, setErrorAsResult = inputs.setErrorAsResult;\n            operationLocation = state.config.operationLocation;\n            if (!(operationLocation !== undefined)) {\n              _context3.next = 11;\n              break;\n            }\n            _context3.next = 5;\n            return pollOperationHelper({\n              poll: poll,\n              getOperationStatus: getOperationStatus,\n              state: state,\n              stateProxy: stateProxy,\n              operationLocation: operationLocation,\n              getResourceLocation: getResourceLocation,\n              options: options\n            });\n          case 5:\n            _yield$pollOperationH = _context3.sent;\n            response = _yield$pollOperationH.response;\n            status = _yield$pollOperationH.status;\n            processOperationStatus({\n              status: status,\n              response: response,\n              state: state,\n              stateProxy: stateProxy,\n              isDone: isDone,\n              processResult: processResult,\n              setErrorAsResult: setErrorAsResult\n            });\n            if (!terminalStates.includes(status)) {\n              intervalInMs = getPollingInterval === null || getPollingInterval === void 0 ? void 0 : getPollingInterval(response);\n              if (intervalInMs) setDelay(intervalInMs);\n              location = getOperationLocation === null || getOperationLocation === void 0 ? void 0 : getOperationLocation(response, state);\n              if (location !== undefined) {\n                isUpdated = operationLocation !== location;\n                state.config.operationLocation = location;\n                withOperationLocation === null || withOperationLocation === void 0 ? void 0 : withOperationLocation(location, isUpdated);\n              } else withOperationLocation === null || withOperationLocation === void 0 ? void 0 : withOperationLocation(operationLocation, false);\n            }\n            updateState === null || updateState === void 0 ? void 0 : updateState(state, response);\n          case 11:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _pollOperation.apply(this, arguments);\n}","map":{"version":3,"mappings":"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","names":["logger","terminalStates","deserializeState","serializedState","JSON","parse","state","e","Error","setStateError","inputs","stateProxy","error","setError","setFailed","processOperationStatus","result","status","isDone","processResult","response","setErrorAsResult","setSucceeded","setCanceled","undefined","concat","includes","setResult","buildResult","initOperation","init","getOperationStatus","withOperationLocation","operationLocation","resourceLocation","metadata","config","verbose","initState","pollOperationHelper","poll","getResourceLocation","options","catch","pollOperation","getOperationLocation","getPollingInterval","updateState","setDelay","intervalInMs","location","isUpdated"],"sourceRoot":"","sources":["../../../src/poller/operation.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { Operation, OperationStatus, RestorableOperationState, StateProxy } from \"./models\";\nimport { logger } from \"../logger\";\nimport { terminalStates } from \"./constants\";\n\n/**\n * Deserializes the state\n */\nexport function deserializeState<TState>(\n  serializedState: string\n): RestorableOperationState<TState> {\n  try {\n    return JSON.parse(serializedState).state;\n  } catch (e) {\n    throw new Error(`Unable to deserialize input state: ${serializedState}`);\n  }\n}\n\nfunction setStateError<TState, TResult>(inputs: {\n  state: TState;\n  stateProxy: StateProxy<TState, TResult>;\n}): (error: Error) => never {\n  const { state, stateProxy } = inputs;\n  return (error: Error) => {\n    stateProxy.setError(state, error);\n    stateProxy.setFailed(state);\n    throw error;\n  };\n}\n\nfunction processOperationStatus<TState, TResult, TResponse>(result: {\n  status: OperationStatus;\n  response: TResponse;\n  state: RestorableOperationState<TState>;\n  stateProxy: StateProxy<TState, TResult>;\n  processResult?: (result: TResponse, state: TState) => TResult;\n  isDone?: (lastResponse: TResponse, state: TState) => boolean;\n  setErrorAsResult: boolean;\n}): void {\n  const { state, stateProxy, status, isDone, processResult, response, setErrorAsResult } = result;\n  switch (status) {\n    case \"succeeded\": {\n      stateProxy.setSucceeded(state);\n      break;\n    }\n    case \"failed\": {\n      stateProxy.setError(state, new Error(`The long-running operation has failed`));\n      stateProxy.setFailed(state);\n      break;\n    }\n    case \"canceled\": {\n      stateProxy.setCanceled(state);\n      break;\n    }\n  }\n  if (\n    isDone?.(response, state) ||\n    (isDone === undefined &&\n      [\"succeeded\", \"canceled\"].concat(setErrorAsResult ? [] : [\"failed\"]).includes(status))\n  ) {\n    stateProxy.setResult(\n      state,\n      buildResult({\n        response,\n        state,\n        processResult,\n      })\n    );\n  }\n}\n\nfunction buildResult<TResponse, TResult, TState>(inputs: {\n  response: TResponse;\n  state: TState;\n  processResult?: (result: TResponse, state: TState) => TResult;\n}): TResult {\n  const { processResult, response, state } = inputs;\n  return processResult ? processResult(response, state) : (response as unknown as TResult);\n}\n\n/**\n * Initiates the long-running operation.\n */\nexport async function initOperation<TResponse, TResult, TState>(inputs: {\n  init: Operation<TResponse, unknown>[\"init\"];\n  stateProxy: StateProxy<TState, TResult>;\n  getOperationStatus: (inputs: {\n    response: TResponse;\n    state: RestorableOperationState<TState>;\n    operationLocation?: string;\n  }) => OperationStatus;\n  processResult?: (result: TResponse, state: TState) => TResult;\n  withOperationLocation?: (operationLocation: string, isUpdated: boolean) => void;\n  setErrorAsResult: boolean;\n}): Promise<RestorableOperationState<TState>> {\n  const {\n    init,\n    stateProxy,\n    processResult,\n    getOperationStatus,\n    withOperationLocation,\n    setErrorAsResult,\n  } = inputs;\n  const { operationLocation, resourceLocation, metadata, response } = await init();\n  if (operationLocation) withOperationLocation?.(operationLocation, false);\n  const config = {\n    metadata,\n    operationLocation,\n    resourceLocation,\n  };\n  logger.verbose(`LRO: Operation description:`, config);\n  const state = stateProxy.initState(config);\n  const status = getOperationStatus({ response, state, operationLocation });\n  processOperationStatus({ state, status, stateProxy, response, setErrorAsResult, processResult });\n  return state;\n}\n\nasync function pollOperationHelper<TResponse, TState, TResult, TOptions>(inputs: {\n  poll: Operation<TResponse, TOptions>[\"poll\"];\n  stateProxy: StateProxy<TState, TResult>;\n  state: RestorableOperationState<TState>;\n  operationLocation: string;\n  getOperationStatus: (\n    response: TResponse,\n    state: RestorableOperationState<TState>\n  ) => OperationStatus;\n  getResourceLocation: (\n    response: TResponse,\n    state: RestorableOperationState<TState>\n  ) => string | undefined;\n  options?: TOptions;\n}): Promise<{\n  status: OperationStatus;\n  response: TResponse;\n}> {\n  const {\n    poll,\n    state,\n    stateProxy,\n    operationLocation,\n    getOperationStatus,\n    getResourceLocation,\n    options,\n  } = inputs;\n  const response = await poll(operationLocation, options).catch(\n    setStateError({\n      state,\n      stateProxy,\n    })\n  );\n  const status = getOperationStatus(response, state);\n  logger.verbose(\n    `LRO: Status:\\n\\tPolling from: ${\n      state.config.operationLocation\n    }\\n\\tOperation status: ${status}\\n\\tPolling status: ${\n      terminalStates.includes(status) ? \"Stopped\" : \"Running\"\n    }`\n  );\n  if (status === \"succeeded\") {\n    const resourceLocation = getResourceLocation(response, state);\n    if (resourceLocation !== undefined) {\n      return {\n        response: await poll(resourceLocation).catch(setStateError({ state, stateProxy })),\n        status,\n      };\n    }\n  }\n  return { response, status };\n}\n\n/** Polls the long-running operation. */\nexport async function pollOperation<TResponse, TState, TResult, TOptions>(inputs: {\n  poll: Operation<TResponse, TOptions>[\"poll\"];\n  stateProxy: StateProxy<TState, TResult>;\n  state: RestorableOperationState<TState>;\n  getOperationStatus: (\n    response: TResponse,\n    state: RestorableOperationState<TState>\n  ) => OperationStatus;\n  getResourceLocation: (\n    response: TResponse,\n    state: RestorableOperationState<TState>\n  ) => string | undefined;\n  getPollingInterval?: (response: TResponse) => number | undefined;\n  setDelay: (intervalInMs: number) => void;\n  getOperationLocation?: (\n    response: TResponse,\n    state: RestorableOperationState<TState>\n  ) => string | undefined;\n  withOperationLocation?: (operationLocation: string, isUpdated: boolean) => void;\n  processResult?: (result: TResponse, state: TState) => TResult;\n  updateState?: (state: TState, lastResponse: TResponse) => void;\n  isDone?: (lastResponse: TResponse, state: TState) => boolean;\n  setErrorAsResult: boolean;\n  options?: TOptions;\n}): Promise<void> {\n  const {\n    poll,\n    state,\n    stateProxy,\n    options,\n    getOperationStatus,\n    getResourceLocation,\n    getOperationLocation,\n    withOperationLocation,\n    getPollingInterval,\n    processResult,\n    updateState,\n    setDelay,\n    isDone,\n    setErrorAsResult,\n  } = inputs;\n  const { operationLocation } = state.config;\n  if (operationLocation !== undefined) {\n    const { response, status } = await pollOperationHelper({\n      poll,\n      getOperationStatus,\n      state,\n      stateProxy,\n      operationLocation,\n      getResourceLocation,\n      options,\n    });\n    processOperationStatus({\n      status,\n      response,\n      state,\n      stateProxy,\n      isDone,\n      processResult,\n      setErrorAsResult,\n    });\n\n    if (!terminalStates.includes(status)) {\n      const intervalInMs = getPollingInterval?.(response);\n      if (intervalInMs) setDelay(intervalInMs);\n      const location = getOperationLocation?.(response, state);\n      if (location !== undefined) {\n        const isUpdated = operationLocation !== location;\n        state.config.operationLocation = location;\n        withOperationLocation?.(location, isUpdated);\n      } else withOperationLocation?.(operationLocation, false);\n    }\n    updateState?.(state, response);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}