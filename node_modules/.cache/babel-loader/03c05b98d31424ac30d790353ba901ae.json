{"ast":null,"code":"/*! @azure/msal-common v9.0.1 2022-12-07 */\n'use strict';\n\nimport { __awaiter, __generator, __assign } from '../_virtual/_tslib.js';\nimport { AuthorityType } from './AuthorityType.js';\nimport { isOpenIdConfigResponse } from './OpenIdConfigResponse.js';\nimport { UrlString } from '../url/UrlString.js';\nimport { ClientAuthError } from '../error/ClientAuthError.js';\nimport { Constants, AuthorityMetadataSource, RegionDiscoveryOutcomes } from '../utils/Constants.js';\nimport { EndpointMetadata, InstanceDiscoveryMetadata } from './AuthorityMetadata.js';\nimport { ClientConfigurationError } from '../error/ClientConfigurationError.js';\nimport { ProtocolMode } from './ProtocolMode.js';\nimport { AuthorityMetadataEntity } from '../cache/entities/AuthorityMetadataEntity.js';\nimport { AzureCloudInstance } from './AuthorityOptions.js';\nimport { isCloudInstanceDiscoveryResponse } from './CloudInstanceDiscoveryResponse.js';\nimport { isCloudInstanceDiscoveryErrorResponse } from './CloudInstanceDiscoveryErrorResponse.js';\nimport { RegionDiscovery } from './RegionDiscovery.js';\nimport { AuthError } from '../error/AuthError.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * The authority class validates the authority URIs used by the user, and retrieves the OpenID Configuration Data from the\r\n * endpoint. It will store the pertinent config data in this object for use during token calls.\r\n */\nvar Authority = /** @class */function () {\n  function Authority(authority, networkInterface, cacheManager, authorityOptions, logger, proxyUrl) {\n    this.canonicalAuthority = authority;\n    this._canonicalAuthority.validateAsUri();\n    this.networkInterface = networkInterface;\n    this.cacheManager = cacheManager;\n    this.authorityOptions = authorityOptions;\n    this.regionDiscovery = new RegionDiscovery(networkInterface);\n    this.regionDiscoveryMetadata = {\n      region_used: undefined,\n      region_source: undefined,\n      region_outcome: undefined\n    };\n    this.proxyUrl = proxyUrl || Constants.EMPTY_STRING;\n    this.logger = logger;\n  }\n  Object.defineProperty(Authority.prototype, \"authorityType\", {\n    // See above for AuthorityType\n    get: function get() {\n      var pathSegments = this.canonicalAuthorityUrlComponents.PathSegments;\n      if (pathSegments.length) {\n        switch (pathSegments[0].toLowerCase()) {\n          case Constants.ADFS:\n            return AuthorityType.Adfs;\n          case Constants.DSTS:\n            return AuthorityType.Dsts;\n        }\n      }\n      return AuthorityType.Default;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"protocolMode\", {\n    /**\r\n     * ProtocolMode enum representing the way endpoints are constructed.\r\n     */\n    get: function get() {\n      return this.authorityOptions.protocolMode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"options\", {\n    /**\r\n     * Returns authorityOptions which can be used to reinstantiate a new authority instance\r\n     */\n    get: function get() {\n      return this.authorityOptions;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"canonicalAuthority\", {\n    /**\r\n     * A URL that is the authority set by the developer\r\n     */\n    get: function get() {\n      return this._canonicalAuthority.urlString;\n    },\n    /**\r\n     * Sets canonical authority.\r\n     */\n    set: function set(url) {\n      this._canonicalAuthority = new UrlString(url);\n      this._canonicalAuthority.validateAsUri();\n      this._canonicalAuthorityUrlComponents = null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"canonicalAuthorityUrlComponents\", {\n    /**\r\n     * Get authority components.\r\n     */\n    get: function get() {\n      if (!this._canonicalAuthorityUrlComponents) {\n        this._canonicalAuthorityUrlComponents = this._canonicalAuthority.getUrlComponents();\n      }\n      return this._canonicalAuthorityUrlComponents;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"hostnameAndPort\", {\n    /**\r\n     * Get hostname and port i.e. login.microsoftonline.com\r\n     */\n    get: function get() {\n      return this.canonicalAuthorityUrlComponents.HostNameAndPort.toLowerCase();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"tenant\", {\n    /**\r\n     * Get tenant for authority.\r\n     */\n    get: function get() {\n      return this.canonicalAuthorityUrlComponents.PathSegments[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"authorizationEndpoint\", {\n    /**\r\n     * OAuth /authorize endpoint for requests\r\n     */\n    get: function get() {\n      if (this.discoveryComplete()) {\n        var endpoint = this.replacePath(this.metadata.authorization_endpoint);\n        return this.replaceTenant(endpoint);\n      } else {\n        throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"tokenEndpoint\", {\n    /**\r\n     * OAuth /token endpoint for requests\r\n     */\n    get: function get() {\n      if (this.discoveryComplete()) {\n        var endpoint = this.replacePath(this.metadata.token_endpoint);\n        return this.replaceTenant(endpoint);\n      } else {\n        throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"deviceCodeEndpoint\", {\n    get: function get() {\n      if (this.discoveryComplete()) {\n        var endpoint = this.replacePath(this.metadata.token_endpoint.replace(\"/token\", \"/devicecode\"));\n        return this.replaceTenant(endpoint);\n      } else {\n        throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"endSessionEndpoint\", {\n    /**\r\n     * OAuth logout endpoint for requests\r\n     */\n    get: function get() {\n      if (this.discoveryComplete()) {\n        // ROPC policies may not have end_session_endpoint set\n        if (!this.metadata.end_session_endpoint) {\n          throw ClientAuthError.createLogoutNotSupportedError();\n        }\n        var endpoint = this.replacePath(this.metadata.end_session_endpoint);\n        return this.replaceTenant(endpoint);\n      } else {\n        throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"selfSignedJwtAudience\", {\n    /**\r\n     * OAuth issuer for requests\r\n     */\n    get: function get() {\n      if (this.discoveryComplete()) {\n        var endpoint = this.replacePath(this.metadata.issuer);\n        return this.replaceTenant(endpoint);\n      } else {\n        throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"jwksUri\", {\n    /**\r\n     * Jwks_uri for token signing keys\r\n     */\n    get: function get() {\n      if (this.discoveryComplete()) {\n        var endpoint = this.replacePath(this.metadata.jwks_uri);\n        return this.replaceTenant(endpoint);\n      } else {\n        throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Replaces tenant in url path with current tenant. Defaults to common.\r\n   * @param urlString\r\n   */\n  Authority.prototype.replaceTenant = function (urlString) {\n    return urlString.replace(/{tenant}|{tenantid}/g, this.tenant);\n  };\n  /**\r\n   * Replaces path such as tenant or policy with the current tenant or policy.\r\n   * @param urlString\r\n   */\n  Authority.prototype.replacePath = function (urlString) {\n    var endpoint = urlString;\n    var cachedAuthorityUrl = new UrlString(this.metadata.canonical_authority);\n    var cachedAuthorityParts = cachedAuthorityUrl.getUrlComponents().PathSegments;\n    var currentAuthorityParts = this.canonicalAuthorityUrlComponents.PathSegments;\n    currentAuthorityParts.forEach(function (currentPart, index) {\n      var cachedPart = cachedAuthorityParts[index];\n      if (currentPart !== cachedPart) {\n        endpoint = endpoint.replace(\"/\" + cachedPart + \"/\", \"/\" + currentPart + \"/\");\n      }\n    });\n    return endpoint;\n  };\n  Object.defineProperty(Authority.prototype, \"defaultOpenIdConfigurationEndpoint\", {\n    /**\r\n     * The default open id configuration endpoint for any canonical authority.\r\n     */\n    get: function get() {\n      if (this.authorityType === AuthorityType.Adfs || this.authorityType === AuthorityType.Dsts || this.protocolMode === ProtocolMode.OIDC) {\n        return this.canonicalAuthority + \".well-known/openid-configuration\";\n      }\n      return this.canonicalAuthority + \"v2.0/.well-known/openid-configuration\";\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Boolean that returns whethr or not tenant discovery has been completed.\r\n   */\n  Authority.prototype.discoveryComplete = function () {\n    return !!this.metadata;\n  };\n  /**\r\n   * Perform endpoint discovery to discover aliases, preferred_cache, preferred_network\r\n   * and the /authorize, /token and logout endpoints.\r\n   */\n  Authority.prototype.resolveEndpointsAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var metadataEntity, cloudDiscoverySource, endpointSource, cacheKey;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            metadataEntity = this.cacheManager.getAuthorityMetadataByAlias(this.hostnameAndPort);\n            if (!metadataEntity) {\n              metadataEntity = new AuthorityMetadataEntity();\n              metadataEntity.updateCanonicalAuthority(this.canonicalAuthority);\n            }\n            return [4 /*yield*/, this.updateCloudDiscoveryMetadata(metadataEntity)];\n          case 1:\n            cloudDiscoverySource = _a.sent();\n            this.canonicalAuthority = this.canonicalAuthority.replace(this.hostnameAndPort, metadataEntity.preferred_network);\n            return [4 /*yield*/, this.updateEndpointMetadata(metadataEntity)];\n          case 2:\n            endpointSource = _a.sent();\n            if (cloudDiscoverySource !== AuthorityMetadataSource.CACHE && endpointSource !== AuthorityMetadataSource.CACHE) {\n              // Reset the expiration time unless both values came from a successful cache lookup\n              metadataEntity.resetExpiresAt();\n              metadataEntity.updateCanonicalAuthority(this.canonicalAuthority);\n            }\n            cacheKey = this.cacheManager.generateAuthorityMetadataCacheKey(metadataEntity.preferred_cache);\n            this.cacheManager.setAuthorityMetadata(cacheKey, metadataEntity);\n            this.metadata = metadataEntity;\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\r\n   * Update AuthorityMetadataEntity with new endpoints and return where the information came from\r\n   * @param metadataEntity\r\n   */\n  Authority.prototype.updateEndpointMetadata = function (metadataEntity) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function () {\n      var metadata, harcodedMetadata;\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            metadata = this.getEndpointMetadataFromConfig();\n            if (metadata) {\n              metadataEntity.updateEndpointMetadata(metadata, false);\n              return [2 /*return*/, AuthorityMetadataSource.CONFIG];\n            }\n            if (this.isAuthoritySameType(metadataEntity) && metadataEntity.endpointsFromNetwork && !metadataEntity.isExpired()) {\n              // No need to update\n              return [2 /*return*/, AuthorityMetadataSource.CACHE];\n            }\n            harcodedMetadata = this.getEndpointMetadataFromHardcodedValues();\n            return [4 /*yield*/, this.getEndpointMetadataFromNetwork()];\n          case 1:\n            metadata = _c.sent();\n            if (!metadata) return [3 /*break*/, 4];\n            if (!((_a = this.authorityOptions.azureRegionConfiguration) === null || _a === void 0 ? void 0 : _a.azureRegion)) return [3 /*break*/, 3];\n            return [4 /*yield*/, this.updateMetadataWithRegionalInformation(metadata)];\n          case 2:\n            metadata = _c.sent();\n            _c.label = 3;\n          case 3:\n            metadataEntity.updateEndpointMetadata(metadata, true);\n            return [2 /*return*/, AuthorityMetadataSource.NETWORK];\n          case 4:\n            if (!(harcodedMetadata && !this.authorityOptions.skipAuthorityMetadataCache)) return [3 /*break*/, 7];\n            if (!((_b = this.authorityOptions.azureRegionConfiguration) === null || _b === void 0 ? void 0 : _b.azureRegion)) return [3 /*break*/, 6];\n            return [4 /*yield*/, this.updateMetadataWithRegionalInformation(harcodedMetadata)];\n          case 5:\n            harcodedMetadata = _c.sent();\n            _c.label = 6;\n          case 6:\n            metadataEntity.updateEndpointMetadata(harcodedMetadata, false);\n            return [2 /*return*/, AuthorityMetadataSource.HARDCODED_VALUES];\n          case 7:\n            throw ClientAuthError.createUnableToGetOpenidConfigError(this.defaultOpenIdConfigurationEndpoint);\n        }\n      });\n    });\n  };\n  /**\r\n   * Compares the number of url components after the domain to determine if the cached\r\n   * authority metadata can be used for the requested authority. Protects against same domain different\r\n   * authority such as login.microsoftonline.com/tenant and login.microsoftonline.com/tfp/tenant/policy\r\n   * @param metadataEntity\r\n   */\n  Authority.prototype.isAuthoritySameType = function (metadataEntity) {\n    var cachedAuthorityUrl = new UrlString(metadataEntity.canonical_authority);\n    var cachedParts = cachedAuthorityUrl.getUrlComponents().PathSegments;\n    return cachedParts.length === this.canonicalAuthorityUrlComponents.PathSegments.length;\n  };\n  /**\r\n   * Parse authorityMetadata config option\r\n   */\n  Authority.prototype.getEndpointMetadataFromConfig = function () {\n    if (this.authorityOptions.authorityMetadata) {\n      try {\n        return JSON.parse(this.authorityOptions.authorityMetadata);\n      } catch (e) {\n        throw ClientConfigurationError.createInvalidAuthorityMetadataError();\n      }\n    }\n    return null;\n  };\n  /**\r\n   * Gets OAuth endpoints from the given OpenID configuration endpoint.\r\n   *\r\n   * @param hasHardcodedMetadata boolean\r\n   */\n  Authority.prototype.getEndpointMetadataFromNetwork = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var options, response;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            options = {};\n            if (this.proxyUrl) {\n              options.proxyUrl = this.proxyUrl;\n            }\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n            return [4 /*yield*/, this.networkInterface.sendGetRequestAsync(this.defaultOpenIdConfigurationEndpoint, options)];\n          case 2:\n            response = _a.sent();\n            return [2 /*return*/, isOpenIdConfigResponse(response.body) ? response.body : null];\n          case 3:\n            _a.sent();\n            return [2 /*return*/, null];\n          case 4:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\r\n   * Get OAuth endpoints for common authorities.\r\n   */\n  Authority.prototype.getEndpointMetadataFromHardcodedValues = function () {\n    if (this.canonicalAuthority in EndpointMetadata) {\n      return EndpointMetadata[this.canonicalAuthority];\n    }\n    return null;\n  };\n  /**\r\n   * Update the retrieved metadata with regional information.\r\n   */\n  Authority.prototype.updateMetadataWithRegionalInformation = function (metadata) {\n    var _a, _b, _c, _d, _e;\n    return __awaiter(this, void 0, void 0, function () {\n      var autodetectedRegionName, azureRegion;\n      return __generator(this, function (_f) {\n        switch (_f.label) {\n          case 0:\n            return [4 /*yield*/, this.regionDiscovery.detectRegion((_a = this.authorityOptions.azureRegionConfiguration) === null || _a === void 0 ? void 0 : _a.environmentRegion, this.regionDiscoveryMetadata, this.proxyUrl)];\n          case 1:\n            autodetectedRegionName = _f.sent();\n            azureRegion = ((_b = this.authorityOptions.azureRegionConfiguration) === null || _b === void 0 ? void 0 : _b.azureRegion) === Constants.AZURE_REGION_AUTO_DISCOVER_FLAG ? autodetectedRegionName : (_c = this.authorityOptions.azureRegionConfiguration) === null || _c === void 0 ? void 0 : _c.azureRegion;\n            if (((_d = this.authorityOptions.azureRegionConfiguration) === null || _d === void 0 ? void 0 : _d.azureRegion) === Constants.AZURE_REGION_AUTO_DISCOVER_FLAG) {\n              this.regionDiscoveryMetadata.region_outcome = autodetectedRegionName ? RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_SUCCESSFUL : RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_FAILED;\n            } else {\n              if (autodetectedRegionName) {\n                this.regionDiscoveryMetadata.region_outcome = ((_e = this.authorityOptions.azureRegionConfiguration) === null || _e === void 0 ? void 0 : _e.azureRegion) === autodetectedRegionName ? RegionDiscoveryOutcomes.CONFIGURED_MATCHES_DETECTED : RegionDiscoveryOutcomes.CONFIGURED_NOT_DETECTED;\n              } else {\n                this.regionDiscoveryMetadata.region_outcome = RegionDiscoveryOutcomes.CONFIGURED_NO_AUTO_DETECTION;\n              }\n            }\n            if (azureRegion) {\n              this.regionDiscoveryMetadata.region_used = azureRegion;\n              return [2 /*return*/, Authority.replaceWithRegionalInformation(metadata, azureRegion)];\n            }\n            return [2 /*return*/, metadata];\n        }\n      });\n    });\n  };\n  /**\r\n   * Updates the AuthorityMetadataEntity with new aliases, preferred_network and preferred_cache\r\n   * and returns where the information was retrieved from\r\n   * @param cachedMetadata\r\n   * @param newMetadata\r\n   */\n  Authority.prototype.updateCloudDiscoveryMetadata = function (metadataEntity) {\n    return __awaiter(this, void 0, void 0, function () {\n      var metadata, metadataEntityExpired, harcodedMetadata;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.logger.verbose(\"Attempting to get cloud discovery metadata in the config\");\n            this.logger.verbosePii(\"Known Authorities: \" + (this.authorityOptions.knownAuthorities || Constants.NOT_APPLICABLE));\n            this.logger.verbosePii(\"Authority Metadata: \" + (this.authorityOptions.authorityMetadata || Constants.NOT_APPLICABLE));\n            this.logger.verbosePii(\"Canonical Authority: \" + (metadataEntity.canonical_authority || Constants.NOT_APPLICABLE));\n            metadata = this.getCloudDiscoveryMetadataFromConfig();\n            if (metadata) {\n              this.logger.verbose(\"Found cloud discovery metadata in the config.\");\n              metadataEntity.updateCloudDiscoveryMetadata(metadata, false);\n              return [2 /*return*/, AuthorityMetadataSource.CONFIG];\n            }\n            // If the cached metadata came from config but that config was not passed to this instance, we must go to the network\n            this.logger.verbose(\"Did not find cloud discovery metadata in the config... Attempting to get cloud discovery metadata from the cache.\");\n            metadataEntityExpired = metadataEntity.isExpired();\n            if (this.isAuthoritySameType(metadataEntity) && metadataEntity.aliasesFromNetwork && !metadataEntityExpired) {\n              this.logger.verbose(\"Found metadata in the cache.\");\n              // No need to update\n              return [2 /*return*/, AuthorityMetadataSource.CACHE];\n            } else if (metadataEntityExpired) {\n              this.logger.verbose(\"The metadata entity is expired.\");\n            }\n            this.logger.verbose(\"Did not find cloud discovery metadata in the cache... Attempting to get cloud discovery metadata from the network.\");\n            return [4 /*yield*/, this.getCloudDiscoveryMetadataFromNetwork()];\n          case 1:\n            metadata = _a.sent();\n            if (metadata) {\n              this.logger.verbose(\"cloud discovery metadata was successfully returned from getCloudDiscoveryMetadataFromNetwork()\");\n              metadataEntity.updateCloudDiscoveryMetadata(metadata, true);\n              return [2 /*return*/, AuthorityMetadataSource.NETWORK];\n            }\n            this.logger.verbose(\"Did not find cloud discovery metadata from the network... Attempting to get cloud discovery metadata from hardcoded values.\");\n            harcodedMetadata = this.getCloudDiscoveryMetadataFromHarcodedValues();\n            if (harcodedMetadata && !this.options.skipAuthorityMetadataCache) {\n              this.logger.verbose(\"Found cloud discovery metadata from hardcoded values.\");\n              metadataEntity.updateCloudDiscoveryMetadata(harcodedMetadata, false);\n              return [2 /*return*/, AuthorityMetadataSource.HARDCODED_VALUES];\n            }\n            // Metadata could not be obtained from the config, cache, network or hardcoded values\n            this.logger.error(\"Did not find cloud discovery metadata from hardcoded values... Metadata could not be obtained from config, cache, network or hardcoded values. Throwing Untrusted Authority Error.\");\n            throw ClientConfigurationError.createUntrustedAuthorityError();\n        }\n      });\n    });\n  };\n  /**\r\n   * Parse cloudDiscoveryMetadata config or check knownAuthorities\r\n   */\n  Authority.prototype.getCloudDiscoveryMetadataFromConfig = function () {\n    // Check if network response was provided in config\n    if (this.authorityOptions.cloudDiscoveryMetadata) {\n      this.logger.verbose(\"The cloud discovery metadata has been provided as a network response, in the config.\");\n      try {\n        this.logger.verbose(\"Attempting to parse the cloud discovery metadata.\");\n        var parsedResponse = JSON.parse(this.authorityOptions.cloudDiscoveryMetadata);\n        var metadata = Authority.getCloudDiscoveryMetadataFromNetworkResponse(parsedResponse.metadata, this.hostnameAndPort);\n        this.logger.verbose(\"Parsed the cloud discovery metadata.\");\n        if (metadata) {\n          this.logger.verbose(\"There is returnable metadata attached to the parsed cloud discovery metadata.\");\n          return metadata;\n        } else {\n          this.logger.verbose(\"There is no metadata attached to the parsed cloud discovery metadata.\");\n        }\n      } catch (e) {\n        this.logger.verbose(\"Unable to parse the cloud discovery metadata. Throwing Invalid Cloud Discovery Metadata Error.\");\n        throw ClientConfigurationError.createInvalidCloudDiscoveryMetadataError();\n      }\n    }\n    // If cloudDiscoveryMetadata is empty or does not contain the host, check knownAuthorities\n    if (this.isInKnownAuthorities()) {\n      this.logger.verbose(\"The host is included in knownAuthorities. Creating new cloud discovery metadata from the host.\");\n      return Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);\n    }\n    return null;\n  };\n  /**\r\n   * Called to get metadata from network if CloudDiscoveryMetadata was not populated by config\r\n   *\r\n   * @param hasHardcodedMetadata boolean\r\n   */\n  Authority.prototype.getCloudDiscoveryMetadataFromNetwork = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var instanceDiscoveryEndpoint, options, match, response, typedResponseBody, metadata, error_1, typedError;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            instanceDiscoveryEndpoint = \"\" + Constants.AAD_INSTANCE_DISCOVERY_ENDPT + this.canonicalAuthority + \"oauth2/v2.0/authorize\";\n            options = {};\n            if (this.proxyUrl) {\n              options.proxyUrl = this.proxyUrl;\n            }\n            match = null;\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n            return [4 /*yield*/, this.networkInterface.sendGetRequestAsync(instanceDiscoveryEndpoint, options)];\n          case 2:\n            response = _a.sent();\n            typedResponseBody = void 0;\n            metadata = void 0;\n            if (isCloudInstanceDiscoveryResponse(response.body)) {\n              typedResponseBody = response.body;\n              metadata = typedResponseBody.metadata;\n              this.logger.verbosePii(\"tenant_discovery_endpoint is: \" + typedResponseBody.tenant_discovery_endpoint);\n            } else if (isCloudInstanceDiscoveryErrorResponse(response.body)) {\n              this.logger.warning(\"A CloudInstanceDiscoveryErrorResponse was returned. The cloud instance discovery network request's status code is: \" + response.status);\n              typedResponseBody = response.body;\n              if (typedResponseBody.error === Constants.INVALID_INSTANCE) {\n                this.logger.error(\"The CloudInstanceDiscoveryErrorResponse error is invalid_instance.\");\n                return [2 /*return*/, null];\n              }\n              this.logger.warning(\"The CloudInstanceDiscoveryErrorResponse error is \" + typedResponseBody.error);\n              this.logger.warning(\"The CloudInstanceDiscoveryErrorResponse error description is \" + typedResponseBody.error_description);\n              this.logger.warning(\"Setting the value of the CloudInstanceDiscoveryMetadata (returned from the network) to []\");\n              metadata = [];\n            } else {\n              this.logger.error(\"AAD did not return a CloudInstanceDiscoveryResponse or CloudInstanceDiscoveryErrorResponse\");\n              return [2 /*return*/, null];\n            }\n            this.logger.verbose(\"Attempting to find a match between the developer's authority and the CloudInstanceDiscoveryMetadata returned from the network request.\");\n            match = Authority.getCloudDiscoveryMetadataFromNetworkResponse(metadata, this.hostnameAndPort);\n            return [3 /*break*/, 4];\n          case 3:\n            error_1 = _a.sent();\n            if (error_1 instanceof AuthError) {\n              this.logger.error(\"There was a network error while attempting to get the cloud discovery instance metadata.\\nError: \" + error_1.errorCode + \"\\nError Description: \" + error_1.errorMessage);\n            } else {\n              typedError = error_1;\n              this.logger.error(\"A non-MSALJS error was thrown while attempting to get the cloud instance discovery metadata.\\nError: \" + typedError.name + \"\\nError Description: \" + typedError.message);\n            }\n            return [2 /*return*/, null];\n          case 4:\n            // Custom Domain scenario, host is trusted because Instance Discovery call succeeded\n            if (!match) {\n              this.logger.warning(\"The developer's authority was not found within the CloudInstanceDiscoveryMetadata returned from the network request.\");\n              this.logger.verbose(\"Creating custom Authority for custom domain scenario.\");\n              match = Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);\n            }\n            return [2 /*return*/, match];\n        }\n      });\n    });\n  };\n  /**\r\n   * Get cloud discovery metadata for common authorities\r\n   */\n  Authority.prototype.getCloudDiscoveryMetadataFromHarcodedValues = function () {\n    if (this.canonicalAuthority in InstanceDiscoveryMetadata) {\n      return InstanceDiscoveryMetadata[this.canonicalAuthority];\n    }\n    return null;\n  };\n  /**\r\n   * Helper function to determine if this host is included in the knownAuthorities config option\r\n   */\n  Authority.prototype.isInKnownAuthorities = function () {\n    var _this = this;\n    var matches = this.authorityOptions.knownAuthorities.filter(function (authority) {\n      return UrlString.getDomainFromUrl(authority).toLowerCase() === _this.hostnameAndPort;\n    });\n    return matches.length > 0;\n  };\n  /**\r\n   * helper function to populate the authority based on azureCloudOptions\r\n   * @param authorityString\r\n   * @param azureCloudOptions\r\n   */\n  Authority.generateAuthority = function (authorityString, azureCloudOptions) {\n    var authorityAzureCloudInstance;\n    if (azureCloudOptions && azureCloudOptions.azureCloudInstance !== AzureCloudInstance.None) {\n      var tenant = azureCloudOptions.tenant ? azureCloudOptions.tenant : Constants.DEFAULT_COMMON_TENANT;\n      authorityAzureCloudInstance = azureCloudOptions.azureCloudInstance + \"/\" + tenant + \"/\";\n    }\n    return authorityAzureCloudInstance ? authorityAzureCloudInstance : authorityString;\n  };\n  /**\r\n   * Creates cloud discovery metadata object from a given host\r\n   * @param host\r\n   */\n  Authority.createCloudDiscoveryMetadataFromHost = function (host) {\n    return {\n      preferred_network: host,\n      preferred_cache: host,\n      aliases: [host]\n    };\n  };\n  /**\r\n   * Searches instance discovery network response for the entry that contains the host in the aliases list\r\n   * @param response\r\n   * @param authority\r\n   */\n  Authority.getCloudDiscoveryMetadataFromNetworkResponse = function (response, authority) {\n    for (var i = 0; i < response.length; i++) {\n      var metadata = response[i];\n      if (metadata.aliases.indexOf(authority) > -1) {\n        return metadata;\n      }\n    }\n    return null;\n  };\n  /**\r\n   * helper function to generate environment from authority object\r\n   */\n  Authority.prototype.getPreferredCache = function () {\n    if (this.discoveryComplete()) {\n      return this.metadata.preferred_cache;\n    } else {\n      throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n    }\n  };\n  /**\r\n   * Returns whether or not the provided host is an alias of this authority instance\r\n   * @param host\r\n   */\n  Authority.prototype.isAlias = function (host) {\n    return this.metadata.aliases.indexOf(host) > -1;\n  };\n  /**\r\n   * Checks whether the provided host is that of a public cloud authority\r\n   *\r\n   * @param authority string\r\n   * @returns bool\r\n   */\n  Authority.isPublicCloudAuthority = function (host) {\n    return Constants.KNOWN_PUBLIC_CLOUDS.indexOf(host) >= 0;\n  };\n  /**\r\n   * Rebuild the authority string with the region\r\n   *\r\n   * @param host string\r\n   * @param region string\r\n   */\n  Authority.buildRegionalAuthorityString = function (host, region, queryString) {\n    // Create and validate a Url string object with the initial authority string\n    var authorityUrlInstance = new UrlString(host);\n    authorityUrlInstance.validateAsUri();\n    var authorityUrlParts = authorityUrlInstance.getUrlComponents();\n    var hostNameAndPort = region + \".\" + authorityUrlParts.HostNameAndPort;\n    if (this.isPublicCloudAuthority(authorityUrlParts.HostNameAndPort)) {\n      hostNameAndPort = region + \".\" + Constants.REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX;\n    }\n    // Include the query string portion of the url\n    var url = UrlString.constructAuthorityUriFromObject(__assign(__assign({}, authorityUrlInstance.getUrlComponents()), {\n      HostNameAndPort: hostNameAndPort\n    })).urlString;\n    // Add the query string if a query string was provided\n    if (queryString) return url + \"?\" + queryString;\n    return url;\n  };\n  /**\r\n   * Replace the endpoints in the metadata object with their regional equivalents.\r\n   *\r\n   * @param metadata OpenIdConfigResponse\r\n   * @param azureRegion string\r\n   */\n  Authority.replaceWithRegionalInformation = function (metadata, azureRegion) {\n    metadata.authorization_endpoint = Authority.buildRegionalAuthorityString(metadata.authorization_endpoint, azureRegion);\n    // TODO: Enquire on whether we should leave the query string or remove it before releasing the feature\n    metadata.token_endpoint = Authority.buildRegionalAuthorityString(metadata.token_endpoint, azureRegion, Constants.REGIONAL_AUTH_NON_MSI_QUERY_STRING);\n    if (metadata.end_session_endpoint) {\n      metadata.end_session_endpoint = Authority.buildRegionalAuthorityString(metadata.end_session_endpoint, azureRegion);\n    }\n    return metadata;\n  };\n  return Authority;\n}();\nexport { Authority };","map":{"version":3,"mappings":"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","names":["Authority","networkInterface","cacheManager","authorityOptions","logger","proxyUrl","canonicalAuthority","authority","_canonicalAuthority","validateAsUri","regionDiscovery","RegionDiscovery","regionDiscoveryMetadata","region_used","undefined","region_source","region_outcome","Constants","EMPTY_STRING","Object","get","pathSegments","canonicalAuthorityUrlComponents","PathSegments","length","toLowerCase","ADFS","AuthorityType","Adfs","DSTS","Dsts","Default","protocolMode","urlString","set","url","UrlString","_canonicalAuthorityUrlComponents","getUrlComponents","HostNameAndPort","discoveryComplete","endpoint","replacePath","metadata","authorization_endpoint","replaceTenant","ClientAuthError","createEndpointDiscoveryIncompleteError","token_endpoint","replace","end_session_endpoint","createLogoutNotSupportedError","issuer","jwks_uri","tenant","cachedAuthorityUrl","canonical_authority","cachedAuthorityParts","currentAuthorityParts","forEach","currentPart","index","cachedPart","authorityType","ProtocolMode","OIDC","metadataEntity","getAuthorityMetadataByAlias","hostnameAndPort","AuthorityMetadataEntity","updateCanonicalAuthority","updateCloudDiscoveryMetadata","cloudDiscoverySource","_a","preferred_network","updateEndpointMetadata","endpointSource","AuthorityMetadataSource","CACHE","resetExpiresAt","cacheKey","generateAuthorityMetadataCacheKey","preferred_cache","setAuthorityMetadata","getEndpointMetadataFromConfig","CONFIG","isAuthoritySameType","endpointsFromNetwork","isExpired","harcodedMetadata","getEndpointMetadataFromHardcodedValues","getEndpointMetadataFromNetwork","_c","azureRegionConfiguration","azureRegion","updateMetadataWithRegionalInformation","NETWORK","skipAuthorityMetadataCache","HARDCODED_VALUES","createUnableToGetOpenidConfigError","defaultOpenIdConfigurationEndpoint","cachedParts","authorityMetadata","JSON","parse","e","ClientConfigurationError","createInvalidAuthorityMetadataError","options","sendGetRequestAsync","response","isOpenIdConfigResponse","body","EndpointMetadata","detectRegion","environmentRegion","autodetectedRegionName","_f","AZURE_REGION_AUTO_DISCOVER_FLAG","RegionDiscoveryOutcomes","AUTO_DETECTION_REQUESTED_SUCCESSFUL","AUTO_DETECTION_REQUESTED_FAILED","CONFIGURED_MATCHES_DETECTED","CONFIGURED_NOT_DETECTED","CONFIGURED_NO_AUTO_DETECTION","replaceWithRegionalInformation","verbose","verbosePii","knownAuthorities","NOT_APPLICABLE","getCloudDiscoveryMetadataFromConfig","metadataEntityExpired","aliasesFromNetwork","getCloudDiscoveryMetadataFromNetwork","getCloudDiscoveryMetadataFromHarcodedValues","error","createUntrustedAuthorityError","cloudDiscoveryMetadata","parsedResponse","getCloudDiscoveryMetadataFromNetworkResponse","createInvalidCloudDiscoveryMetadataError","isInKnownAuthorities","createCloudDiscoveryMetadataFromHost","instanceDiscoveryEndpoint","AAD_INSTANCE_DISCOVERY_ENDPT","match","typedResponseBody","isCloudInstanceDiscoveryResponse","tenant_discovery_endpoint","isCloudInstanceDiscoveryErrorResponse","warning","status","INVALID_INSTANCE","error_description","error_1","AuthError","errorCode","errorMessage","typedError","name","message","InstanceDiscoveryMetadata","_this","matches","filter","getDomainFromUrl","authorityString","azureCloudOptions","authorityAzureCloudInstance","azureCloudInstance","AzureCloudInstance","None","DEFAULT_COMMON_TENANT","host","aliases","i","indexOf","KNOWN_PUBLIC_CLOUDS","region","queryString","authorityUrlInstance","authorityUrlParts","hostNameAndPort","isPublicCloudAuthority","REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX","constructAuthorityUriFromObject","buildRegionalAuthorityString","REGIONAL_AUTH_NON_MSI_QUERY_STRING"],"sources":["../../src/authority/Authority.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { AuthorityType } from \"./AuthorityType\";\nimport { isOpenIdConfigResponse, OpenIdConfigResponse } from \"./OpenIdConfigResponse\";\nimport { UrlString } from \"../url/UrlString\";\nimport { IUri } from \"../url/IUri\";\nimport { ClientAuthError } from \"../error/ClientAuthError\";\nimport { INetworkModule } from \"../network/INetworkModule\";\nimport { AuthorityMetadataSource, Constants, RegionDiscoveryOutcomes } from \"../utils/Constants\";\nimport { EndpointMetadata, InstanceDiscoveryMetadata } from \"./AuthorityMetadata\";\nimport { ClientConfigurationError } from \"../error/ClientConfigurationError\";\nimport { ProtocolMode } from \"./ProtocolMode\";\nimport { ICacheManager } from \"../cache/interface/ICacheManager\";\nimport { AuthorityMetadataEntity } from \"../cache/entities/AuthorityMetadataEntity\";\nimport { AuthorityOptions , AzureCloudInstance } from \"./AuthorityOptions\";\nimport { CloudInstanceDiscoveryResponse, isCloudInstanceDiscoveryResponse } from \"./CloudInstanceDiscoveryResponse\";\nimport { CloudInstanceDiscoveryErrorResponse, isCloudInstanceDiscoveryErrorResponse } from \"./CloudInstanceDiscoveryErrorResponse\";\nimport { CloudDiscoveryMetadata } from \"./CloudDiscoveryMetadata\";\nimport { RegionDiscovery } from \"./RegionDiscovery\";\nimport { RegionDiscoveryMetadata } from \"./RegionDiscoveryMetadata\";\nimport { ImdsOptions } from \"./ImdsOptions\";\nimport { AzureCloudOptions } from \"../config/ClientConfiguration\";\nimport { Logger } from \"../logger/Logger\";\nimport { AuthError } from \"../error/AuthError\";\n\n/**\n * The authority class validates the authority URIs used by the user, and retrieves the OpenID Configuration Data from the\n * endpoint. It will store the pertinent config data in this object for use during token calls.\n */\nexport class Authority {\n    // Canonical authority url string\n    private _canonicalAuthority: UrlString;\n    // Canonicaly authority url components\n    private _canonicalAuthorityUrlComponents: IUri | null;\n    // Network interface to make requests with.\n    protected networkInterface: INetworkModule;\n    // Cache Manager to cache network responses\n    protected cacheManager: ICacheManager;\n    // Protocol mode to construct endpoints\n    private authorityOptions: AuthorityOptions;\n    // Authority metadata\n    private metadata: AuthorityMetadataEntity;\n    // Region discovery service\n    private regionDiscovery: RegionDiscovery;\n    // Region discovery metadata\n    public regionDiscoveryMetadata: RegionDiscoveryMetadata;\n    // Proxy url string\n    private proxyUrl: string;\n    // Logger object\n    private logger: Logger;\n\n    constructor(\n        authority: string,\n        networkInterface: INetworkModule,\n        cacheManager: ICacheManager,\n        authorityOptions: AuthorityOptions,\n        logger: Logger,\n        proxyUrl?: string\n    ) {\n        this.canonicalAuthority = authority;\n        this._canonicalAuthority.validateAsUri();\n        this.networkInterface = networkInterface;\n        this.cacheManager = cacheManager;\n        this.authorityOptions = authorityOptions;\n        this.regionDiscovery = new RegionDiscovery(networkInterface);\n        this.regionDiscoveryMetadata = { region_used: undefined, region_source: undefined, region_outcome: undefined };\n        this.proxyUrl = proxyUrl || Constants.EMPTY_STRING;\n        this.logger = logger;\n    }\n\n    // See above for AuthorityType\n    public get authorityType(): AuthorityType {\n        const pathSegments = this.canonicalAuthorityUrlComponents.PathSegments;\n        if (pathSegments.length) {\n            switch(pathSegments[0].toLowerCase()) {\n                case Constants.ADFS:\n                    return AuthorityType.Adfs;\n                case Constants.DSTS:\n                    return AuthorityType.Dsts;\n                default:\n                    break;\n            }\n        }\n        return AuthorityType.Default;\n    }\n\n    /**\n     * ProtocolMode enum representing the way endpoints are constructed.\n     */\n    public get protocolMode(): ProtocolMode {\n        return this.authorityOptions.protocolMode;\n    }\n\n    /**\n     * Returns authorityOptions which can be used to reinstantiate a new authority instance\n     */\n    public get options(): AuthorityOptions {\n        return this.authorityOptions;\n    }\n\n    /**\n     * A URL that is the authority set by the developer\n     */\n    public get canonicalAuthority(): string {\n        return this._canonicalAuthority.urlString;\n    }\n\n    /**\n     * Sets canonical authority.\n     */\n    public set canonicalAuthority(url: string) {\n        this._canonicalAuthority = new UrlString(url);\n        this._canonicalAuthority.validateAsUri();\n        this._canonicalAuthorityUrlComponents = null;\n    }\n\n    /**\n     * Get authority components.\n     */\n    public get canonicalAuthorityUrlComponents(): IUri {\n        if (!this._canonicalAuthorityUrlComponents) {\n            this._canonicalAuthorityUrlComponents = this._canonicalAuthority.getUrlComponents();\n        }\n\n        return this._canonicalAuthorityUrlComponents;\n    }\n\n    /**\n     * Get hostname and port i.e. login.microsoftonline.com\n     */\n    public get hostnameAndPort(): string {\n        return this.canonicalAuthorityUrlComponents.HostNameAndPort.toLowerCase();\n    }\n\n    /**\n     * Get tenant for authority.\n     */\n    public get tenant(): string {\n        return this.canonicalAuthorityUrlComponents.PathSegments[0];\n    }\n\n    /**\n     * OAuth /authorize endpoint for requests\n     */\n    public get authorizationEndpoint(): string {\n        if(this.discoveryComplete()) {\n            const endpoint = this.replacePath(this.metadata.authorization_endpoint);\n            return this.replaceTenant(endpoint);\n        } else {\n            throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n        }\n    }\n\n    /**\n     * OAuth /token endpoint for requests\n     */\n    public get tokenEndpoint(): string {\n        if(this.discoveryComplete()) {\n            const endpoint = this.replacePath(this.metadata.token_endpoint);\n            return this.replaceTenant(endpoint);\n        } else {\n            throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n        }\n    }\n\n    public get deviceCodeEndpoint(): string {\n        if(this.discoveryComplete()) {\n            const endpoint = this.replacePath(this.metadata.token_endpoint.replace(\"/token\", \"/devicecode\"));\n            return this.replaceTenant(endpoint);\n        } else {\n            throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n        }\n    }\n\n    /**\n     * OAuth logout endpoint for requests\n     */\n    public get endSessionEndpoint(): string {\n        if(this.discoveryComplete()) {\n            // ROPC policies may not have end_session_endpoint set\n            if (!this.metadata.end_session_endpoint) {\n                throw ClientAuthError.createLogoutNotSupportedError();\n            }\n            const endpoint = this.replacePath(this.metadata.end_session_endpoint);\n            return this.replaceTenant(endpoint);\n        } else {\n            throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n        }\n    }\n\n    /**\n     * OAuth issuer for requests\n     */\n    public get selfSignedJwtAudience(): string {\n        if(this.discoveryComplete()) {\n            const endpoint = this.replacePath(this.metadata.issuer);\n            return this.replaceTenant(endpoint);\n        } else {\n            throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n        }\n    }\n\n    /**\n     * Jwks_uri for token signing keys\n     */\n    public get jwksUri(): string {\n        if(this.discoveryComplete()) {\n            const endpoint = this.replacePath(this.metadata.jwks_uri);\n            return this.replaceTenant(endpoint);\n        } else {\n            throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n        }\n    }\n\n    /**\n     * Replaces tenant in url path with current tenant. Defaults to common.\n     * @param urlString\n     */\n    private replaceTenant(urlString: string): string {\n        return urlString.replace(/{tenant}|{tenantid}/g, this.tenant);\n    }\n\n    /**\n     * Replaces path such as tenant or policy with the current tenant or policy.\n     * @param urlString\n     */\n    private replacePath(urlString: string): string {\n        let endpoint = urlString;\n        const cachedAuthorityUrl = new UrlString(this.metadata.canonical_authority);\n        const cachedAuthorityParts = cachedAuthorityUrl.getUrlComponents().PathSegments;\n        const currentAuthorityParts = this.canonicalAuthorityUrlComponents.PathSegments;\n\n        currentAuthorityParts.forEach((currentPart, index) => {\n            const cachedPart = cachedAuthorityParts[index];\n            if (currentPart !== cachedPart) {\n                endpoint = endpoint.replace(`/${cachedPart}/`, `/${currentPart}/`);\n            }\n        });\n\n        return endpoint;\n    }\n\n    /**\n     * The default open id configuration endpoint for any canonical authority.\n     */\n    protected get defaultOpenIdConfigurationEndpoint(): string {\n        if (\n            this.authorityType === AuthorityType.Adfs ||\n            this.authorityType === AuthorityType.Dsts ||\n            this.protocolMode === ProtocolMode.OIDC\n        ) {\n            return `${this.canonicalAuthority}.well-known/openid-configuration`;\n        }\n        return `${this.canonicalAuthority}v2.0/.well-known/openid-configuration`;\n    }\n\n    /**\n     * Boolean that returns whethr or not tenant discovery has been completed.\n     */\n    discoveryComplete(): boolean {\n        return !!this.metadata;\n    }\n\n    /**\n     * Perform endpoint discovery to discover aliases, preferred_cache, preferred_network\n     * and the /authorize, /token and logout endpoints.\n     */\n    public async resolveEndpointsAsync(): Promise<void> {\n        let metadataEntity = this.cacheManager.getAuthorityMetadataByAlias(this.hostnameAndPort);\n        if (!metadataEntity) {\n            metadataEntity = new AuthorityMetadataEntity();\n            metadataEntity.updateCanonicalAuthority(this.canonicalAuthority);\n        }\n\n        const cloudDiscoverySource = await this.updateCloudDiscoveryMetadata(metadataEntity);\n        this.canonicalAuthority = this.canonicalAuthority.replace(this.hostnameAndPort, metadataEntity.preferred_network);\n        const endpointSource = await this.updateEndpointMetadata(metadataEntity);\n\n        if (cloudDiscoverySource !== AuthorityMetadataSource.CACHE && endpointSource !== AuthorityMetadataSource.CACHE) {\n            // Reset the expiration time unless both values came from a successful cache lookup\n            metadataEntity.resetExpiresAt();\n            metadataEntity.updateCanonicalAuthority(this.canonicalAuthority);\n        }\n\n        const cacheKey = this.cacheManager.generateAuthorityMetadataCacheKey(metadataEntity.preferred_cache);\n        this.cacheManager.setAuthorityMetadata(cacheKey, metadataEntity);\n        this.metadata = metadataEntity;\n    }\n\n    /**\n     * Update AuthorityMetadataEntity with new endpoints and return where the information came from\n     * @param metadataEntity\n     */\n    private async updateEndpointMetadata(metadataEntity: AuthorityMetadataEntity): Promise<AuthorityMetadataSource> {\n        let metadata = this.getEndpointMetadataFromConfig();\n        if (metadata) {\n            metadataEntity.updateEndpointMetadata(metadata, false);\n            return AuthorityMetadataSource.CONFIG;\n        }\n\n        if (this.isAuthoritySameType(metadataEntity) && metadataEntity.endpointsFromNetwork && !metadataEntity.isExpired()) {\n            // No need to update\n            return AuthorityMetadataSource.CACHE;\n        }\n\n        let harcodedMetadata = this.getEndpointMetadataFromHardcodedValues();\n        metadata = await this.getEndpointMetadataFromNetwork();\n        if (metadata) {\n            // If the user prefers to use an azure region replace the global endpoints with regional information.\n            if (this.authorityOptions.azureRegionConfiguration?.azureRegion) {\n                metadata = await this.updateMetadataWithRegionalInformation(metadata);\n            }\n\n            metadataEntity.updateEndpointMetadata(metadata, true);\n            return AuthorityMetadataSource.NETWORK;\n        }    \n\n        if (harcodedMetadata && !this.authorityOptions.skipAuthorityMetadataCache) {\n            // If the user prefers to use an azure region replace the global endpoints with regional information.\n            if (this.authorityOptions.azureRegionConfiguration?.azureRegion) {\n                harcodedMetadata = await this.updateMetadataWithRegionalInformation(\n                    harcodedMetadata\n                );\n            }\n\n            metadataEntity.updateEndpointMetadata(harcodedMetadata, false);\n            return AuthorityMetadataSource.HARDCODED_VALUES;\n        } else {\n            throw ClientAuthError.createUnableToGetOpenidConfigError(\n                this.defaultOpenIdConfigurationEndpoint\n            );\n        }\n    }\n\n    /**\n     * Compares the number of url components after the domain to determine if the cached \n     * authority metadata can be used for the requested authority. Protects against same domain different \n     * authority such as login.microsoftonline.com/tenant and login.microsoftonline.com/tfp/tenant/policy\n     * @param metadataEntity\n     */\n    private isAuthoritySameType(metadataEntity: AuthorityMetadataEntity): boolean {\n        const cachedAuthorityUrl = new UrlString(metadataEntity.canonical_authority);\n        const cachedParts = cachedAuthorityUrl.getUrlComponents().PathSegments;\n\n        return cachedParts.length === this.canonicalAuthorityUrlComponents.PathSegments.length;\n    }\n\n    /**\n     * Parse authorityMetadata config option\n     */\n    private getEndpointMetadataFromConfig(): OpenIdConfigResponse | null {\n        if (this.authorityOptions.authorityMetadata) {\n            try {\n                return JSON.parse(this.authorityOptions.authorityMetadata) as OpenIdConfigResponse;\n            } catch (e) {\n                throw ClientConfigurationError.createInvalidAuthorityMetadataError();\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Gets OAuth endpoints from the given OpenID configuration endpoint.\n     * \n     * @param hasHardcodedMetadata boolean\n     */\n    private async getEndpointMetadataFromNetwork(): Promise<OpenIdConfigResponse | null> {\n        const options: ImdsOptions = {};\n        if (this.proxyUrl) {\n            options.proxyUrl = this.proxyUrl;\n        }\n\n        /*\n         * TODO: Add a timeout if the authority exists in our library's \n         * hardcoded list of metadata\n         */\n\n        try {\n            const response = await this.networkInterface.\n                sendGetRequestAsync<OpenIdConfigResponse>(this.defaultOpenIdConfigurationEndpoint, options);\n            return isOpenIdConfigResponse(response.body) ? response.body : null;\n        } catch (e) {\n            return null;\n        }\n    }\n\n    /**\n     * Get OAuth endpoints for common authorities.\n     */\n    private getEndpointMetadataFromHardcodedValues(): OpenIdConfigResponse | null {\n        if (this.canonicalAuthority in EndpointMetadata) {\n            return EndpointMetadata[this.canonicalAuthority];\n        }\n\n        return null;\n    }\n\n    /**\n     * Update the retrieved metadata with regional information.\n     */\n    private async updateMetadataWithRegionalInformation(metadata: OpenIdConfigResponse): Promise<OpenIdConfigResponse> {\n        const autodetectedRegionName = await this.regionDiscovery.detectRegion(\n            this.authorityOptions.azureRegionConfiguration?.environmentRegion,\n            this.regionDiscoveryMetadata,\n            this.proxyUrl\n        );\n\n        const azureRegion = \n            this.authorityOptions.azureRegionConfiguration?.azureRegion === Constants.AZURE_REGION_AUTO_DISCOVER_FLAG\n                ? autodetectedRegionName\n                : this.authorityOptions.azureRegionConfiguration?.azureRegion;\n\n        if (this.authorityOptions.azureRegionConfiguration?.azureRegion === Constants.AZURE_REGION_AUTO_DISCOVER_FLAG) {\n            this.regionDiscoveryMetadata.region_outcome = autodetectedRegionName ?\n                RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_SUCCESSFUL :\n                RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_FAILED;\n        } else {\n            if (autodetectedRegionName) {\n                this.regionDiscoveryMetadata.region_outcome = (\n                    this.authorityOptions.azureRegionConfiguration?.azureRegion === autodetectedRegionName\n                ) ?\n                    RegionDiscoveryOutcomes.CONFIGURED_MATCHES_DETECTED :\n                    RegionDiscoveryOutcomes.CONFIGURED_NOT_DETECTED;\n            } else {\n                this.regionDiscoveryMetadata.region_outcome = RegionDiscoveryOutcomes.CONFIGURED_NO_AUTO_DETECTION;\n            }\n        }\n\n        if (azureRegion) {\n            this.regionDiscoveryMetadata.region_used = azureRegion;\n            return Authority.replaceWithRegionalInformation(metadata, azureRegion);\n        }\n\n        return metadata;\n    }\n\n    /**\n     * Updates the AuthorityMetadataEntity with new aliases, preferred_network and preferred_cache\n     * and returns where the information was retrieved from\n     * @param cachedMetadata\n     * @param newMetadata\n     */\n    private async updateCloudDiscoveryMetadata(metadataEntity: AuthorityMetadataEntity): Promise<AuthorityMetadataSource> {\n        this.logger.verbose(\"Attempting to get cloud discovery metadata in the config\");\n        this.logger.verbosePii(`Known Authorities: ${this.authorityOptions.knownAuthorities || Constants.NOT_APPLICABLE}`);\n        this.logger.verbosePii(`Authority Metadata: ${this.authorityOptions.authorityMetadata || Constants.NOT_APPLICABLE}`);\n        this.logger.verbosePii(`Canonical Authority: ${metadataEntity.canonical_authority || Constants.NOT_APPLICABLE}`);\n        let metadata = this.getCloudDiscoveryMetadataFromConfig();\n        if (metadata) {\n            this.logger.verbose(\"Found cloud discovery metadata in the config.\");\n            metadataEntity.updateCloudDiscoveryMetadata(metadata, false);\n            return AuthorityMetadataSource.CONFIG;\n        }\n\n        // If the cached metadata came from config but that config was not passed to this instance, we must go to the network\n        this.logger.verbose(\"Did not find cloud discovery metadata in the config... Attempting to get cloud discovery metadata from the cache.\");\n        const metadataEntityExpired = metadataEntity.isExpired();\n        if (this.isAuthoritySameType(metadataEntity) && metadataEntity.aliasesFromNetwork && !metadataEntityExpired) {\n            this.logger.verbose(\"Found metadata in the cache.\");\n            // No need to update\n            return AuthorityMetadataSource.CACHE;\n        } else if (metadataEntityExpired) {\n            this.logger.verbose(\"The metadata entity is expired.\");\n        }\n\n        this.logger.verbose(\"Did not find cloud discovery metadata in the cache... Attempting to get cloud discovery metadata from the network.\");\n        metadata = await this.getCloudDiscoveryMetadataFromNetwork();\n        if (metadata) {\n            this.logger.verbose(\"cloud discovery metadata was successfully returned from getCloudDiscoveryMetadataFromNetwork()\");\n            metadataEntity.updateCloudDiscoveryMetadata(metadata, true);\n            return AuthorityMetadataSource.NETWORK;\n        }\n        \n        this.logger.verbose(\"Did not find cloud discovery metadata from the network... Attempting to get cloud discovery metadata from hardcoded values.\");\n        const harcodedMetadata = this.getCloudDiscoveryMetadataFromHarcodedValues();\n        if (harcodedMetadata && !this.options.skipAuthorityMetadataCache) {\n            this.logger.verbose(\"Found cloud discovery metadata from hardcoded values.\");\n            metadataEntity.updateCloudDiscoveryMetadata(harcodedMetadata, false);\n            return AuthorityMetadataSource.HARDCODED_VALUES;\n        }\n        \n        // Metadata could not be obtained from the config, cache, network or hardcoded values\n        this.logger.error(\"Did not find cloud discovery metadata from hardcoded values... Metadata could not be obtained from config, cache, network or hardcoded values. Throwing Untrusted Authority Error.\");\n        throw ClientConfigurationError.createUntrustedAuthorityError();\n    }\n\n    /**\n     * Parse cloudDiscoveryMetadata config or check knownAuthorities\n     */\n    private getCloudDiscoveryMetadataFromConfig(): CloudDiscoveryMetadata | null {\n        // Check if network response was provided in config\n        if (this.authorityOptions.cloudDiscoveryMetadata) {\n            this.logger.verbose(\"The cloud discovery metadata has been provided as a network response, in the config.\");\n            try {\n                this.logger.verbose(\"Attempting to parse the cloud discovery metadata.\");\n                const parsedResponse = JSON.parse(this.authorityOptions.cloudDiscoveryMetadata) as CloudInstanceDiscoveryResponse;\n                const metadata = Authority.getCloudDiscoveryMetadataFromNetworkResponse(\n                    parsedResponse.metadata,\n                    this.hostnameAndPort\n                );\n                this.logger.verbose(\"Parsed the cloud discovery metadata.\");\n                if (metadata) {\n                    this.logger.verbose(\"There is returnable metadata attached to the parsed cloud discovery metadata.\");\n                    return metadata;\n                } else {\n                    this.logger.verbose(\"There is no metadata attached to the parsed cloud discovery metadata.\");\n                }\n            } catch (e) {\n                this.logger.verbose(\"Unable to parse the cloud discovery metadata. Throwing Invalid Cloud Discovery Metadata Error.\");\n                throw ClientConfigurationError.createInvalidCloudDiscoveryMetadataError();\n            }\n        }\n\n        // If cloudDiscoveryMetadata is empty or does not contain the host, check knownAuthorities\n        if (this.isInKnownAuthorities()) {\n            this.logger.verbose(\"The host is included in knownAuthorities. Creating new cloud discovery metadata from the host.\");\n            return Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);\n        }\n\n        return null;\n    }\n\n    /**\n     * Called to get metadata from network if CloudDiscoveryMetadata was not populated by config\n     * \n     * @param hasHardcodedMetadata boolean\n     */\n    private async getCloudDiscoveryMetadataFromNetwork(): Promise<CloudDiscoveryMetadata | null> {\n        const instanceDiscoveryEndpoint =\n            `${Constants.AAD_INSTANCE_DISCOVERY_ENDPT}${this.canonicalAuthority}oauth2/v2.0/authorize`;\n        const options: ImdsOptions = {};\n        if (this.proxyUrl) {\n            options.proxyUrl = this.proxyUrl;\n        }\n\n        /*\n         * TODO: Add a timeout if the authority exists in our library's\n         * hardcoded list of metadata\n         */\n\n        let match = null;\n        try {\n            const response =\n                await this.networkInterface.sendGetRequestAsync<CloudInstanceDiscoveryResponse | CloudInstanceDiscoveryErrorResponse>(\n                    instanceDiscoveryEndpoint,\n                    options\n                );\n            \n            let typedResponseBody: CloudInstanceDiscoveryResponse | CloudInstanceDiscoveryErrorResponse;\n            let metadata: Array<CloudDiscoveryMetadata>;\n            if (isCloudInstanceDiscoveryResponse(response.body)) {\n                typedResponseBody = response.body as CloudInstanceDiscoveryResponse;\n                metadata = typedResponseBody.metadata;\n\n                this.logger.verbosePii(`tenant_discovery_endpoint is: ${typedResponseBody.tenant_discovery_endpoint}`);\n            } else if (isCloudInstanceDiscoveryErrorResponse(response.body)) {\n                this.logger.warning(`A CloudInstanceDiscoveryErrorResponse was returned. The cloud instance discovery network request's status code is: ${response.status}`);\n\n                typedResponseBody = response.body as CloudInstanceDiscoveryErrorResponse;\n                if (typedResponseBody.error === Constants.INVALID_INSTANCE) {\n                    this.logger.error(\"The CloudInstanceDiscoveryErrorResponse error is invalid_instance.\");\n                    return null;\n                }\n\n                this.logger.warning(`The CloudInstanceDiscoveryErrorResponse error is ${typedResponseBody.error}`);\n                this.logger.warning(`The CloudInstanceDiscoveryErrorResponse error description is ${typedResponseBody.error_description}`);\n                \n                this.logger.warning(\"Setting the value of the CloudInstanceDiscoveryMetadata (returned from the network) to []\");\n                metadata = [];\n            } else {\n                this.logger.error(\"AAD did not return a CloudInstanceDiscoveryResponse or CloudInstanceDiscoveryErrorResponse\");\n                return null;\n            }\n\n            this.logger.verbose(\"Attempting to find a match between the developer's authority and the CloudInstanceDiscoveryMetadata returned from the network request.\");\n            match = Authority.getCloudDiscoveryMetadataFromNetworkResponse(\n                metadata,\n                this.hostnameAndPort\n            );\n        } catch (error) {\n            if (error instanceof AuthError) {\n                this.logger.error(`There was a network error while attempting to get the cloud discovery instance metadata.\\nError: ${error.errorCode}\\nError Description: ${error.errorMessage}`);\n            } else {\n                const typedError = error as Error;\n                this.logger.error(`A non-MSALJS error was thrown while attempting to get the cloud instance discovery metadata.\\nError: ${typedError.name}\\nError Description: ${typedError.message}`);\n            }\n            \n            return null;\n        }\n\n        // Custom Domain scenario, host is trusted because Instance Discovery call succeeded\n        if (!match) {\n            this.logger.warning(\"The developer's authority was not found within the CloudInstanceDiscoveryMetadata returned from the network request.\");\n            this.logger.verbose(\"Creating custom Authority for custom domain scenario.\");\n\n            match = Authority.createCloudDiscoveryMetadataFromHost(\n                this.hostnameAndPort\n            );\n        }\n        return match;\n    }\n\n    /**\n     * Get cloud discovery metadata for common authorities \n     */\n    private getCloudDiscoveryMetadataFromHarcodedValues(): CloudDiscoveryMetadata | null {\n        if (this.canonicalAuthority in InstanceDiscoveryMetadata) {\n            return InstanceDiscoveryMetadata[this.canonicalAuthority];\n        }\n\n        return null;\n    }\n\n    /**\n     * Helper function to determine if this host is included in the knownAuthorities config option\n     */\n    private isInKnownAuthorities(): boolean {\n        const matches = this.authorityOptions.knownAuthorities.filter((authority) => {\n            return UrlString.getDomainFromUrl(authority).toLowerCase() === this.hostnameAndPort;\n        });\n\n        return matches.length > 0;\n    }\n\n    /**\n     * helper function to populate the authority based on azureCloudOptions\n     * @param authorityString\n     * @param azureCloudOptions\n     */\n    static generateAuthority(authorityString: string, azureCloudOptions?: AzureCloudOptions): string {\n        let authorityAzureCloudInstance;\n\n        if (azureCloudOptions && azureCloudOptions.azureCloudInstance !== AzureCloudInstance.None) {\n            const tenant = azureCloudOptions.tenant ? azureCloudOptions.tenant : Constants.DEFAULT_COMMON_TENANT;\n            authorityAzureCloudInstance = `${azureCloudOptions.azureCloudInstance}/${tenant}/`;\n        }\n\n        return authorityAzureCloudInstance ? authorityAzureCloudInstance : authorityString;\n    }\n\n    /**\n     * Creates cloud discovery metadata object from a given host\n     * @param host\n     */\n    static createCloudDiscoveryMetadataFromHost(host: string): CloudDiscoveryMetadata {\n        return {\n            preferred_network: host,\n            preferred_cache: host,\n            aliases: [host]\n        };\n    }\n\n    /**\n     * Searches instance discovery network response for the entry that contains the host in the aliases list\n     * @param response\n     * @param authority\n     */\n    static getCloudDiscoveryMetadataFromNetworkResponse(\n        response: CloudDiscoveryMetadata[],\n        authority: string\n    ): CloudDiscoveryMetadata | null {\n        for (let i = 0; i < response.length; i++) {\n            const metadata = response[i];\n            if (metadata.aliases.indexOf(authority) > -1) {\n                return metadata;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * helper function to generate environment from authority object\n     */\n    getPreferredCache(): string {\n        if(this.discoveryComplete()) {\n            return this.metadata.preferred_cache;\n        } else {\n            throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n        }\n    }\n\n    /**\n     * Returns whether or not the provided host is an alias of this authority instance\n     * @param host\n     */\n    isAlias(host: string): boolean {\n        return this.metadata.aliases.indexOf(host) > -1;\n    }\n\n    /**\n     * Checks whether the provided host is that of a public cloud authority\n     *\n     * @param authority string\n     * @returns bool\n     */\n    static isPublicCloudAuthority(host: string): boolean {\n        return Constants.KNOWN_PUBLIC_CLOUDS.indexOf(host) >= 0;\n    }\n\n    /**\n     * Rebuild the authority string with the region\n     *\n     * @param host string\n     * @param region string\n     */\n    static buildRegionalAuthorityString(host: string, region: string, queryString?: string): string {\n        // Create and validate a Url string object with the initial authority string\n        const authorityUrlInstance = new UrlString(host);\n        authorityUrlInstance.validateAsUri();\n\n        const authorityUrlParts = authorityUrlInstance.getUrlComponents();\n\n        let hostNameAndPort= `${region}.${authorityUrlParts.HostNameAndPort}`;\n\n        if (this.isPublicCloudAuthority(authorityUrlParts.HostNameAndPort)) {\n            hostNameAndPort = `${region}.${Constants.REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX}`;\n        }\n\n        // Include the query string portion of the url\n        const url = UrlString.constructAuthorityUriFromObject({\n            ...authorityUrlInstance.getUrlComponents(),\n            HostNameAndPort: hostNameAndPort\n        }).urlString;\n\n        // Add the query string if a query string was provided\n        if (queryString) return `${url}?${queryString}`;\n\n        return url;\n    }\n\n    /**\n     * Replace the endpoints in the metadata object with their regional equivalents.\n     *\n     * @param metadata OpenIdConfigResponse\n     * @param azureRegion string\n     */\n    static replaceWithRegionalInformation(metadata: OpenIdConfigResponse, azureRegion: string): OpenIdConfigResponse {\n        metadata.authorization_endpoint = Authority.buildRegionalAuthorityString(metadata.authorization_endpoint, azureRegion);\n        // TODO: Enquire on whether we should leave the query string or remove it before releasing the feature\n        metadata.token_endpoint = Authority.buildRegionalAuthorityString(\n            metadata.token_endpoint, azureRegion, Constants.REGIONAL_AUTH_NON_MSI_QUERY_STRING\n        );\n\n        if (metadata.end_session_endpoint) {\n            metadata.end_session_endpoint = Authority.buildRegionalAuthorityString(metadata.end_session_endpoint, azureRegion);\n        }\n\n        return metadata;\n    }\n}\n\n"]},"metadata":{},"sourceType":"module"}