{"ast":null,"code":"/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport { CryptoUtils } from \"./CryptoUtils\";\nimport { StringUtils } from \"./StringUtils\";\nimport { TimeUtils } from \"./TimeUtils\";\n/**\n * @hidden\n */\nvar TokenUtils = /** @class */function () {\n  function TokenUtils() {}\n  /**\n   * decode a JWT\n   *\n   * @param jwtToken\n   */\n  TokenUtils.decodeJwt = function (jwtToken) {\n    if (StringUtils.isEmpty(jwtToken)) {\n      return null;\n    }\n    var idTokenPartsRegex = /^([^\\.\\s]*)\\.([^\\.\\s]+)\\.([^\\.\\s]*)$/;\n    var matches = idTokenPartsRegex.exec(jwtToken);\n    if (!matches || matches.length < 4) {\n      // this._requestContext.logger.warn(\"The returned id_token is not parseable.\");\n      return null;\n    }\n    var crackedToken = {\n      header: matches[1],\n      JWSPayload: matches[2],\n      JWSSig: matches[3]\n    };\n    return crackedToken;\n  };\n  /**\n   * Evaluates whether token cache item expiration is within expiration offset range\n   * @param tokenCacheItem\n   */\n  TokenUtils.validateExpirationIsWithinOffset = function (expiration, tokenRenewalOffsetSeconds) {\n    var offset = tokenRenewalOffsetSeconds || 300;\n    return expiration && expiration > TimeUtils.now() + offset;\n  };\n  /**\n   * Extract IdToken by decoding the RAWIdToken\n   *\n   * @param encodedIdToken\n   */\n  TokenUtils.extractIdToken = function (encodedIdToken) {\n    // id token will be decoded to get the username\n    var decodedToken = this.decodeJwt(encodedIdToken);\n    if (!decodedToken) {\n      return null;\n    }\n    try {\n      var base64IdToken = decodedToken[\"JWSPayload\"];\n      var base64Decoded = CryptoUtils.base64Decode(base64IdToken);\n      if (!base64Decoded) {\n        // this._requestContext.logger.info(\"The returned id_token could not be base64 url safe decoded.\");\n        return null;\n      }\n      // ECMA script has JSON built-in support\n      return JSON.parse(base64Decoded);\n    } catch (err) {\n      // this._requestContext.logger.error(\"The returned id_token could not be decoded\" + err);\n    }\n    return null;\n  };\n  return TokenUtils;\n}();\nexport { TokenUtils };","map":{"version":3,"mappings":"AAAA;;;;AAKA,SAASA,WAAW,QAAQ,eAAe;AAC3C,SAASC,WAAW,QAAQ,eAAe;AAC3C,SAASC,SAAS,QAAQ,aAAa;AAEvC;;;AAGA;EAAA,uBA4DA;EA1DI;;;;;EAKOC,oBAAS,GAAhB,UAAiBC,QAAgB;IAC7B,IAAIH,WAAW,CAACI,OAAO,CAACD,QAAQ,CAAC,EAAE;MAC/B,OAAO,IAAI;;IAEf,IAAME,iBAAiB,GAAG,sCAAsC;IAChE,IAAMC,OAAO,GAAGD,iBAAiB,CAACE,IAAI,CAACJ,QAAQ,CAAC;IAChD,IAAI,CAACG,OAAO,IAAIA,OAAO,CAACE,MAAM,GAAG,CAAC,EAAE;MAChC;MACA,OAAO,IAAI;;IAEf,IAAMC,YAAY,GAAG;MACjBC,MAAM,EAAEJ,OAAO,CAAC,CAAC,CAAC;MAClBK,UAAU,EAAEL,OAAO,CAAC,CAAC,CAAC;MACtBM,MAAM,EAAEN,OAAO,CAAC,CAAC;KACpB;IACD,OAAOG,YAAY;EACvB,CAAC;EAED;;;;EAIOP,2CAAgC,GAAvC,UAAwCW,UAAkB,EAAEC,yBAAiC;IACzF,IAAMC,MAAM,GAAGD,yBAAyB,IAAI,GAAG;IAC/C,OAAOD,UAAU,IAAKA,UAAU,GAAGZ,SAAS,CAACe,GAAG,EAAE,GAAGD,MAAO;EAChE,CAAC;EAED;;;;;EAKOb,yBAAc,GAArB,UAAsBe,cAAsB;IAC5C;IACI,IAAMC,YAAY,GAAG,IAAI,CAACC,SAAS,CAACF,cAAc,CAAC;IACnD,IAAI,CAACC,YAAY,EAAE;MACf,OAAO,IAAI;;IAEf,IAAI;MACA,IAAME,aAAa,GAAGF,YAAY,CAAC,YAAY,CAAC;MAChD,IAAMG,aAAa,GAAGtB,WAAW,CAACuB,YAAY,CAACF,aAAa,CAAC;MAC7D,IAAI,CAACC,aAAa,EAAE;QAChB;QACA,OAAO,IAAI;;MAEf;MACA,OAAOE,IAAI,CAACC,KAAK,CAACH,aAAa,CAAC;KACnC,CAAC,OAAOI,GAAG,EAAE;MACV;IAAA;IAGJ,OAAO,IAAI;EACf,CAAC;EACL,iBAAC;AAAD,CAAC,EA5DD","names":["CryptoUtils","StringUtils","TimeUtils","TokenUtils","jwtToken","isEmpty","idTokenPartsRegex","matches","exec","length","crackedToken","header","JWSPayload","JWSSig","expiration","tokenRenewalOffsetSeconds","offset","now","encodedIdToken","decodedToken","decodeJwt","base64IdToken","base64Decoded","base64Decode","JSON","parse","err"],"sourceRoot":"","sources":["../../src/utils/TokenUtils.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}