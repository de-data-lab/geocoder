{"ast":null,"code":"import _asyncToGenerator from \"/Users/tbeckett/Documents/TI - Project Info/JavaScript_end_to_end_client_file_upload_to_Azure_Storage_Blobs/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/tbeckett/Documents/TI - Project Info/JavaScript_end_to_end_client_file_upload_to_Azure_Storage_Blobs/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/tbeckett/Documents/TI - Project Info/JavaScript_end_to_end_client_file_upload_to_Azure_Storage_Blobs/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/tbeckett/Documents/TI - Project Info/JavaScript_end_to_end_client_file_upload_to_Azure_Storage_Blobs/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/tbeckett/Documents/TI - Project Info/JavaScript_end_to_end_client_file_upload_to_Azure_Storage_Blobs/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { delay as _delay } from \"@azure/core-http\";\nimport { Poller } from \"@azure/core-lro\";\n/**\n * This is the poller returned by {@link BlobClient.beginCopyFromURL}.\n * This can not be instantiated directly outside of this package.\n *\n * @hidden\n */\nexport var BlobBeginCopyFromUrlPoller = /*#__PURE__*/function (_Poller) {\n  _inherits(BlobBeginCopyFromUrlPoller, _Poller);\n  var _super = _createSuper(BlobBeginCopyFromUrlPoller);\n  function BlobBeginCopyFromUrlPoller(options) {\n    var _this;\n    _classCallCheck(this, BlobBeginCopyFromUrlPoller);\n    var blobClient = options.blobClient,\n      copySource = options.copySource,\n      _options$intervalInMs = options.intervalInMs,\n      intervalInMs = _options$intervalInMs === void 0 ? 15000 : _options$intervalInMs,\n      onProgress = options.onProgress,\n      resumeFrom = options.resumeFrom,\n      startCopyFromURLOptions = options.startCopyFromURLOptions;\n    var state;\n    if (resumeFrom) {\n      state = JSON.parse(resumeFrom).state;\n    }\n    var operation = makeBlobBeginCopyFromURLPollOperation(Object.assign(Object.assign({}, state), {\n      blobClient: blobClient,\n      copySource: copySource,\n      startCopyFromURLOptions: startCopyFromURLOptions\n    }));\n    _this = _super.call(this, operation);\n    if (typeof onProgress === \"function\") {\n      _this.onProgress(onProgress);\n    }\n    _this.intervalInMs = intervalInMs;\n    return _this;\n  }\n  _createClass(BlobBeginCopyFromUrlPoller, [{\n    key: \"delay\",\n    value: function delay() {\n      return _delay(this.intervalInMs);\n    }\n  }]);\n  return BlobBeginCopyFromUrlPoller;\n}(Poller);\n/**\n * Note: Intentionally using function expression over arrow function expression\n * so that the function can be invoked with a different context.\n * This affects what `this` refers to.\n * @hidden\n */\nvar cancel = /*#__PURE__*/function () {\n  var _cancel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var options,\n      state,\n      copyId,\n      _args = arguments;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            options = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};\n            state = this.state;\n            copyId = state.copyId;\n            if (!state.isCompleted) {\n              _context.next = 5;\n              break;\n            }\n            return _context.abrupt(\"return\", makeBlobBeginCopyFromURLPollOperation(state));\n          case 5:\n            if (copyId) {\n              _context.next = 8;\n              break;\n            }\n            state.isCancelled = true;\n            return _context.abrupt(\"return\", makeBlobBeginCopyFromURLPollOperation(state));\n          case 8:\n            _context.next = 10;\n            return state.blobClient.abortCopyFromURL(copyId, {\n              abortSignal: options.abortSignal\n            });\n          case 10:\n            state.isCancelled = true;\n            return _context.abrupt(\"return\", makeBlobBeginCopyFromURLPollOperation(state));\n          case 12:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, this);\n  }));\n  function cancel() {\n    return _cancel.apply(this, arguments);\n  }\n  return cancel;\n}();\n/**\n * Note: Intentionally using function expression over arrow function expression\n * so that the function can be invoked with a different context.\n * This affects what `this` refers to.\n * @hidden\n */\nvar update = /*#__PURE__*/function () {\n  var _update = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n    var options,\n      state,\n      blobClient,\n      copySource,\n      startCopyFromURLOptions,\n      result,\n      _result,\n      copyStatus,\n      copyProgress,\n      prevCopyProgress,\n      _args2 = arguments;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            options = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};\n            state = this.state;\n            blobClient = state.blobClient, copySource = state.copySource, startCopyFromURLOptions = state.startCopyFromURLOptions;\n            if (state.isStarted) {\n              _context2.next = 12;\n              break;\n            }\n            state.isStarted = true;\n            _context2.next = 7;\n            return blobClient.startCopyFromURL(copySource, startCopyFromURLOptions);\n          case 7:\n            result = _context2.sent;\n            // copyId is needed to abort\n            state.copyId = result.copyId;\n            if (result.copyStatus === \"success\") {\n              state.result = result;\n              state.isCompleted = true;\n            }\n            _context2.next = 27;\n            break;\n          case 12:\n            if (state.isCompleted) {\n              _context2.next = 27;\n              break;\n            }\n            _context2.prev = 13;\n            _context2.next = 16;\n            return state.blobClient.getProperties({\n              abortSignal: options.abortSignal\n            });\n          case 16:\n            _result = _context2.sent;\n            copyStatus = _result.copyStatus, copyProgress = _result.copyProgress;\n            prevCopyProgress = state.copyProgress;\n            if (copyProgress) {\n              state.copyProgress = copyProgress;\n            }\n            if (copyStatus === \"pending\" && copyProgress !== prevCopyProgress && typeof options.fireProgress === \"function\") {\n              // trigger in setTimeout, or swallow error?\n              options.fireProgress(state);\n            } else if (copyStatus === \"success\") {\n              state.result = _result;\n              state.isCompleted = true;\n            } else if (copyStatus === \"failed\") {\n              state.error = new Error(\"Blob copy failed with reason: \\\"\".concat(_result.copyStatusDescription || \"unknown\", \"\\\"\"));\n              state.isCompleted = true;\n            }\n            _context2.next = 27;\n            break;\n          case 23:\n            _context2.prev = 23;\n            _context2.t0 = _context2[\"catch\"](13);\n            state.error = _context2.t0;\n            state.isCompleted = true;\n          case 27:\n            return _context2.abrupt(\"return\", makeBlobBeginCopyFromURLPollOperation(state));\n          case 28:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, this, [[13, 23]]);\n  }));\n  function update() {\n    return _update.apply(this, arguments);\n  }\n  return update;\n}();\n/**\n * Note: Intentionally using function expression over arrow function expression\n * so that the function can be invoked with a different context.\n * This affects what `this` refers to.\n * @hidden\n */\nvar toString = function toString() {\n  return JSON.stringify({\n    state: this.state\n  }, function (key, value) {\n    // remove blobClient from serialized state since a client can't be hydrated from this info.\n    if (key === \"blobClient\") {\n      return undefined;\n    }\n    return value;\n  });\n};\n/**\n * Creates a poll operation given the provided state.\n * @hidden\n */\nfunction makeBlobBeginCopyFromURLPollOperation(state) {\n  return {\n    state: Object.assign({}, state),\n    cancel: cancel,\n    toString: toString,\n    update: update\n  };\n}","map":{"version":3,"mappings":"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","names":["delay","Poller","BlobBeginCopyFromUrlPoller","options","blobClient","copySource","intervalInMs","onProgress","resumeFrom","startCopyFromURLOptions","state","JSON","parse","operation","makeBlobBeginCopyFromURLPollOperation","cancel","copyId","isCompleted","isCancelled","abortCopyFromURL","abortSignal","update","isStarted","startCopyFromURL","result","copyStatus","getProperties","copyProgress","prevCopyProgress","fireProgress","error","Error","copyStatusDescription","toString","stringify","key","value","undefined"],"sourceRoot":"","sources":["../../../../src/pollers/BlobStartCopyFromUrlPoller.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { delay } from \"@azure/core-http\";\nimport { PollOperation, PollOperationState, Poller } from \"@azure/core-lro\";\nimport { BlobClient, BlobStartCopyFromURLOptions, BlobBeginCopyFromURLResponse } from \"../Clients\";\n\n/**\n * Defines the operations from a {@link BlobClient} that are needed for the poller\n * returned by {@link BlobClient.beginCopyFromURL} to work.\n */\nexport type CopyPollerBlobClient = Pick<BlobClient, \"abortCopyFromURL\" | \"getProperties\"> & {\n  startCopyFromURL(\n    copySource: string,\n    options?: BlobStartCopyFromURLOptions\n  ): Promise<BlobBeginCopyFromURLResponse>;\n};\n\n/**\n * The state used by the poller returned from {@link BlobClient.beginCopyFromURL}.\n *\n * This state is passed into the user-specified `onProgress` callback\n * whenever copy progress is detected.\n */\nexport interface BlobBeginCopyFromUrlPollState\n  extends PollOperationState<BlobBeginCopyFromURLResponse> {\n  /**\n   * The instance of {@link BlobClient} that was used when calling {@link BlobClient.beginCopyFromURL}.\n   */\n  readonly blobClient: CopyPollerBlobClient;\n  /**\n   * The copyId that identifies the in-progress blob copy.\n   */\n  copyId?: string;\n  /**\n   * the progress of the blob copy as reported by the service.\n   */\n  copyProgress?: string;\n  /**\n   * The source URL provided in {@link BlobClient.beginCopyFromURL}.\n   */\n  copySource: string;\n  /**\n   * The options that were passed to the initial {@link BlobClient.beginCopyFromURL} call.\n   * This is exposed for the poller and should not be modified directly.\n   */\n  readonly startCopyFromURLOptions?: BlobStartCopyFromURLOptions;\n}\n\n/**\n * The PollOperation responsible for:\n *  - performing the initial startCopyFromURL\n *  - checking the copy status via getProperties\n *  - cancellation via abortCopyFromURL\n * @hidden\n */\nexport interface BlobBeginCopyFromURLPollOperation\n  extends PollOperation<BlobBeginCopyFromUrlPollState, BlobBeginCopyFromURLResponse> {}\n\n/**\n * The set of options used to configure the poller.\n * This is an internal interface populated by {@link BlobClient.beginCopyFromURL}.\n *\n * @hidden\n */\nexport interface BlobBeginCopyFromUrlPollerOptions {\n  blobClient: CopyPollerBlobClient;\n  copySource: string;\n  intervalInMs?: number;\n  onProgress?: (state: BlobBeginCopyFromUrlPollState) => void;\n  resumeFrom?: string;\n  startCopyFromURLOptions?: BlobStartCopyFromURLOptions;\n}\n\n/**\n * This is the poller returned by {@link BlobClient.beginCopyFromURL}.\n * This can not be instantiated directly outside of this package.\n *\n * @hidden\n */\nexport class BlobBeginCopyFromUrlPoller extends Poller<\n  BlobBeginCopyFromUrlPollState,\n  BlobBeginCopyFromURLResponse\n> {\n  public intervalInMs: number;\n\n  constructor(options: BlobBeginCopyFromUrlPollerOptions) {\n    const {\n      blobClient,\n      copySource,\n      intervalInMs = 15000,\n      onProgress,\n      resumeFrom,\n      startCopyFromURLOptions,\n    } = options;\n\n    let state: BlobBeginCopyFromUrlPollState | undefined;\n\n    if (resumeFrom) {\n      state = JSON.parse(resumeFrom).state;\n    }\n\n    const operation = makeBlobBeginCopyFromURLPollOperation({\n      ...state,\n      blobClient,\n      copySource,\n      startCopyFromURLOptions,\n    });\n\n    super(operation);\n\n    if (typeof onProgress === \"function\") {\n      this.onProgress(onProgress);\n    }\n\n    this.intervalInMs = intervalInMs;\n  }\n\n  public delay(): Promise<void> {\n    return delay(this.intervalInMs);\n  }\n}\n\n/**\n * Note: Intentionally using function expression over arrow function expression\n * so that the function can be invoked with a different context.\n * This affects what `this` refers to.\n * @hidden\n */\nconst cancel: BlobBeginCopyFromURLPollOperation[\"cancel\"] = async function cancel(\n  this: BlobBeginCopyFromURLPollOperation,\n  options = {}\n) {\n  const state = this.state;\n  const { copyId } = state;\n  if (state.isCompleted) {\n    return makeBlobBeginCopyFromURLPollOperation(state);\n  }\n\n  if (!copyId) {\n    state.isCancelled = true;\n    return makeBlobBeginCopyFromURLPollOperation(state);\n  }\n\n  // if abortCopyFromURL throws, it will bubble up to user's poller.cancelOperation call\n  await state.blobClient.abortCopyFromURL(copyId, {\n    abortSignal: options.abortSignal,\n  });\n  state.isCancelled = true;\n\n  return makeBlobBeginCopyFromURLPollOperation(state);\n};\n\n/**\n * Note: Intentionally using function expression over arrow function expression\n * so that the function can be invoked with a different context.\n * This affects what `this` refers to.\n * @hidden\n */\nconst update: BlobBeginCopyFromURLPollOperation[\"update\"] = async function update(\n  this: BlobBeginCopyFromURLPollOperation,\n  options = {}\n): Promise<BlobBeginCopyFromURLPollOperation> {\n  const state = this.state;\n  const { blobClient, copySource, startCopyFromURLOptions } = state;\n\n  if (!state.isStarted) {\n    state.isStarted = true;\n    const result = await blobClient.startCopyFromURL(copySource, startCopyFromURLOptions);\n\n    // copyId is needed to abort\n    state.copyId = result.copyId;\n    if (result.copyStatus === \"success\") {\n      state.result = result;\n      state.isCompleted = true;\n    }\n  } else if (!state.isCompleted) {\n    try {\n      const result = await state.blobClient.getProperties({ abortSignal: options.abortSignal });\n      const { copyStatus, copyProgress } = result;\n      const prevCopyProgress = state.copyProgress;\n      if (copyProgress) {\n        state.copyProgress = copyProgress;\n      }\n      if (\n        copyStatus === \"pending\" &&\n        copyProgress !== prevCopyProgress &&\n        typeof options.fireProgress === \"function\"\n      ) {\n        // trigger in setTimeout, or swallow error?\n        options.fireProgress(state);\n      } else if (copyStatus === \"success\") {\n        state.result = result;\n        state.isCompleted = true;\n      } else if (copyStatus === \"failed\") {\n        state.error = new Error(\n          `Blob copy failed with reason: \"${result.copyStatusDescription || \"unknown\"}\"`\n        );\n        state.isCompleted = true;\n      }\n    } catch (err: any) {\n      state.error = err;\n      state.isCompleted = true;\n    }\n  }\n\n  return makeBlobBeginCopyFromURLPollOperation(state);\n};\n\n/**\n * Note: Intentionally using function expression over arrow function expression\n * so that the function can be invoked with a different context.\n * This affects what `this` refers to.\n * @hidden\n */\nconst toString: BlobBeginCopyFromURLPollOperation[\"toString\"] = function toString(\n  this: BlobBeginCopyFromURLPollOperation\n) {\n  return JSON.stringify({ state: this.state }, (key, value) => {\n    // remove blobClient from serialized state since a client can't be hydrated from this info.\n    if (key === \"blobClient\") {\n      return undefined;\n    }\n    return value;\n  });\n};\n\n/**\n * Creates a poll operation given the provided state.\n * @hidden\n */\nfunction makeBlobBeginCopyFromURLPollOperation(\n  state: BlobBeginCopyFromUrlPollState\n): BlobBeginCopyFromURLPollOperation {\n  return {\n    state: { ...state },\n    cancel,\n    toString,\n    update,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}