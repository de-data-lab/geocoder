{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/tbeckett/Documents/TI - Project Info/JavaScript_end_to_end_client_file_upload_to_Azure_Storage_Blobs/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"/Users/tbeckett/Documents/TI - Project Info/JavaScript_end_to_end_client_file_upload_to_Azure_Storage_Blobs/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/tbeckett/Documents/TI - Project Info/JavaScript_end_to_end_client_file_upload_to_Azure_Storage_Blobs/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { HttpHeaders } from \"./httpHeaders\";\nimport { AbortError } from \"@azure/abort-controller\";\nimport { RestError } from \"./restError\";\n/**\n * A HttpClient implementation that uses XMLHttpRequest to send HTTP requests.\n */\nexport var XhrHttpClient = /*#__PURE__*/function () {\n  function XhrHttpClient() {\n    _classCallCheck(this, XhrHttpClient);\n  }\n  _createClass(XhrHttpClient, [{\n    key: \"sendRequest\",\n    value: function sendRequest(request) {\n      var _a;\n      var xhr = new XMLHttpRequest();\n      if (request.proxySettings) {\n        throw new Error(\"HTTP proxy is not supported in browser environment\");\n      }\n      var abortSignal = request.abortSignal;\n      if (abortSignal) {\n        if (abortSignal.aborted) {\n          return Promise.reject(new AbortError(\"The operation was aborted.\"));\n        }\n        var listener = function listener() {\n          xhr.abort();\n        };\n        abortSignal.addEventListener(\"abort\", listener);\n        xhr.addEventListener(\"readystatechange\", function () {\n          if (xhr.readyState === XMLHttpRequest.DONE) {\n            abortSignal.removeEventListener(\"abort\", listener);\n          }\n        });\n      }\n      addProgressListener(xhr.upload, request.onUploadProgress);\n      addProgressListener(xhr, request.onDownloadProgress);\n      if (request.formData) {\n        var formData = request.formData;\n        var requestForm = new FormData();\n        var appendFormValue = function appendFormValue(key, value) {\n          if (value && Object.prototype.hasOwnProperty.call(value, \"value\") && Object.prototype.hasOwnProperty.call(value, \"options\")) {\n            requestForm.append(key, value.value, value.options);\n          } else {\n            requestForm.append(key, value);\n          }\n        };\n        for (var _i = 0, _Object$keys = Object.keys(formData); _i < _Object$keys.length; _i++) {\n          var formKey = _Object$keys[_i];\n          var formValue = formData[formKey];\n          if (Array.isArray(formValue)) {\n            for (var j = 0; j < formValue.length; j++) {\n              appendFormValue(formKey, formValue[j]);\n            }\n          } else {\n            appendFormValue(formKey, formValue);\n          }\n        }\n        request.body = requestForm;\n        request.formData = undefined;\n        var contentType = request.headers.get(\"Content-Type\");\n        if (contentType && contentType.indexOf(\"multipart/form-data\") !== -1) {\n          // browser will automatically apply a suitable content-type header\n          request.headers.remove(\"Content-Type\");\n        }\n      }\n      xhr.open(request.method, request.url);\n      xhr.timeout = request.timeout;\n      xhr.withCredentials = request.withCredentials;\n      var _iterator = _createForOfIteratorHelper(request.headers.headersArray()),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var header = _step.value;\n          xhr.setRequestHeader(header.name, header.value);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      xhr.responseType = ((_a = request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.size) || request.streamResponseBody ? \"blob\" : \"text\";\n      // tslint:disable-next-line:no-null-keyword\n      xhr.send(request.body === undefined ? null : request.body);\n      if (xhr.responseType === \"blob\") {\n        return new Promise(function (resolve, reject) {\n          handleBlobResponse(xhr, request, resolve, reject);\n          rejectOnTerminalEvent(request, xhr, reject);\n        });\n      } else {\n        return new Promise(function (resolve, reject) {\n          xhr.addEventListener(\"load\", function () {\n            return resolve({\n              request: request,\n              status: xhr.status,\n              headers: parseHeaders(xhr),\n              bodyAsText: xhr.responseText\n            });\n          });\n          rejectOnTerminalEvent(request, xhr, reject);\n        });\n      }\n    }\n  }]);\n  return XhrHttpClient;\n}();\nfunction handleBlobResponse(xhr, request, res, rej) {\n  xhr.addEventListener(\"readystatechange\", function () {\n    var _a;\n    // Resolve as soon as headers are loaded\n    if (xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED) {\n      if (request.streamResponseBody || ((_a = request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(xhr.status))) {\n        var blobBody = new Promise(function (resolve, reject) {\n          xhr.addEventListener(\"load\", function () {\n            resolve(xhr.response);\n          });\n          rejectOnTerminalEvent(request, xhr, reject);\n        });\n        res({\n          request: request,\n          status: xhr.status,\n          headers: parseHeaders(xhr),\n          blobBody: blobBody\n        });\n      } else {\n        xhr.addEventListener(\"load\", function () {\n          // xhr.response is of Blob type if the request is sent with xhr.responseType === \"blob\"\n          // but the status code is not one of the stream response status codes,\n          // so treat it as text and convert from Blob to text\n          if (xhr.response) {\n            // Blob.text() is not supported in IE so using FileReader instead\n            var reader = new FileReader();\n            reader.onload = function (e) {\n              var _a;\n              var text = (_a = e.target) === null || _a === void 0 ? void 0 : _a.result;\n              res({\n                request: request,\n                status: xhr.status,\n                headers: parseHeaders(xhr),\n                bodyAsText: text\n              });\n            };\n            reader.onerror = function (_e) {\n              rej(reader.error);\n            };\n            reader.readAsText(xhr.response, \"UTF-8\");\n          } else {\n            res({\n              request: request,\n              status: xhr.status,\n              headers: parseHeaders(xhr)\n            });\n          }\n        });\n      }\n    }\n  });\n}\nfunction addProgressListener(xhr, listener) {\n  if (listener) {\n    xhr.addEventListener(\"progress\", function (rawEvent) {\n      return listener({\n        loadedBytes: rawEvent.loaded\n      });\n    });\n  }\n}\n// exported locally for testing\nexport function parseHeaders(xhr) {\n  var responseHeaders = new HttpHeaders();\n  var headerLines = xhr.getAllResponseHeaders().trim().split(/[\\r\\n]+/);\n  var _iterator2 = _createForOfIteratorHelper(headerLines),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var line = _step2.value;\n      var index = line.indexOf(\":\");\n      var headerName = line.slice(0, index);\n      var headerValue = line.slice(index + 2);\n      responseHeaders.set(headerName, headerValue);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return responseHeaders;\n}\nfunction rejectOnTerminalEvent(request, xhr, reject) {\n  xhr.addEventListener(\"error\", function () {\n    return reject(new RestError(\"Failed to send request to \".concat(request.url), RestError.REQUEST_SEND_ERROR, undefined, request));\n  });\n  var abortError = new AbortError(\"The operation was aborted.\");\n  xhr.addEventListener(\"abort\", function () {\n    return reject(abortError);\n  });\n  xhr.addEventListener(\"timeout\", function () {\n    return reject(abortError);\n  });\n}","map":{"version":3,"mappings":";;;AAAA;AACA;AAEA,SAASA,WAAW,QAAyB,eAAe;AAE5D,SAASC,UAAU,QAAQ,yBAAyB;AAGpD,SAASC,SAAS,QAAQ,aAAa;AAEvC;;;AAGA,WAAaC,aAAa;EAAA;IAAA;EAAA;EAAA;IAAA;IAAA,OACjB,qBAAYC,OAAwB;;MACzC,IAAMC,GAAG,GAAG,IAAIC,cAAc,EAAE;MAEhC,IAAIF,OAAO,CAACG,aAAa,EAAE;QACzB,MAAM,IAAIC,KAAK,CAAC,oDAAoD,CAAC;;MAGvE,IAAMC,WAAW,GAAGL,OAAO,CAACK,WAAW;MACvC,IAAIA,WAAW,EAAE;QACf,IAAIA,WAAW,CAACC,OAAO,EAAE;UACvB,OAAOC,OAAO,CAACC,MAAM,CAAC,IAAIX,UAAU,CAAC,4BAA4B,CAAC,CAAC;;QAGrE,IAAMY,QAAQ,GAAG,SAAXA,QAAQ,GAAc;UAC1BR,GAAG,CAACS,KAAK,EAAE;QACb,CAAC;QACDL,WAAW,CAACM,gBAAgB,CAAC,OAAO,EAAEF,QAAQ,CAAC;QAC/CR,GAAG,CAACU,gBAAgB,CAAC,kBAAkB,EAAE,YAAK;UAC5C,IAAIV,GAAG,CAACW,UAAU,KAAKV,cAAc,CAACW,IAAI,EAAE;YAC1CR,WAAW,CAACS,mBAAmB,CAAC,OAAO,EAAEL,QAAQ,CAAC;;QAEtD,CAAC,CAAC;;MAGJM,mBAAmB,CAACd,GAAG,CAACe,MAAM,EAAEhB,OAAO,CAACiB,gBAAgB,CAAC;MACzDF,mBAAmB,CAACd,GAAG,EAAED,OAAO,CAACkB,kBAAkB,CAAC;MAEpD,IAAIlB,OAAO,CAACmB,QAAQ,EAAE;QACpB,IAAMA,QAAQ,GAAGnB,OAAO,CAACmB,QAAQ;QACjC,IAAMC,WAAW,GAAG,IAAIC,QAAQ,EAAE;QAClC,IAAMC,eAAe,GAAG,SAAlBA,eAAe,CAAIC,GAAW,EAAEC,KAAU,EAAU;UACxD,IACEA,KAAK,IACLC,MAAM,CAACC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACJ,KAAK,EAAE,OAAO,CAAC,IACpDC,MAAM,CAACC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACJ,KAAK,EAAE,SAAS,CAAC,EACtD;YACAJ,WAAW,CAACS,MAAM,CAACN,GAAG,EAAEC,KAAK,CAACA,KAAK,EAAEA,KAAK,CAACM,OAAO,CAAC;WACpD,MAAM;YACLV,WAAW,CAACS,MAAM,CAACN,GAAG,EAAEC,KAAK,CAAC;;QAElC,CAAC;QACD,gCAAsBC,MAAM,CAACM,IAAI,CAACZ,QAAQ,CAAC,kCAAE;UAAxC,IAAMa,OAAO;UAChB,IAAMC,SAAS,GAAGd,QAAQ,CAACa,OAAO,CAAC;UACnC,IAAIE,KAAK,CAACC,OAAO,CAACF,SAAS,CAAC,EAAE;YAC5B,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,SAAS,CAACI,MAAM,EAAED,CAAC,EAAE,EAAE;cACzCd,eAAe,CAACU,OAAO,EAAEC,SAAS,CAACG,CAAC,CAAC,CAAC;;WAEzC,MAAM;YACLd,eAAe,CAACU,OAAO,EAAEC,SAAS,CAAC;;;QAIvCjC,OAAO,CAACsC,IAAI,GAAGlB,WAAW;QAC1BpB,OAAO,CAACmB,QAAQ,GAAGoB,SAAS;QAC5B,IAAMC,WAAW,GAAGxC,OAAO,CAACyC,OAAO,CAACC,GAAG,CAAC,cAAc,CAAC;QACvD,IAAIF,WAAW,IAAIA,WAAW,CAACG,OAAO,CAAC,qBAAqB,CAAC,KAAK,CAAC,CAAC,EAAE;UACpE;UACA3C,OAAO,CAACyC,OAAO,CAACG,MAAM,CAAC,cAAc,CAAC;;;MAI1C3C,GAAG,CAAC4C,IAAI,CAAC7C,OAAO,CAAC8C,MAAM,EAAE9C,OAAO,CAAC+C,GAAG,CAAC;MACrC9C,GAAG,CAAC+C,OAAO,GAAGhD,OAAO,CAACgD,OAAO;MAC7B/C,GAAG,CAACgD,eAAe,GAAGjD,OAAO,CAACiD,eAAe;MAAC,2CACzBjD,OAAO,CAACyC,OAAO,CAACS,YAAY,EAAE;QAAA;MAAA;QAAnD,oDAAqD;UAAA,IAA1CC,MAAM;UACflD,GAAG,CAACmD,gBAAgB,CAACD,MAAM,CAACE,IAAI,EAAEF,MAAM,CAAC3B,KAAK,CAAC;;MAChD;QAAA;MAAA;QAAA;MAAA;MAEDvB,GAAG,CAACqD,YAAY,GACd,cAAO,CAACC,yBAAyB,0CAAEC,IAAI,KAAIxD,OAAO,CAACyD,kBAAkB,GAAG,MAAM,GAAG,MAAM;MAEzF;MACAxD,GAAG,CAACyD,IAAI,CAAC1D,OAAO,CAACsC,IAAI,KAAKC,SAAS,GAAG,IAAI,GAAGvC,OAAO,CAACsC,IAAI,CAAC;MAE1D,IAAIrC,GAAG,CAACqD,YAAY,KAAK,MAAM,EAAE;QAC/B,OAAO,IAAI/C,OAAO,CAAC,UAACoD,OAAO,EAAEnD,MAAM,EAAI;UACrCoD,kBAAkB,CAAC3D,GAAG,EAAED,OAAO,EAAE2D,OAAO,EAAEnD,MAAM,CAAC;UACjDqD,qBAAqB,CAAC7D,OAAO,EAAEC,GAAG,EAAEO,MAAM,CAAC;QAC7C,CAAC,CAAC;OACH,MAAM;QACL,OAAO,IAAID,OAAO,CAAC,UAAUoD,OAAO,EAAEnD,MAAM;UAC1CP,GAAG,CAACU,gBAAgB,CAAC,MAAM,EAAE;YAAA,OAC3BgD,OAAO,CAAC;cACN3D,OAAO,EAAPA,OAAO;cACP8D,MAAM,EAAE7D,GAAG,CAAC6D,MAAM;cAClBrB,OAAO,EAAEsB,YAAY,CAAC9D,GAAG,CAAC;cAC1B+D,UAAU,EAAE/D,GAAG,CAACgE;aACjB,CAAC;UAAA,EACH;UACDJ,qBAAqB,CAAC7D,OAAO,EAAEC,GAAG,EAAEO,MAAM,CAAC;QAC7C,CAAC,CAAC;;IAEN;EAAC;EAAA;AAAA;AAGH,SAASoD,kBAAkB,CACzB3D,GAAmB,EACnBD,OAAwB,EACxBkE,GAAgF,EAChFC,GAA2B;EAE3BlE,GAAG,CAACU,gBAAgB,CAAC,kBAAkB,EAAE,YAAK;;IAC5C;IACA,IAAIV,GAAG,CAACW,UAAU,KAAKV,cAAc,CAACkE,gBAAgB,EAAE;MACtD,IAAIpE,OAAO,CAACyD,kBAAkB,KAAI,aAAO,CAACF,yBAAyB,0CAAEc,GAAG,CAACpE,GAAG,CAAC6D,MAAM,CAAC,GAAE;QACpF,IAAMQ,QAAQ,GAAG,IAAI/D,OAAO,CAAO,UAACoD,OAAO,EAAEnD,MAAM,EAAI;UACrDP,GAAG,CAACU,gBAAgB,CAAC,MAAM,EAAE,YAAK;YAChCgD,OAAO,CAAC1D,GAAG,CAACsE,QAAQ,CAAC;UACvB,CAAC,CAAC;UACFV,qBAAqB,CAAC7D,OAAO,EAAEC,GAAG,EAAEO,MAAM,CAAC;QAC7C,CAAC,CAAC;QACF0D,GAAG,CAAC;UACFlE,OAAO,EAAPA,OAAO;UACP8D,MAAM,EAAE7D,GAAG,CAAC6D,MAAM;UAClBrB,OAAO,EAAEsB,YAAY,CAAC9D,GAAG,CAAC;UAC1BqE,QAAQ,EAARA;SACD,CAAC;OACH,MAAM;QACLrE,GAAG,CAACU,gBAAgB,CAAC,MAAM,EAAE,YAAK;UAChC;UACA;UACA;UACA,IAAIV,GAAG,CAACsE,QAAQ,EAAE;YAChB;YACA,IAAMC,MAAM,GAAG,IAAIC,UAAU,EAAE;YAC/BD,MAAM,CAACE,MAAM,GAAG,UAAUC,CAAC;;cACzB,IAAMC,IAAI,GAAG,OAAC,CAACC,MAAM,0CAAEC,MAAgB;cACvCZ,GAAG,CAAC;gBACFlE,OAAO,EAAPA,OAAO;gBACP8D,MAAM,EAAE7D,GAAG,CAAC6D,MAAM;gBAClBrB,OAAO,EAAEsB,YAAY,CAAC9D,GAAG,CAAC;gBAC1B+D,UAAU,EAAEY;eACb,CAAC;YACJ,CAAC;YACDJ,MAAM,CAACO,OAAO,GAAG,UAAUC,EAAE;cAC3Bb,GAAG,CAACK,MAAM,CAACS,KAAK,CAAC;YACnB,CAAC;YACDT,MAAM,CAACU,UAAU,CAACjF,GAAG,CAACsE,QAAQ,EAAE,OAAO,CAAC;WACzC,MAAM;YACLL,GAAG,CAAC;cACFlE,OAAO,EAAPA,OAAO;cACP8D,MAAM,EAAE7D,GAAG,CAAC6D,MAAM;cAClBrB,OAAO,EAAEsB,YAAY,CAAC9D,GAAG;aAC1B,CAAC;;QAEN,CAAC,CAAC;;;EAGR,CAAC,CAAC;AACJ;AAEA,SAASc,mBAAmB,CAC1Bd,GAA8B,EAC9BQ,QAAoD;EAEpD,IAAIA,QAAQ,EAAE;IACZR,GAAG,CAACU,gBAAgB,CAAC,UAAU,EAAE,UAACwE,QAAQ;MAAA,OACxC1E,QAAQ,CAAC;QACP2E,WAAW,EAAED,QAAQ,CAACE;OACvB,CAAC;IAAA,EACH;;AAEL;AAEA;AACA,OAAM,SAAUtB,YAAY,CAAC9D,GAAmB;EAC9C,IAAMqF,eAAe,GAAG,IAAI1F,WAAW,EAAE;EACzC,IAAM2F,WAAW,GAAGtF,GAAG,CACpBuF,qBAAqB,EAAE,CACvBC,IAAI,EAAE,CACNC,KAAK,CAAC,SAAS,CAAC;EAAC,4CACDH,WAAW;IAAA;EAAA;IAA9B,uDAAgC;MAAA,IAArBI,IAAI;MACb,IAAMC,KAAK,GAAGD,IAAI,CAAChD,OAAO,CAAC,GAAG,CAAC;MAC/B,IAAMkD,UAAU,GAAGF,IAAI,CAACG,KAAK,CAAC,CAAC,EAAEF,KAAK,CAAC;MACvC,IAAMG,WAAW,GAAGJ,IAAI,CAACG,KAAK,CAACF,KAAK,GAAG,CAAC,CAAC;MACzCN,eAAe,CAACU,GAAG,CAACH,UAAU,EAAEE,WAAW,CAAC;;EAC7C;IAAA;EAAA;IAAA;EAAA;EACD,OAAOT,eAAe;AACxB;AAEA,SAASzB,qBAAqB,CAC5B7D,OAAwB,EACxBC,GAAmB,EACnBO,MAA0B;EAE1BP,GAAG,CAACU,gBAAgB,CAAC,OAAO,EAAE;IAAA,OAC5BH,MAAM,CACJ,IAAIV,SAAS,qCACkBE,OAAO,CAAC+C,GAAG,GACxCjD,SAAS,CAACmG,kBAAkB,EAC5B1D,SAAS,EACTvC,OAAO,CACR,CACF;EAAA,EACF;EACD,IAAMkG,UAAU,GAAG,IAAIrG,UAAU,CAAC,4BAA4B,CAAC;EAC/DI,GAAG,CAACU,gBAAgB,CAAC,OAAO,EAAE;IAAA,OAAMH,MAAM,CAAC0F,UAAU,CAAC;EAAA,EAAC;EACvDjG,GAAG,CAACU,gBAAgB,CAAC,SAAS,EAAE;IAAA,OAAMH,MAAM,CAAC0F,UAAU,CAAC;EAAA,EAAC;AAC3D","names":["HttpHeaders","AbortError","RestError","XhrHttpClient","request","xhr","XMLHttpRequest","proxySettings","Error","abortSignal","aborted","Promise","reject","listener","abort","addEventListener","readyState","DONE","removeEventListener","addProgressListener","upload","onUploadProgress","onDownloadProgress","formData","requestForm","FormData","appendFormValue","key","value","Object","prototype","hasOwnProperty","call","append","options","keys","formKey","formValue","Array","isArray","j","length","body","undefined","contentType","headers","get","indexOf","remove","open","method","url","timeout","withCredentials","headersArray","header","setRequestHeader","name","responseType","streamResponseStatusCodes","size","streamResponseBody","send","resolve","handleBlobResponse","rejectOnTerminalEvent","status","parseHeaders","bodyAsText","responseText","res","rej","HEADERS_RECEIVED","has","blobBody","response","reader","FileReader","onload","e","text","target","result","onerror","_e","error","readAsText","rawEvent","loadedBytes","loaded","responseHeaders","headerLines","getAllResponseHeaders","trim","split","line","index","headerName","slice","headerValue","set","REQUEST_SEND_ERROR","abortError"],"sourceRoot":"","sources":["../../src/xhrHttpClient.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { HttpHeaders, HttpHeadersLike } from \"./httpHeaders\";\nimport { TransferProgressEvent, WebResourceLike } from \"./webResource\";\nimport { AbortError } from \"@azure/abort-controller\";\nimport { HttpClient } from \"./httpClient\";\nimport { HttpOperationResponse } from \"./httpOperationResponse\";\nimport { RestError } from \"./restError\";\n\n/**\n * A HttpClient implementation that uses XMLHttpRequest to send HTTP requests.\n */\nexport class XhrHttpClient implements HttpClient {\n  public sendRequest(request: WebResourceLike): Promise<HttpOperationResponse> {\n    const xhr = new XMLHttpRequest();\n\n    if (request.proxySettings) {\n      throw new Error(\"HTTP proxy is not supported in browser environment\");\n    }\n\n    const abortSignal = request.abortSignal;\n    if (abortSignal) {\n      if (abortSignal.aborted) {\n        return Promise.reject(new AbortError(\"The operation was aborted.\"));\n      }\n\n      const listener = (): void => {\n        xhr.abort();\n      };\n      abortSignal.addEventListener(\"abort\", listener);\n      xhr.addEventListener(\"readystatechange\", () => {\n        if (xhr.readyState === XMLHttpRequest.DONE) {\n          abortSignal.removeEventListener(\"abort\", listener);\n        }\n      });\n    }\n\n    addProgressListener(xhr.upload, request.onUploadProgress);\n    addProgressListener(xhr, request.onDownloadProgress);\n\n    if (request.formData) {\n      const formData = request.formData;\n      const requestForm = new FormData();\n      const appendFormValue = (key: string, value: any): void => {\n        if (\n          value &&\n          Object.prototype.hasOwnProperty.call(value, \"value\") &&\n          Object.prototype.hasOwnProperty.call(value, \"options\")\n        ) {\n          requestForm.append(key, value.value, value.options);\n        } else {\n          requestForm.append(key, value);\n        }\n      };\n      for (const formKey of Object.keys(formData)) {\n        const formValue = formData[formKey];\n        if (Array.isArray(formValue)) {\n          for (let j = 0; j < formValue.length; j++) {\n            appendFormValue(formKey, formValue[j]);\n          }\n        } else {\n          appendFormValue(formKey, formValue);\n        }\n      }\n\n      request.body = requestForm;\n      request.formData = undefined;\n      const contentType = request.headers.get(\"Content-Type\");\n      if (contentType && contentType.indexOf(\"multipart/form-data\") !== -1) {\n        // browser will automatically apply a suitable content-type header\n        request.headers.remove(\"Content-Type\");\n      }\n    }\n\n    xhr.open(request.method, request.url);\n    xhr.timeout = request.timeout;\n    xhr.withCredentials = request.withCredentials;\n    for (const header of request.headers.headersArray()) {\n      xhr.setRequestHeader(header.name, header.value);\n    }\n\n    xhr.responseType =\n      request.streamResponseStatusCodes?.size || request.streamResponseBody ? \"blob\" : \"text\";\n\n    // tslint:disable-next-line:no-null-keyword\n    xhr.send(request.body === undefined ? null : request.body);\n\n    if (xhr.responseType === \"blob\") {\n      return new Promise((resolve, reject) => {\n        handleBlobResponse(xhr, request, resolve, reject);\n        rejectOnTerminalEvent(request, xhr, reject);\n      });\n    } else {\n      return new Promise(function (resolve, reject) {\n        xhr.addEventListener(\"load\", () =>\n          resolve({\n            request,\n            status: xhr.status,\n            headers: parseHeaders(xhr),\n            bodyAsText: xhr.responseText,\n          })\n        );\n        rejectOnTerminalEvent(request, xhr, reject);\n      });\n    }\n  }\n}\n\nfunction handleBlobResponse(\n  xhr: XMLHttpRequest,\n  request: WebResourceLike,\n  res: (value: HttpOperationResponse | PromiseLike<HttpOperationResponse>) => void,\n  rej: (reason?: any) => void\n): void {\n  xhr.addEventListener(\"readystatechange\", () => {\n    // Resolve as soon as headers are loaded\n    if (xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED) {\n      if (request.streamResponseBody || request.streamResponseStatusCodes?.has(xhr.status)) {\n        const blobBody = new Promise<Blob>((resolve, reject) => {\n          xhr.addEventListener(\"load\", () => {\n            resolve(xhr.response);\n          });\n          rejectOnTerminalEvent(request, xhr, reject);\n        });\n        res({\n          request,\n          status: xhr.status,\n          headers: parseHeaders(xhr),\n          blobBody,\n        });\n      } else {\n        xhr.addEventListener(\"load\", () => {\n          // xhr.response is of Blob type if the request is sent with xhr.responseType === \"blob\"\n          // but the status code is not one of the stream response status codes,\n          // so treat it as text and convert from Blob to text\n          if (xhr.response) {\n            // Blob.text() is not supported in IE so using FileReader instead\n            const reader = new FileReader();\n            reader.onload = function (e) {\n              const text = e.target?.result as string;\n              res({\n                request,\n                status: xhr.status,\n                headers: parseHeaders(xhr),\n                bodyAsText: text,\n              });\n            };\n            reader.onerror = function (_e) {\n              rej(reader.error);\n            };\n            reader.readAsText(xhr.response, \"UTF-8\");\n          } else {\n            res({\n              request,\n              status: xhr.status,\n              headers: parseHeaders(xhr),\n            });\n          }\n        });\n      }\n    }\n  });\n}\n\nfunction addProgressListener(\n  xhr: XMLHttpRequestEventTarget,\n  listener?: (progress: TransferProgressEvent) => void\n): void {\n  if (listener) {\n    xhr.addEventListener(\"progress\", (rawEvent) =>\n      listener({\n        loadedBytes: rawEvent.loaded,\n      })\n    );\n  }\n}\n\n// exported locally for testing\nexport function parseHeaders(xhr: XMLHttpRequest): HttpHeadersLike {\n  const responseHeaders = new HttpHeaders();\n  const headerLines = xhr\n    .getAllResponseHeaders()\n    .trim()\n    .split(/[\\r\\n]+/);\n  for (const line of headerLines) {\n    const index = line.indexOf(\":\");\n    const headerName = line.slice(0, index);\n    const headerValue = line.slice(index + 2);\n    responseHeaders.set(headerName, headerValue);\n  }\n  return responseHeaders;\n}\n\nfunction rejectOnTerminalEvent(\n  request: WebResourceLike,\n  xhr: XMLHttpRequest,\n  reject: (err: any) => void\n): void {\n  xhr.addEventListener(\"error\", () =>\n    reject(\n      new RestError(\n        `Failed to send request to ${request.url}`,\n        RestError.REQUEST_SEND_ERROR,\n        undefined,\n        request\n      )\n    )\n  );\n  const abortError = new AbortError(\"The operation was aborted.\");\n  xhr.addEventListener(\"abort\", () => reject(abortError));\n  xhr.addEventListener(\"timeout\", () => reject(abortError));\n}\n"]},"metadata":{},"sourceType":"module"}