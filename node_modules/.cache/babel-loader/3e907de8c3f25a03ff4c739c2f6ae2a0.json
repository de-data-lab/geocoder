{"ast":null,"code":"import _slicedToArray from \"/Users/tbeckett/Documents/geo-react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _defineProperty from \"/Users/tbeckett/Documents/geo-react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _createForOfIteratorHelper from \"/Users/tbeckett/Documents/geo-react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"/Users/tbeckett/Documents/geo-react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/tbeckett/Documents/geo-react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n/* eslint-disable eqeqeq */\nimport * as base64 from \"./util/base64\";\nimport * as utils from \"./util/utils\";\nimport { XML_ATTRKEY, XML_CHARKEY } from \"./util/serializer.common\";\n// This file contains utility code to serialize and deserialize network operations according to `OperationSpec` objects generated by AutoRest.TypeScript from OpenAPI specifications.\n/**\n * Used to map raw response objects to final shapes.\n * Helps packing and unpacking Dates and other encoded types that are not intrinsic to JSON.\n * Also allows pulling values from headers, as well as inserting default values and constants.\n */\nexport var Serializer = /*#__PURE__*/function () {\n  function Serializer() {\n    var modelMappers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var\n    /**\n     * Whether the contents are XML or not.\n     */\n    isXML = arguments.length > 1 ? arguments[1] : undefined;\n    _classCallCheck(this, Serializer);\n    this.modelMappers = modelMappers;\n    this.isXML = isXML;\n  }\n  /**\n   * Validates constraints, if any. This function will throw if the provided value does not respect those constraints.\n   * @param mapper - The definition of data models.\n   * @param value - The value.\n   * @param objectName - Name of the object. Used in the error messages.\n   * @deprecated Removing the constraints validation on client side.\n   */\n  _createClass(Serializer, [{\n    key: \"validateConstraints\",\n    value: function validateConstraints(mapper, value, objectName) {\n      var failValidation = function failValidation(constraintName, constraintValue) {\n        throw new Error(\"\\\"\".concat(objectName, \"\\\" with value \\\"\").concat(value, \"\\\" should satisfy the constraint \\\"\").concat(constraintName, \"\\\": \").concat(constraintValue, \".\"));\n      };\n      if (mapper.constraints && value != undefined) {\n        var valueAsNumber = value;\n        var _mapper$constraints = mapper.constraints,\n          ExclusiveMaximum = _mapper$constraints.ExclusiveMaximum,\n          ExclusiveMinimum = _mapper$constraints.ExclusiveMinimum,\n          InclusiveMaximum = _mapper$constraints.InclusiveMaximum,\n          InclusiveMinimum = _mapper$constraints.InclusiveMinimum,\n          MaxItems = _mapper$constraints.MaxItems,\n          MaxLength = _mapper$constraints.MaxLength,\n          MinItems = _mapper$constraints.MinItems,\n          MinLength = _mapper$constraints.MinLength,\n          MultipleOf = _mapper$constraints.MultipleOf,\n          Pattern = _mapper$constraints.Pattern,\n          UniqueItems = _mapper$constraints.UniqueItems;\n        if (ExclusiveMaximum != undefined && valueAsNumber >= ExclusiveMaximum) {\n          failValidation(\"ExclusiveMaximum\", ExclusiveMaximum);\n        }\n        if (ExclusiveMinimum != undefined && valueAsNumber <= ExclusiveMinimum) {\n          failValidation(\"ExclusiveMinimum\", ExclusiveMinimum);\n        }\n        if (InclusiveMaximum != undefined && valueAsNumber > InclusiveMaximum) {\n          failValidation(\"InclusiveMaximum\", InclusiveMaximum);\n        }\n        if (InclusiveMinimum != undefined && valueAsNumber < InclusiveMinimum) {\n          failValidation(\"InclusiveMinimum\", InclusiveMinimum);\n        }\n        var valueAsArray = value;\n        if (MaxItems != undefined && valueAsArray.length > MaxItems) {\n          failValidation(\"MaxItems\", MaxItems);\n        }\n        if (MaxLength != undefined && valueAsArray.length > MaxLength) {\n          failValidation(\"MaxLength\", MaxLength);\n        }\n        if (MinItems != undefined && valueAsArray.length < MinItems) {\n          failValidation(\"MinItems\", MinItems);\n        }\n        if (MinLength != undefined && valueAsArray.length < MinLength) {\n          failValidation(\"MinLength\", MinLength);\n        }\n        if (MultipleOf != undefined && valueAsNumber % MultipleOf !== 0) {\n          failValidation(\"MultipleOf\", MultipleOf);\n        }\n        if (Pattern) {\n          var pattern = typeof Pattern === \"string\" ? new RegExp(Pattern) : Pattern;\n          if (typeof value !== \"string\" || value.match(pattern) === null) {\n            failValidation(\"Pattern\", Pattern);\n          }\n        }\n        if (UniqueItems && valueAsArray.some(function (item, i, ar) {\n          return ar.indexOf(item) !== i;\n        })) {\n          failValidation(\"UniqueItems\", UniqueItems);\n        }\n      }\n    }\n    /**\n     * Serialize the given object based on its metadata defined in the mapper.\n     *\n     * @param mapper - The mapper which defines the metadata of the serializable object.\n     * @param object - A valid Javascript object to be serialized.\n     * @param objectName - Name of the serialized object.\n     * @param options - additional options to deserialization.\n     * @returns A valid serialized Javascript object.\n     */\n  }, {\n    key: \"serialize\",\n    value: function serialize(mapper, object, objectName) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var _a, _b, _c;\n      var updatedOptions = {\n        rootName: (_a = options.rootName) !== null && _a !== void 0 ? _a : \"\",\n        includeRoot: (_b = options.includeRoot) !== null && _b !== void 0 ? _b : false,\n        xmlCharKey: (_c = options.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY\n      };\n      var payload = {};\n      var mapperType = mapper.type.name;\n      if (!objectName) {\n        objectName = mapper.serializedName;\n      }\n      if (mapperType.match(/^Sequence$/i) !== null) {\n        payload = [];\n      }\n      if (mapper.isConstant) {\n        object = mapper.defaultValue;\n      }\n      // This table of allowed values should help explain\n      // the mapper.required and mapper.nullable properties.\n      // X means \"neither undefined or null are allowed\".\n      //           || required\n      //           || true      | false\n      //  nullable || ==========================\n      //      true || null      | undefined/null\n      //     false || X         | undefined\n      // undefined || X         | undefined/null\n      var required = mapper.required,\n        nullable = mapper.nullable;\n      if (required && nullable && object === undefined) {\n        throw new Error(\"\".concat(objectName, \" cannot be undefined.\"));\n      }\n      if (required && !nullable && object == undefined) {\n        throw new Error(\"\".concat(objectName, \" cannot be null or undefined.\"));\n      }\n      if (!required && nullable === false && object === null) {\n        throw new Error(\"\".concat(objectName, \" cannot be null.\"));\n      }\n      if (object == undefined) {\n        payload = object;\n      } else {\n        if (mapperType.match(/^any$/i) !== null) {\n          payload = object;\n        } else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i) !== null) {\n          payload = serializeBasicTypes(mapperType, objectName, object);\n        } else if (mapperType.match(/^Enum$/i) !== null) {\n          var enumMapper = mapper;\n          payload = serializeEnumType(objectName, enumMapper.type.allowedValues, object);\n        } else if (mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i) !== null) {\n          payload = serializeDateTypes(mapperType, object, objectName);\n        } else if (mapperType.match(/^ByteArray$/i) !== null) {\n          payload = serializeByteArrayType(objectName, object);\n        } else if (mapperType.match(/^Base64Url$/i) !== null) {\n          payload = serializeBase64UrlType(objectName, object);\n        } else if (mapperType.match(/^Sequence$/i) !== null) {\n          payload = serializeSequenceType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);\n        } else if (mapperType.match(/^Dictionary$/i) !== null) {\n          payload = serializeDictionaryType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);\n        } else if (mapperType.match(/^Composite$/i) !== null) {\n          payload = serializeCompositeType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);\n        }\n      }\n      return payload;\n    }\n    /**\n     * Deserialize the given object based on its metadata defined in the mapper.\n     *\n     * @param mapper - The mapper which defines the metadata of the serializable object.\n     * @param responseBody - A valid Javascript entity to be deserialized.\n     * @param objectName - Name of the deserialized object.\n     * @param options - Controls behavior of XML parser and builder.\n     * @returns A valid deserialized Javascript object.\n     */\n  }, {\n    key: \"deserialize\",\n    value: function deserialize(mapper, responseBody, objectName) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var _a, _b, _c;\n      var updatedOptions = {\n        rootName: (_a = options.rootName) !== null && _a !== void 0 ? _a : \"\",\n        includeRoot: (_b = options.includeRoot) !== null && _b !== void 0 ? _b : false,\n        xmlCharKey: (_c = options.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY\n      };\n      if (responseBody == undefined) {\n        if (this.isXML && mapper.type.name === \"Sequence\" && !mapper.xmlIsWrapped) {\n          // Edge case for empty XML non-wrapped lists. xml2js can't distinguish\n          // between the list being empty versus being missing,\n          // so let's do the more user-friendly thing and return an empty list.\n          responseBody = [];\n        }\n        // specifically check for undefined as default value can be a falsey value `0, \"\", false, null`\n        if (mapper.defaultValue !== undefined) {\n          responseBody = mapper.defaultValue;\n        }\n        return responseBody;\n      }\n      var payload;\n      var mapperType = mapper.type.name;\n      if (!objectName) {\n        objectName = mapper.serializedName;\n      }\n      if (mapperType.match(/^Composite$/i) !== null) {\n        payload = deserializeCompositeType(this, mapper, responseBody, objectName, updatedOptions);\n      } else {\n        if (this.isXML) {\n          var xmlCharKey = updatedOptions.xmlCharKey;\n          var castResponseBody = responseBody;\n          /**\n           * If the mapper specifies this as a non-composite type value but the responseBody contains\n           * both header (\"$\" i.e., XML_ATTRKEY) and body (\"#\" i.e., XML_CHARKEY) properties,\n           * then just reduce the responseBody value to the body (\"#\" i.e., XML_CHARKEY) property.\n           */\n          if (castResponseBody[XML_ATTRKEY] != undefined && castResponseBody[xmlCharKey] != undefined) {\n            responseBody = castResponseBody[xmlCharKey];\n          }\n        }\n        if (mapperType.match(/^Number$/i) !== null) {\n          payload = parseFloat(responseBody);\n          if (isNaN(payload)) {\n            payload = responseBody;\n          }\n        } else if (mapperType.match(/^Boolean$/i) !== null) {\n          if (responseBody === \"true\") {\n            payload = true;\n          } else if (responseBody === \"false\") {\n            payload = false;\n          } else {\n            payload = responseBody;\n          }\n        } else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i) !== null) {\n          payload = responseBody;\n        } else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/i) !== null) {\n          payload = new Date(responseBody);\n        } else if (mapperType.match(/^UnixTime$/i) !== null) {\n          payload = unixTimeToDate(responseBody);\n        } else if (mapperType.match(/^ByteArray$/i) !== null) {\n          payload = base64.decodeString(responseBody);\n        } else if (mapperType.match(/^Base64Url$/i) !== null) {\n          payload = base64UrlToByteArray(responseBody);\n        } else if (mapperType.match(/^Sequence$/i) !== null) {\n          payload = deserializeSequenceType(this, mapper, responseBody, objectName, updatedOptions);\n        } else if (mapperType.match(/^Dictionary$/i) !== null) {\n          payload = deserializeDictionaryType(this, mapper, responseBody, objectName, updatedOptions);\n        }\n      }\n      if (mapper.isConstant) {\n        payload = mapper.defaultValue;\n      }\n      return payload;\n    }\n  }]);\n  return Serializer;\n}();\nfunction trimEnd(str, ch) {\n  var len = str.length;\n  while (len - 1 >= 0 && str[len - 1] === ch) {\n    --len;\n  }\n  return str.substr(0, len);\n}\nfunction bufferToBase64Url(buffer) {\n  if (!buffer) {\n    return undefined;\n  }\n  if (!(buffer instanceof Uint8Array)) {\n    throw new Error(\"Please provide an input of type Uint8Array for converting to Base64Url.\");\n  }\n  // Uint8Array to Base64.\n  var str = base64.encodeByteArray(buffer);\n  // Base64 to Base64Url.\n  return trimEnd(str, \"=\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\nfunction base64UrlToByteArray(str) {\n  if (!str) {\n    return undefined;\n  }\n  if (str && typeof str.valueOf() !== \"string\") {\n    throw new Error(\"Please provide an input of type string for converting to Uint8Array\");\n  }\n  // Base64Url to Base64.\n  str = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  // Base64 to Uint8Array.\n  return base64.decodeString(str);\n}\nfunction splitSerializeName(prop) {\n  var classes = [];\n  var partialclass = \"\";\n  if (prop) {\n    var subwords = prop.split(\".\");\n    var _iterator = _createForOfIteratorHelper(subwords),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var item = _step.value;\n        if (item.charAt(item.length - 1) === \"\\\\\") {\n          partialclass += item.substr(0, item.length - 1) + \".\";\n        } else {\n          partialclass += item;\n          classes.push(partialclass);\n          partialclass = \"\";\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n  return classes;\n}\nfunction dateToUnixTime(d) {\n  if (!d) {\n    return undefined;\n  }\n  if (typeof d.valueOf() === \"string\") {\n    d = new Date(d);\n  }\n  return Math.floor(d.getTime() / 1000);\n}\nfunction unixTimeToDate(n) {\n  if (!n) {\n    return undefined;\n  }\n  return new Date(n * 1000);\n}\nfunction serializeBasicTypes(typeName, objectName, value) {\n  if (value !== null && value !== undefined) {\n    if (typeName.match(/^Number$/i) !== null) {\n      if (typeof value !== \"number\") {\n        throw new Error(\"\".concat(objectName, \" with value \").concat(value, \" must be of type number.\"));\n      }\n    } else if (typeName.match(/^String$/i) !== null) {\n      if (typeof value.valueOf() !== \"string\") {\n        throw new Error(\"\".concat(objectName, \" with value \\\"\").concat(value, \"\\\" must be of type string.\"));\n      }\n    } else if (typeName.match(/^Uuid$/i) !== null) {\n      if (!(typeof value.valueOf() === \"string\" && utils.isValidUuid(value))) {\n        throw new Error(\"\".concat(objectName, \" with value \\\"\").concat(value, \"\\\" must be of type string and a valid uuid.\"));\n      }\n    } else if (typeName.match(/^Boolean$/i) !== null) {\n      if (typeof value !== \"boolean\") {\n        throw new Error(\"\".concat(objectName, \" with value \").concat(value, \" must be of type boolean.\"));\n      }\n    } else if (typeName.match(/^Stream$/i) !== null) {\n      var objectType = typeof value;\n      if (objectType !== \"string\" && objectType !== \"function\" && !(value instanceof ArrayBuffer) && !ArrayBuffer.isView(value) && !((typeof Blob === \"function\" || typeof Blob === \"object\") && value instanceof Blob)) {\n        throw new Error(\"\".concat(objectName, \" must be a string, Blob, ArrayBuffer, ArrayBufferView, or a function returning NodeJS.ReadableStream.\"));\n      }\n    }\n  }\n  return value;\n}\nfunction serializeEnumType(objectName, allowedValues, value) {\n  if (!allowedValues) {\n    throw new Error(\"Please provide a set of allowedValues to validate \".concat(objectName, \" as an Enum Type.\"));\n  }\n  var isPresent = allowedValues.some(function (item) {\n    if (typeof item.valueOf() === \"string\") {\n      return item.toLowerCase() === value.toLowerCase();\n    }\n    return item === value;\n  });\n  if (!isPresent) {\n    throw new Error(\"\".concat(value, \" is not a valid value for \").concat(objectName, \". The valid values are: \").concat(JSON.stringify(allowedValues), \".\"));\n  }\n  return value;\n}\nfunction serializeByteArrayType(objectName, value) {\n  var returnValue = \"\";\n  if (value != undefined) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error(\"\".concat(objectName, \" must be of type Uint8Array.\"));\n    }\n    returnValue = base64.encodeByteArray(value);\n  }\n  return returnValue;\n}\nfunction serializeBase64UrlType(objectName, value) {\n  var returnValue = \"\";\n  if (value != undefined) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error(\"\".concat(objectName, \" must be of type Uint8Array.\"));\n    }\n    returnValue = bufferToBase64Url(value) || \"\";\n  }\n  return returnValue;\n}\nfunction serializeDateTypes(typeName, value, objectName) {\n  if (value != undefined) {\n    if (typeName.match(/^Date$/i) !== null) {\n      if (!(value instanceof Date || typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))) {\n        throw new Error(\"\".concat(objectName, \" must be an instanceof Date or a string in ISO8601 format.\"));\n      }\n      value = value instanceof Date ? value.toISOString().substring(0, 10) : new Date(value).toISOString().substring(0, 10);\n    } else if (typeName.match(/^DateTime$/i) !== null) {\n      if (!(value instanceof Date || typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))) {\n        throw new Error(\"\".concat(objectName, \" must be an instanceof Date or a string in ISO8601 format.\"));\n      }\n      value = value instanceof Date ? value.toISOString() : new Date(value).toISOString();\n    } else if (typeName.match(/^DateTimeRfc1123$/i) !== null) {\n      if (!(value instanceof Date || typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))) {\n        throw new Error(\"\".concat(objectName, \" must be an instanceof Date or a string in RFC-1123 format.\"));\n      }\n      value = value instanceof Date ? value.toUTCString() : new Date(value).toUTCString();\n    } else if (typeName.match(/^UnixTime$/i) !== null) {\n      if (!(value instanceof Date || typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))) {\n        throw new Error(\"\".concat(objectName, \" must be an instanceof Date or a string in RFC-1123/ISO8601 format \") + \"for it to be serialized in UnixTime/Epoch format.\");\n      }\n      value = dateToUnixTime(value);\n    } else if (typeName.match(/^TimeSpan$/i) !== null) {\n      if (!utils.isDuration(value)) {\n        throw new Error(\"\".concat(objectName, \" must be a string in ISO 8601 format. Instead was \\\"\").concat(value, \"\\\".\"));\n      }\n    }\n  }\n  return value;\n}\nfunction serializeSequenceType(serializer, mapper, object, objectName, isXml, options) {\n  if (!Array.isArray(object)) {\n    throw new Error(\"\".concat(objectName, \" must be of type Array.\"));\n  }\n  var elementType = mapper.type.element;\n  if (!elementType || typeof elementType !== \"object\") {\n    throw new Error(\"element\\\" metadata for an Array must be defined in the \" + \"mapper and it must of type \\\"object\\\" in \".concat(objectName, \".\"));\n  }\n  var tempArray = [];\n  for (var i = 0; i < object.length; i++) {\n    var serializedValue = serializer.serialize(elementType, object[i], objectName, options);\n    if (isXml && elementType.xmlNamespace) {\n      var xmlnsKey = elementType.xmlNamespacePrefix ? \"xmlns:\".concat(elementType.xmlNamespacePrefix) : \"xmlns\";\n      if (elementType.type.name === \"Composite\") {\n        tempArray[i] = Object.assign({}, serializedValue);\n        tempArray[i][XML_ATTRKEY] = _defineProperty({}, xmlnsKey, elementType.xmlNamespace);\n      } else {\n        tempArray[i] = {};\n        tempArray[i][options.xmlCharKey] = serializedValue;\n        tempArray[i][XML_ATTRKEY] = _defineProperty({}, xmlnsKey, elementType.xmlNamespace);\n      }\n    } else {\n      tempArray[i] = serializedValue;\n    }\n  }\n  return tempArray;\n}\nfunction serializeDictionaryType(serializer, mapper, object, objectName, isXml, options) {\n  if (typeof object !== \"object\") {\n    throw new Error(\"\".concat(objectName, \" must be of type object.\"));\n  }\n  var valueType = mapper.type.value;\n  if (!valueType || typeof valueType !== \"object\") {\n    throw new Error(\"\\\"value\\\" metadata for a Dictionary must be defined in the \" + \"mapper and it must of type \\\"object\\\" in \".concat(objectName, \".\"));\n  }\n  var tempDictionary = {};\n  for (var _i = 0, _Object$keys = Object.keys(object); _i < _Object$keys.length; _i++) {\n    var key = _Object$keys[_i];\n    var serializedValue = serializer.serialize(valueType, object[key], objectName, options);\n    // If the element needs an XML namespace we need to add it within the $ property\n    tempDictionary[key] = getXmlObjectValue(valueType, serializedValue, isXml, options);\n  }\n  // Add the namespace to the root element if needed\n  if (isXml && mapper.xmlNamespace) {\n    var xmlnsKey = mapper.xmlNamespacePrefix ? \"xmlns:\".concat(mapper.xmlNamespacePrefix) : \"xmlns\";\n    var result = tempDictionary;\n    result[XML_ATTRKEY] = _defineProperty({}, xmlnsKey, mapper.xmlNamespace);\n    return result;\n  }\n  return tempDictionary;\n}\n/**\n * Resolves the additionalProperties property from a referenced mapper.\n * @param serializer - The serializer containing the entire set of mappers.\n * @param mapper - The composite mapper to resolve.\n * @param objectName - Name of the object being serialized.\n */\nfunction resolveAdditionalProperties(serializer, mapper, objectName) {\n  var additionalProperties = mapper.type.additionalProperties;\n  if (!additionalProperties && mapper.type.className) {\n    var modelMapper = resolveReferencedMapper(serializer, mapper, objectName);\n    return modelMapper === null || modelMapper === void 0 ? void 0 : modelMapper.type.additionalProperties;\n  }\n  return additionalProperties;\n}\n/**\n * Finds the mapper referenced by `className`.\n * @param serializer - The serializer containing the entire set of mappers\n * @param mapper - The composite mapper to resolve\n * @param objectName - Name of the object being serialized\n */\nfunction resolveReferencedMapper(serializer, mapper, objectName) {\n  var className = mapper.type.className;\n  if (!className) {\n    throw new Error(\"Class name for model \\\"\".concat(objectName, \"\\\" is not provided in the mapper \\\"\").concat(JSON.stringify(mapper, undefined, 2), \"\\\".\"));\n  }\n  return serializer.modelMappers[className];\n}\n/**\n * Resolves a composite mapper's modelProperties.\n * @param serializer - The serializer containing the entire set of mappers\n * @param mapper - The composite mapper to resolve\n */\nfunction resolveModelProperties(serializer, mapper, objectName) {\n  var modelProps = mapper.type.modelProperties;\n  if (!modelProps) {\n    var modelMapper = resolveReferencedMapper(serializer, mapper, objectName);\n    if (!modelMapper) {\n      throw new Error(\"mapper() cannot be null or undefined for model \\\"\".concat(mapper.type.className, \"\\\".\"));\n    }\n    modelProps = modelMapper === null || modelMapper === void 0 ? void 0 : modelMapper.type.modelProperties;\n    if (!modelProps) {\n      throw new Error(\"modelProperties cannot be null or undefined in the \" + \"mapper \\\"\".concat(JSON.stringify(modelMapper), \"\\\" of type \\\"\").concat(mapper.type.className, \"\\\" for object \\\"\").concat(objectName, \"\\\".\"));\n    }\n  }\n  return modelProps;\n}\nfunction serializeCompositeType(serializer, mapper, object, objectName, isXml, options) {\n  if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {\n    mapper = getPolymorphicMapper(serializer, mapper, object, \"clientName\");\n  }\n  if (object != undefined) {\n    var payload = {};\n    var modelProps = resolveModelProperties(serializer, mapper, objectName);\n    for (var _i2 = 0, _Object$keys2 = Object.keys(modelProps); _i2 < _Object$keys2.length; _i2++) {\n      var key = _Object$keys2[_i2];\n      var propertyMapper = modelProps[key];\n      if (propertyMapper.readOnly) {\n        continue;\n      }\n      var propName = void 0;\n      var parentObject = payload;\n      if (serializer.isXML) {\n        if (propertyMapper.xmlIsWrapped) {\n          propName = propertyMapper.xmlName;\n        } else {\n          propName = propertyMapper.xmlElementName || propertyMapper.xmlName;\n        }\n      } else {\n        var paths = splitSerializeName(propertyMapper.serializedName);\n        propName = paths.pop();\n        var _iterator2 = _createForOfIteratorHelper(paths),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var pathName = _step2.value;\n            var childObject = parentObject[pathName];\n            if (childObject == undefined && (object[key] != undefined || propertyMapper.defaultValue !== undefined)) {\n              parentObject[pathName] = {};\n            }\n            parentObject = parentObject[pathName];\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n      if (parentObject != undefined) {\n        if (isXml && mapper.xmlNamespace) {\n          var xmlnsKey = mapper.xmlNamespacePrefix ? \"xmlns:\".concat(mapper.xmlNamespacePrefix) : \"xmlns\";\n          parentObject[XML_ATTRKEY] = Object.assign(Object.assign({}, parentObject[XML_ATTRKEY]), _defineProperty({}, xmlnsKey, mapper.xmlNamespace));\n        }\n        var propertyObjectName = propertyMapper.serializedName !== \"\" ? objectName + \".\" + propertyMapper.serializedName : objectName;\n        var toSerialize = object[key];\n        var polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);\n        if (polymorphicDiscriminator && polymorphicDiscriminator.clientName === key && toSerialize == undefined) {\n          toSerialize = mapper.serializedName;\n        }\n        var serializedValue = serializer.serialize(propertyMapper, toSerialize, propertyObjectName, options);\n        if (serializedValue !== undefined && propName != undefined) {\n          var value = getXmlObjectValue(propertyMapper, serializedValue, isXml, options);\n          if (isXml && propertyMapper.xmlIsAttribute) {\n            // XML_ATTRKEY, i.e., $ is the key attributes are kept under in xml2js.\n            // This keeps things simple while preventing name collision\n            // with names in user documents.\n            parentObject[XML_ATTRKEY] = parentObject[XML_ATTRKEY] || {};\n            parentObject[XML_ATTRKEY][propName] = serializedValue;\n          } else if (isXml && propertyMapper.xmlIsWrapped) {\n            parentObject[propName] = _defineProperty({}, propertyMapper.xmlElementName, value);\n          } else {\n            parentObject[propName] = value;\n          }\n        }\n      }\n    }\n    var additionalPropertiesMapper = resolveAdditionalProperties(serializer, mapper, objectName);\n    if (additionalPropertiesMapper) {\n      var propNames = Object.keys(modelProps);\n      var _loop = function _loop(clientPropName) {\n        var isAdditionalProperty = propNames.every(function (pn) {\n          return pn !== clientPropName;\n        });\n        if (isAdditionalProperty) {\n          payload[clientPropName] = serializer.serialize(additionalPropertiesMapper, object[clientPropName], objectName + '[\"' + clientPropName + '\"]', options);\n        }\n      };\n      for (var clientPropName in object) {\n        _loop(clientPropName);\n      }\n    }\n    return payload;\n  }\n  return object;\n}\nfunction getXmlObjectValue(propertyMapper, serializedValue, isXml, options) {\n  if (!isXml || !propertyMapper.xmlNamespace) {\n    return serializedValue;\n  }\n  var xmlnsKey = propertyMapper.xmlNamespacePrefix ? \"xmlns:\".concat(propertyMapper.xmlNamespacePrefix) : \"xmlns\";\n  var xmlNamespace = _defineProperty({}, xmlnsKey, propertyMapper.xmlNamespace);\n  if ([\"Composite\"].includes(propertyMapper.type.name)) {\n    if (serializedValue[XML_ATTRKEY]) {\n      return serializedValue;\n    } else {\n      var _result = Object.assign({}, serializedValue);\n      _result[XML_ATTRKEY] = xmlNamespace;\n      return _result;\n    }\n  }\n  var result = {};\n  result[options.xmlCharKey] = serializedValue;\n  result[XML_ATTRKEY] = xmlNamespace;\n  return result;\n}\nfunction isSpecialXmlProperty(propertyName, options) {\n  return [XML_ATTRKEY, options.xmlCharKey].includes(propertyName);\n}\nfunction deserializeCompositeType(serializer, mapper, responseBody, objectName, options) {\n  var _a, _b;\n  var xmlCharKey = (_a = options.xmlCharKey) !== null && _a !== void 0 ? _a : XML_CHARKEY;\n  if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {\n    mapper = getPolymorphicMapper(serializer, mapper, responseBody, \"serializedName\");\n  }\n  var modelProps = resolveModelProperties(serializer, mapper, objectName);\n  var instance = {};\n  var handledPropertyNames = [];\n  for (var _i3 = 0, _Object$keys3 = Object.keys(modelProps); _i3 < _Object$keys3.length; _i3++) {\n    var key = _Object$keys3[_i3];\n    var propertyMapper = modelProps[key];\n    var paths = splitSerializeName(modelProps[key].serializedName);\n    handledPropertyNames.push(paths[0]);\n    var serializedName = propertyMapper.serializedName,\n      xmlName = propertyMapper.xmlName,\n      xmlElementName = propertyMapper.xmlElementName;\n    var propertyObjectName = objectName;\n    if (serializedName !== \"\" && serializedName !== undefined) {\n      propertyObjectName = objectName + \".\" + serializedName;\n    }\n    var headerCollectionPrefix = propertyMapper.headerCollectionPrefix;\n    if (headerCollectionPrefix) {\n      var dictionary = {};\n      for (var _i4 = 0, _Object$keys4 = Object.keys(responseBody); _i4 < _Object$keys4.length; _i4++) {\n        var headerKey = _Object$keys4[_i4];\n        if (headerKey.startsWith(headerCollectionPrefix)) {\n          dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer.deserialize(propertyMapper.type.value, responseBody[headerKey], propertyObjectName, options);\n        }\n        handledPropertyNames.push(headerKey);\n      }\n      instance[key] = dictionary;\n    } else if (serializer.isXML) {\n      if (propertyMapper.xmlIsAttribute && responseBody[XML_ATTRKEY]) {\n        instance[key] = serializer.deserialize(propertyMapper, responseBody[XML_ATTRKEY][xmlName], propertyObjectName, options);\n      } else if (propertyMapper.xmlIsMsText) {\n        if (responseBody[xmlCharKey] !== undefined) {\n          instance[key] = responseBody[xmlCharKey];\n        } else if (typeof responseBody === \"string\") {\n          // The special case where xml parser parses \"<Name>content</Name>\" into JSON of\n          //   `{ name: \"content\"}` instead of `{ name: { \"_\": \"content\" }}`\n          instance[key] = responseBody;\n        }\n      } else {\n        var propertyName = xmlElementName || xmlName || serializedName;\n        if (propertyMapper.xmlIsWrapped) {\n          /* a list of <xmlElementName> wrapped by <xmlName>\n            For the xml example below\n              <Cors>\n                <CorsRule>...</CorsRule>\n                <CorsRule>...</CorsRule>\n              </Cors>\n            the responseBody has\n              {\n                Cors: {\n                  CorsRule: [{...}, {...}]\n                }\n              }\n            xmlName is \"Cors\" and xmlElementName is\"CorsRule\".\n          */\n          var wrapped = responseBody[xmlName];\n          var elementList = (_b = wrapped === null || wrapped === void 0 ? void 0 : wrapped[xmlElementName]) !== null && _b !== void 0 ? _b : [];\n          instance[key] = serializer.deserialize(propertyMapper, elementList, propertyObjectName, options);\n        } else {\n          var property = responseBody[propertyName];\n          instance[key] = serializer.deserialize(propertyMapper, property, propertyObjectName, options);\n        }\n      }\n    } else {\n      // deserialize the property if it is present in the provided responseBody instance\n      var propertyInstance = void 0;\n      var res = responseBody;\n      // traversing the object step by step.\n      var _iterator3 = _createForOfIteratorHelper(paths),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var item = _step3.value;\n          if (!res) break;\n          res = res[item];\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      propertyInstance = res;\n      var polymorphicDiscriminator = mapper.type.polymorphicDiscriminator;\n      // checking that the model property name (key)(ex: \"fishtype\") and the\n      // clientName of the polymorphicDiscriminator {metadata} (ex: \"fishtype\")\n      // instead of the serializedName of the polymorphicDiscriminator (ex: \"fish.type\")\n      // is a better approach. The generator is not consistent with escaping '\\.' in the\n      // serializedName of the property (ex: \"fish\\.type\") that is marked as polymorphic discriminator\n      // and the serializedName of the metadata polymorphicDiscriminator (ex: \"fish.type\"). However,\n      // the clientName transformation of the polymorphicDiscriminator (ex: \"fishtype\") and\n      // the transformation of model property name (ex: \"fishtype\") is done consistently.\n      // Hence, it is a safer bet to rely on the clientName of the polymorphicDiscriminator.\n      if (polymorphicDiscriminator && key === polymorphicDiscriminator.clientName && propertyInstance == undefined) {\n        propertyInstance = mapper.serializedName;\n      }\n      var serializedValue = void 0;\n      // paging\n      if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === \"\") {\n        propertyInstance = responseBody[key];\n        var arrayInstance = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);\n        // Copy over any properties that have already been added into the instance, where they do\n        // not exist on the newly de-serialized array\n        for (var _i5 = 0, _Object$entries = Object.entries(instance); _i5 < _Object$entries.length; _i5++) {\n          var _Object$entries$_i = _slicedToArray(_Object$entries[_i5], 2),\n            k = _Object$entries$_i[0],\n            v = _Object$entries$_i[1];\n          if (!Object.prototype.hasOwnProperty.call(arrayInstance, k)) {\n            arrayInstance[k] = v;\n          }\n        }\n        instance = arrayInstance;\n      } else if (propertyInstance !== undefined || propertyMapper.defaultValue !== undefined) {\n        serializedValue = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);\n        instance[key] = serializedValue;\n      }\n    }\n  }\n  var additionalPropertiesMapper = mapper.type.additionalProperties;\n  if (additionalPropertiesMapper) {\n    var isAdditionalProperty = function isAdditionalProperty(responsePropName) {\n      for (var clientPropName in modelProps) {\n        var _paths = splitSerializeName(modelProps[clientPropName].serializedName);\n        if (_paths[0] === responsePropName) {\n          return false;\n        }\n      }\n      return true;\n    };\n    for (var responsePropName in responseBody) {\n      if (isAdditionalProperty(responsePropName)) {\n        instance[responsePropName] = serializer.deserialize(additionalPropertiesMapper, responseBody[responsePropName], objectName + '[\"' + responsePropName + '\"]', options);\n      }\n    }\n  } else if (responseBody) {\n    for (var _i6 = 0, _Object$keys5 = Object.keys(responseBody); _i6 < _Object$keys5.length; _i6++) {\n      var _key = _Object$keys5[_i6];\n      if (instance[_key] === undefined && !handledPropertyNames.includes(_key) && !isSpecialXmlProperty(_key, options)) {\n        instance[_key] = responseBody[_key];\n      }\n    }\n  }\n  return instance;\n}\nfunction deserializeDictionaryType(serializer, mapper, responseBody, objectName, options) {\n  var value = mapper.type.value;\n  if (!value || typeof value !== \"object\") {\n    throw new Error(\"\\\"value\\\" metadata for a Dictionary must be defined in the \" + \"mapper and it must of type \\\"object\\\" in \".concat(objectName));\n  }\n  if (responseBody) {\n    var tempDictionary = {};\n    for (var _i7 = 0, _Object$keys6 = Object.keys(responseBody); _i7 < _Object$keys6.length; _i7++) {\n      var key = _Object$keys6[_i7];\n      tempDictionary[key] = serializer.deserialize(value, responseBody[key], objectName, options);\n    }\n    return tempDictionary;\n  }\n  return responseBody;\n}\nfunction deserializeSequenceType(serializer, mapper, responseBody, objectName, options) {\n  var element = mapper.type.element;\n  if (!element || typeof element !== \"object\") {\n    throw new Error(\"element\\\" metadata for an Array must be defined in the \" + \"mapper and it must of type \\\"object\\\" in \".concat(objectName));\n  }\n  if (responseBody) {\n    if (!Array.isArray(responseBody)) {\n      // xml2js will interpret a single element array as just the element, so force it to be an array\n      responseBody = [responseBody];\n    }\n    var tempArray = [];\n    for (var i = 0; i < responseBody.length; i++) {\n      tempArray[i] = serializer.deserialize(element, responseBody[i], \"\".concat(objectName, \"[\").concat(i, \"]\"), options);\n    }\n    return tempArray;\n  }\n  return responseBody;\n}\nfunction getPolymorphicMapper(serializer, mapper, object, polymorphicPropertyName) {\n  var polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);\n  if (polymorphicDiscriminator) {\n    var discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];\n    if (discriminatorName != undefined) {\n      var discriminatorValue = object[discriminatorName];\n      if (discriminatorValue != undefined) {\n        var typeName = mapper.type.uberParent || mapper.type.className;\n        var indexDiscriminator = discriminatorValue === typeName ? discriminatorValue : typeName + \".\" + discriminatorValue;\n        var polymorphicMapper = serializer.modelMappers.discriminators[indexDiscriminator];\n        if (polymorphicMapper) {\n          mapper = polymorphicMapper;\n        }\n      }\n    }\n  }\n  return mapper;\n}\nfunction getPolymorphicDiscriminatorRecursively(serializer, mapper) {\n  return mapper.type.polymorphicDiscriminator || getPolymorphicDiscriminatorSafely(serializer, mapper.type.uberParent) || getPolymorphicDiscriminatorSafely(serializer, mapper.type.className);\n}\nfunction getPolymorphicDiscriminatorSafely(serializer, typeName) {\n  return typeName && serializer.modelMappers[typeName] && serializer.modelMappers[typeName].type.polymorphicDiscriminator;\n}\n/**\n * Utility function that serializes an object that might contain binary information into a plain object, array or a string.\n */\nexport function serializeObject(toSerialize) {\n  var castToSerialize = toSerialize;\n  if (toSerialize == undefined) return undefined;\n  if (toSerialize instanceof Uint8Array) {\n    toSerialize = base64.encodeByteArray(toSerialize);\n    return toSerialize;\n  } else if (toSerialize instanceof Date) {\n    return toSerialize.toISOString();\n  } else if (Array.isArray(toSerialize)) {\n    var array = [];\n    for (var i = 0; i < toSerialize.length; i++) {\n      array.push(serializeObject(toSerialize[i]));\n    }\n    return array;\n  } else if (typeof toSerialize === \"object\") {\n    var dictionary = {};\n    for (var property in toSerialize) {\n      dictionary[property] = serializeObject(castToSerialize[property]);\n    }\n    return dictionary;\n  }\n  return toSerialize;\n}\n/**\n * Utility function to create a K:V from a list of strings\n */\nfunction strEnum(o) {\n  var result = {};\n  var _iterator4 = _createForOfIteratorHelper(o),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var key = _step4.value;\n      result[key] = key;\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n  return result;\n}\n/**\n * String enum containing the string types of property mappers.\n */\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport var MapperType = strEnum([\"Base64Url\", \"Boolean\", \"ByteArray\", \"Composite\", \"Date\", \"DateTime\", \"DateTimeRfc1123\", \"Dictionary\", \"Enum\", \"Number\", \"Object\", \"Sequence\", \"String\", \"Stream\", \"TimeSpan\", \"UnixTime\"]);","map":{"version":3,"mappings":"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","names":["base64","utils","XML_ATTRKEY","XML_CHARKEY","Serializer","modelMappers","isXML","mapper","value","objectName","failValidation","constraintName","constraintValue","Error","constraints","undefined","valueAsNumber","ExclusiveMaximum","ExclusiveMinimum","InclusiveMaximum","InclusiveMinimum","MaxItems","MaxLength","MinItems","MinLength","MultipleOf","Pattern","UniqueItems","valueAsArray","length","pattern","RegExp","match","some","item","i","ar","indexOf","object","options","updatedOptions","rootName","includeRoot","xmlCharKey","payload","mapperType","type","name","serializedName","isConstant","defaultValue","required","nullable","serializeBasicTypes","enumMapper","serializeEnumType","allowedValues","serializeDateTypes","serializeByteArrayType","serializeBase64UrlType","serializeSequenceType","Boolean","serializeDictionaryType","serializeCompositeType","responseBody","xmlIsWrapped","deserializeCompositeType","castResponseBody","parseFloat","isNaN","Date","unixTimeToDate","decodeString","base64UrlToByteArray","deserializeSequenceType","deserializeDictionaryType","trimEnd","str","ch","len","substr","bufferToBase64Url","buffer","Uint8Array","encodeByteArray","replace","valueOf","splitSerializeName","prop","classes","partialclass","subwords","split","charAt","push","dateToUnixTime","d","Math","floor","getTime","n","typeName","isValidUuid","objectType","ArrayBuffer","isView","Blob","isPresent","toLowerCase","JSON","stringify","returnValue","parse","toISOString","substring","toUTCString","isDuration","serializer","isXml","Array","isArray","elementType","element","tempArray","serializedValue","serialize","xmlNamespace","xmlnsKey","xmlNamespacePrefix","valueType","tempDictionary","Object","keys","key","getXmlObjectValue","result","resolveAdditionalProperties","additionalProperties","className","modelMapper","resolveReferencedMapper","resolveModelProperties","modelProps","modelProperties","getPolymorphicDiscriminatorRecursively","getPolymorphicMapper","propertyMapper","readOnly","propName","parentObject","xmlName","xmlElementName","paths","pop","pathName","childObject","propertyObjectName","toSerialize","polymorphicDiscriminator","clientName","xmlIsAttribute","additionalPropertiesMapper","propNames","clientPropName","isAdditionalProperty","every","pn","includes","isSpecialXmlProperty","propertyName","instance","handledPropertyNames","headerCollectionPrefix","dictionary","headerKey","startsWith","deserialize","xmlIsMsText","wrapped","elementList","property","propertyInstance","res","arrayInstance","entries","k","v","prototype","hasOwnProperty","call","responsePropName","polymorphicPropertyName","discriminatorName","discriminatorValue","uberParent","indexDiscriminator","polymorphicMapper","discriminators","getPolymorphicDiscriminatorSafely","serializeObject","castToSerialize","array","strEnum","o","MapperType"],"sourceRoot":"","sources":["../../src/serializer.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n/* eslint-disable eqeqeq */\n\nimport * as base64 from \"./util/base64\";\nimport * as utils from \"./util/utils\";\nimport { SerializerOptions, XML_ATTRKEY, XML_CHARKEY } from \"./util/serializer.common\";\n\n// This file contains utility code to serialize and deserialize network operations according to `OperationSpec` objects generated by AutoRest.TypeScript from OpenAPI specifications.\n\n/**\n * Used to map raw response objects to final shapes.\n * Helps packing and unpacking Dates and other encoded types that are not intrinsic to JSON.\n * Also allows pulling values from headers, as well as inserting default values and constants.\n */\nexport class Serializer {\n  constructor(\n    /**\n     * The provided model mapper.\n     */\n    public readonly modelMappers: { [key: string]: any } = {},\n    /**\n     * Whether the contents are XML or not.\n     */\n    public readonly isXML?: boolean\n  ) {}\n\n  /**\n   * Validates constraints, if any. This function will throw if the provided value does not respect those constraints.\n   * @param mapper - The definition of data models.\n   * @param value - The value.\n   * @param objectName - Name of the object. Used in the error messages.\n   * @deprecated Removing the constraints validation on client side.\n   */\n  validateConstraints(mapper: Mapper, value: unknown, objectName: string): void {\n    const failValidation = (\n      constraintName: keyof MapperConstraints,\n      constraintValue: any\n    ): Error => {\n      throw new Error(\n        `\"${objectName}\" with value \"${value}\" should satisfy the constraint \"${constraintName}\": ${constraintValue}.`\n      );\n    };\n    if (mapper.constraints && value != undefined) {\n      const valueAsNumber = value as number;\n      const {\n        ExclusiveMaximum,\n        ExclusiveMinimum,\n        InclusiveMaximum,\n        InclusiveMinimum,\n        MaxItems,\n        MaxLength,\n        MinItems,\n        MinLength,\n        MultipleOf,\n        Pattern,\n        UniqueItems,\n      } = mapper.constraints;\n      if (ExclusiveMaximum != undefined && valueAsNumber >= ExclusiveMaximum) {\n        failValidation(\"ExclusiveMaximum\", ExclusiveMaximum);\n      }\n      if (ExclusiveMinimum != undefined && valueAsNumber <= ExclusiveMinimum) {\n        failValidation(\"ExclusiveMinimum\", ExclusiveMinimum);\n      }\n      if (InclusiveMaximum != undefined && valueAsNumber > InclusiveMaximum) {\n        failValidation(\"InclusiveMaximum\", InclusiveMaximum);\n      }\n      if (InclusiveMinimum != undefined && valueAsNumber < InclusiveMinimum) {\n        failValidation(\"InclusiveMinimum\", InclusiveMinimum);\n      }\n      const valueAsArray = value as any[];\n      if (MaxItems != undefined && valueAsArray.length > MaxItems) {\n        failValidation(\"MaxItems\", MaxItems);\n      }\n      if (MaxLength != undefined && valueAsArray.length > MaxLength) {\n        failValidation(\"MaxLength\", MaxLength);\n      }\n      if (MinItems != undefined && valueAsArray.length < MinItems) {\n        failValidation(\"MinItems\", MinItems);\n      }\n      if (MinLength != undefined && valueAsArray.length < MinLength) {\n        failValidation(\"MinLength\", MinLength);\n      }\n      if (MultipleOf != undefined && valueAsNumber % MultipleOf !== 0) {\n        failValidation(\"MultipleOf\", MultipleOf);\n      }\n      if (Pattern) {\n        const pattern: RegExp = typeof Pattern === \"string\" ? new RegExp(Pattern) : Pattern;\n        if (typeof value !== \"string\" || value.match(pattern) === null) {\n          failValidation(\"Pattern\", Pattern);\n        }\n      }\n      if (\n        UniqueItems &&\n        valueAsArray.some((item: any, i: number, ar: Array<any>) => ar.indexOf(item) !== i)\n      ) {\n        failValidation(\"UniqueItems\", UniqueItems);\n      }\n    }\n  }\n\n  /**\n   * Serialize the given object based on its metadata defined in the mapper.\n   *\n   * @param mapper - The mapper which defines the metadata of the serializable object.\n   * @param object - A valid Javascript object to be serialized.\n   * @param objectName - Name of the serialized object.\n   * @param options - additional options to deserialization.\n   * @returns A valid serialized Javascript object.\n   */\n  serialize(\n    mapper: Mapper,\n    object: unknown,\n    objectName?: string,\n    options: SerializerOptions = {}\n  ): any {\n    const updatedOptions: Required<SerializerOptions> = {\n      rootName: options.rootName ?? \"\",\n      includeRoot: options.includeRoot ?? false,\n      xmlCharKey: options.xmlCharKey ?? XML_CHARKEY,\n    };\n    let payload: any = {};\n    const mapperType = mapper.type.name as string;\n    if (!objectName) {\n      objectName = mapper.serializedName!;\n    }\n    if (mapperType.match(/^Sequence$/i) !== null) {\n      payload = [];\n    }\n\n    if (mapper.isConstant) {\n      object = mapper.defaultValue;\n    }\n\n    // This table of allowed values should help explain\n    // the mapper.required and mapper.nullable properties.\n    // X means \"neither undefined or null are allowed\".\n    //           || required\n    //           || true      | false\n    //  nullable || ==========================\n    //      true || null      | undefined/null\n    //     false || X         | undefined\n    // undefined || X         | undefined/null\n\n    const { required, nullable } = mapper;\n\n    if (required && nullable && object === undefined) {\n      throw new Error(`${objectName} cannot be undefined.`);\n    }\n    if (required && !nullable && object == undefined) {\n      throw new Error(`${objectName} cannot be null or undefined.`);\n    }\n    if (!required && nullable === false && object === null) {\n      throw new Error(`${objectName} cannot be null.`);\n    }\n\n    if (object == undefined) {\n      payload = object;\n    } else {\n      if (mapperType.match(/^any$/i) !== null) {\n        payload = object;\n      } else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i) !== null) {\n        payload = serializeBasicTypes(mapperType, objectName, object);\n      } else if (mapperType.match(/^Enum$/i) !== null) {\n        const enumMapper: EnumMapper = mapper as EnumMapper;\n        payload = serializeEnumType(objectName, enumMapper.type.allowedValues, object);\n      } else if (\n        mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i) !== null\n      ) {\n        payload = serializeDateTypes(mapperType, object, objectName);\n      } else if (mapperType.match(/^ByteArray$/i) !== null) {\n        payload = serializeByteArrayType(objectName, object as Uint8Array);\n      } else if (mapperType.match(/^Base64Url$/i) !== null) {\n        payload = serializeBase64UrlType(objectName, object as Uint8Array);\n      } else if (mapperType.match(/^Sequence$/i) !== null) {\n        payload = serializeSequenceType(\n          this,\n          mapper as SequenceMapper,\n          object,\n          objectName,\n          Boolean(this.isXML),\n          updatedOptions\n        );\n      } else if (mapperType.match(/^Dictionary$/i) !== null) {\n        payload = serializeDictionaryType(\n          this,\n          mapper as DictionaryMapper,\n          object,\n          objectName,\n          Boolean(this.isXML),\n          updatedOptions\n        );\n      } else if (mapperType.match(/^Composite$/i) !== null) {\n        payload = serializeCompositeType(\n          this,\n          mapper as CompositeMapper,\n          object,\n          objectName,\n          Boolean(this.isXML),\n          updatedOptions\n        );\n      }\n    }\n    return payload;\n  }\n\n  /**\n   * Deserialize the given object based on its metadata defined in the mapper.\n   *\n   * @param mapper - The mapper which defines the metadata of the serializable object.\n   * @param responseBody - A valid Javascript entity to be deserialized.\n   * @param objectName - Name of the deserialized object.\n   * @param options - Controls behavior of XML parser and builder.\n   * @returns A valid deserialized Javascript object.\n   */\n  deserialize(\n    mapper: Mapper,\n    responseBody: unknown,\n    objectName: string,\n    options: SerializerOptions = {}\n  ): any {\n    const updatedOptions: Required<SerializerOptions> = {\n      rootName: options.rootName ?? \"\",\n      includeRoot: options.includeRoot ?? false,\n      xmlCharKey: options.xmlCharKey ?? XML_CHARKEY,\n    };\n    if (responseBody == undefined) {\n      if (this.isXML && mapper.type.name === \"Sequence\" && !mapper.xmlIsWrapped) {\n        // Edge case for empty XML non-wrapped lists. xml2js can't distinguish\n        // between the list being empty versus being missing,\n        // so let's do the more user-friendly thing and return an empty list.\n        responseBody = [];\n      }\n      // specifically check for undefined as default value can be a falsey value `0, \"\", false, null`\n      if (mapper.defaultValue !== undefined) {\n        responseBody = mapper.defaultValue;\n      }\n      return responseBody;\n    }\n\n    let payload: any;\n    const mapperType = mapper.type.name;\n    if (!objectName) {\n      objectName = mapper.serializedName!;\n    }\n\n    if (mapperType.match(/^Composite$/i) !== null) {\n      payload = deserializeCompositeType(\n        this,\n        mapper as CompositeMapper,\n        responseBody,\n        objectName,\n        updatedOptions\n      );\n    } else {\n      if (this.isXML) {\n        const xmlCharKey = updatedOptions.xmlCharKey;\n        const castResponseBody = responseBody as Record<string, unknown>;\n        /**\n         * If the mapper specifies this as a non-composite type value but the responseBody contains\n         * both header (\"$\" i.e., XML_ATTRKEY) and body (\"#\" i.e., XML_CHARKEY) properties,\n         * then just reduce the responseBody value to the body (\"#\" i.e., XML_CHARKEY) property.\n         */\n        if (\n          castResponseBody[XML_ATTRKEY] != undefined &&\n          castResponseBody[xmlCharKey] != undefined\n        ) {\n          responseBody = castResponseBody[xmlCharKey];\n        }\n      }\n\n      if (mapperType.match(/^Number$/i) !== null) {\n        payload = parseFloat(responseBody as string);\n        if (isNaN(payload)) {\n          payload = responseBody;\n        }\n      } else if (mapperType.match(/^Boolean$/i) !== null) {\n        if (responseBody === \"true\") {\n          payload = true;\n        } else if (responseBody === \"false\") {\n          payload = false;\n        } else {\n          payload = responseBody;\n        }\n      } else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i) !== null) {\n        payload = responseBody;\n      } else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/i) !== null) {\n        payload = new Date(responseBody as string);\n      } else if (mapperType.match(/^UnixTime$/i) !== null) {\n        payload = unixTimeToDate(responseBody as number);\n      } else if (mapperType.match(/^ByteArray$/i) !== null) {\n        payload = base64.decodeString(responseBody as string);\n      } else if (mapperType.match(/^Base64Url$/i) !== null) {\n        payload = base64UrlToByteArray(responseBody as string);\n      } else if (mapperType.match(/^Sequence$/i) !== null) {\n        payload = deserializeSequenceType(\n          this,\n          mapper as SequenceMapper,\n          responseBody,\n          objectName,\n          updatedOptions\n        );\n      } else if (mapperType.match(/^Dictionary$/i) !== null) {\n        payload = deserializeDictionaryType(\n          this,\n          mapper as DictionaryMapper,\n          responseBody,\n          objectName,\n          updatedOptions\n        );\n      }\n    }\n\n    if (mapper.isConstant) {\n      payload = mapper.defaultValue;\n    }\n\n    return payload;\n  }\n}\n\nfunction trimEnd(str: string, ch: string): string {\n  let len = str.length;\n  while (len - 1 >= 0 && str[len - 1] === ch) {\n    --len;\n  }\n  return str.substr(0, len);\n}\n\nfunction bufferToBase64Url(buffer: any): string | undefined {\n  if (!buffer) {\n    return undefined;\n  }\n  if (!(buffer instanceof Uint8Array)) {\n    throw new Error(`Please provide an input of type Uint8Array for converting to Base64Url.`);\n  }\n  // Uint8Array to Base64.\n  const str = base64.encodeByteArray(buffer);\n  // Base64 to Base64Url.\n  return trimEnd(str, \"=\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\n\nfunction base64UrlToByteArray(str: string): Uint8Array | undefined {\n  if (!str) {\n    return undefined;\n  }\n  if (str && typeof str.valueOf() !== \"string\") {\n    throw new Error(\"Please provide an input of type string for converting to Uint8Array\");\n  }\n  // Base64Url to Base64.\n  str = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  // Base64 to Uint8Array.\n  return base64.decodeString(str);\n}\n\nfunction splitSerializeName(prop: string | undefined): string[] {\n  const classes: string[] = [];\n  let partialclass = \"\";\n  if (prop) {\n    const subwords = prop.split(\".\");\n\n    for (const item of subwords) {\n      if (item.charAt(item.length - 1) === \"\\\\\") {\n        partialclass += item.substr(0, item.length - 1) + \".\";\n      } else {\n        partialclass += item;\n        classes.push(partialclass);\n        partialclass = \"\";\n      }\n    }\n  }\n\n  return classes;\n}\n\nfunction dateToUnixTime(d: string | Date): number | undefined {\n  if (!d) {\n    return undefined;\n  }\n\n  if (typeof d.valueOf() === \"string\") {\n    d = new Date(d as string);\n  }\n  return Math.floor((d as Date).getTime() / 1000);\n}\n\nfunction unixTimeToDate(n: number): Date | undefined {\n  if (!n) {\n    return undefined;\n  }\n  return new Date(n * 1000);\n}\n\nfunction serializeBasicTypes(typeName: string, objectName: string, value: any): any {\n  if (value !== null && value !== undefined) {\n    if (typeName.match(/^Number$/i) !== null) {\n      if (typeof value !== \"number\") {\n        throw new Error(`${objectName} with value ${value} must be of type number.`);\n      }\n    } else if (typeName.match(/^String$/i) !== null) {\n      if (typeof value.valueOf() !== \"string\") {\n        throw new Error(`${objectName} with value \"${value}\" must be of type string.`);\n      }\n    } else if (typeName.match(/^Uuid$/i) !== null) {\n      if (!(typeof value.valueOf() === \"string\" && utils.isValidUuid(value))) {\n        throw new Error(\n          `${objectName} with value \"${value}\" must be of type string and a valid uuid.`\n        );\n      }\n    } else if (typeName.match(/^Boolean$/i) !== null) {\n      if (typeof value !== \"boolean\") {\n        throw new Error(`${objectName} with value ${value} must be of type boolean.`);\n      }\n    } else if (typeName.match(/^Stream$/i) !== null) {\n      const objectType = typeof value;\n      if (\n        objectType !== \"string\" &&\n        objectType !== \"function\" &&\n        !(value instanceof ArrayBuffer) &&\n        !ArrayBuffer.isView(value) &&\n        !((typeof Blob === \"function\" || typeof Blob === \"object\") && value instanceof Blob)\n      ) {\n        throw new Error(\n          `${objectName} must be a string, Blob, ArrayBuffer, ArrayBufferView, or a function returning NodeJS.ReadableStream.`\n        );\n      }\n    }\n  }\n\n  return value;\n}\n\nfunction serializeEnumType(objectName: string, allowedValues: Array<any>, value: any): any {\n  if (!allowedValues) {\n    throw new Error(\n      `Please provide a set of allowedValues to validate ${objectName} as an Enum Type.`\n    );\n  }\n  const isPresent = allowedValues.some((item) => {\n    if (typeof item.valueOf() === \"string\") {\n      return item.toLowerCase() === value.toLowerCase();\n    }\n    return item === value;\n  });\n  if (!isPresent) {\n    throw new Error(\n      `${value} is not a valid value for ${objectName}. The valid values are: ${JSON.stringify(\n        allowedValues\n      )}.`\n    );\n  }\n  return value;\n}\n\nfunction serializeByteArrayType(objectName: string, value: Uint8Array): string {\n  let returnValue: string = \"\";\n  if (value != undefined) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error(`${objectName} must be of type Uint8Array.`);\n    }\n    returnValue = base64.encodeByteArray(value);\n  }\n  return returnValue;\n}\n\nfunction serializeBase64UrlType(objectName: string, value: Uint8Array): string {\n  let returnValue: string = \"\";\n  if (value != undefined) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error(`${objectName} must be of type Uint8Array.`);\n    }\n    returnValue = bufferToBase64Url(value) || \"\";\n  }\n  return returnValue;\n}\n\nfunction serializeDateTypes(typeName: string, value: any, objectName: string): any {\n  if (value != undefined) {\n    if (typeName.match(/^Date$/i) !== null) {\n      if (\n        !(\n          value instanceof Date ||\n          (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))\n        )\n      ) {\n        throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);\n      }\n      value =\n        value instanceof Date\n          ? value.toISOString().substring(0, 10)\n          : new Date(value).toISOString().substring(0, 10);\n    } else if (typeName.match(/^DateTime$/i) !== null) {\n      if (\n        !(\n          value instanceof Date ||\n          (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))\n        )\n      ) {\n        throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);\n      }\n      value = value instanceof Date ? value.toISOString() : new Date(value).toISOString();\n    } else if (typeName.match(/^DateTimeRfc1123$/i) !== null) {\n      if (\n        !(\n          value instanceof Date ||\n          (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))\n        )\n      ) {\n        throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123 format.`);\n      }\n      value = value instanceof Date ? value.toUTCString() : new Date(value).toUTCString();\n    } else if (typeName.match(/^UnixTime$/i) !== null) {\n      if (\n        !(\n          value instanceof Date ||\n          (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))\n        )\n      ) {\n        throw new Error(\n          `${objectName} must be an instanceof Date or a string in RFC-1123/ISO8601 format ` +\n            `for it to be serialized in UnixTime/Epoch format.`\n        );\n      }\n      value = dateToUnixTime(value);\n    } else if (typeName.match(/^TimeSpan$/i) !== null) {\n      if (!utils.isDuration(value)) {\n        throw new Error(\n          `${objectName} must be a string in ISO 8601 format. Instead was \"${value}\".`\n        );\n      }\n    }\n  }\n  return value;\n}\n\nfunction serializeSequenceType(\n  serializer: Serializer,\n  mapper: SequenceMapper,\n  object: any,\n  objectName: string,\n  isXml: boolean,\n  options: Required<SerializerOptions>\n): any[] {\n  if (!Array.isArray(object)) {\n    throw new Error(`${objectName} must be of type Array.`);\n  }\n  const elementType = mapper.type.element;\n  if (!elementType || typeof elementType !== \"object\") {\n    throw new Error(\n      `element\" metadata for an Array must be defined in the ` +\n        `mapper and it must of type \"object\" in ${objectName}.`\n    );\n  }\n  const tempArray = [];\n  for (let i = 0; i < object.length; i++) {\n    const serializedValue = serializer.serialize(elementType, object[i], objectName, options);\n\n    if (isXml && elementType.xmlNamespace) {\n      const xmlnsKey = elementType.xmlNamespacePrefix\n        ? `xmlns:${elementType.xmlNamespacePrefix}`\n        : \"xmlns\";\n      if (elementType.type.name === \"Composite\") {\n        tempArray[i] = { ...serializedValue };\n        tempArray[i][XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };\n      } else {\n        tempArray[i] = {};\n        tempArray[i][options.xmlCharKey] = serializedValue;\n        tempArray[i][XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };\n      }\n    } else {\n      tempArray[i] = serializedValue;\n    }\n  }\n  return tempArray;\n}\n\nfunction serializeDictionaryType(\n  serializer: Serializer,\n  mapper: DictionaryMapper,\n  object: any,\n  objectName: string,\n  isXml: boolean,\n  options: Required<SerializerOptions>\n): { [key: string]: any } {\n  if (typeof object !== \"object\") {\n    throw new Error(`${objectName} must be of type object.`);\n  }\n  const valueType = mapper.type.value;\n  if (!valueType || typeof valueType !== \"object\") {\n    throw new Error(\n      `\"value\" metadata for a Dictionary must be defined in the ` +\n        `mapper and it must of type \"object\" in ${objectName}.`\n    );\n  }\n  const tempDictionary: { [key: string]: any } = {};\n  for (const key of Object.keys(object)) {\n    const serializedValue = serializer.serialize(valueType, object[key], objectName, options);\n    // If the element needs an XML namespace we need to add it within the $ property\n    tempDictionary[key] = getXmlObjectValue(valueType, serializedValue, isXml, options);\n  }\n\n  // Add the namespace to the root element if needed\n  if (isXml && mapper.xmlNamespace) {\n    const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : \"xmlns\";\n\n    const result = tempDictionary;\n    result[XML_ATTRKEY] = { [xmlnsKey]: mapper.xmlNamespace };\n    return result;\n  }\n\n  return tempDictionary;\n}\n\n/**\n * Resolves the additionalProperties property from a referenced mapper.\n * @param serializer - The serializer containing the entire set of mappers.\n * @param mapper - The composite mapper to resolve.\n * @param objectName - Name of the object being serialized.\n */\nfunction resolveAdditionalProperties(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  objectName: string\n): SequenceMapper | BaseMapper | CompositeMapper | DictionaryMapper | EnumMapper | undefined {\n  const additionalProperties = mapper.type.additionalProperties;\n\n  if (!additionalProperties && mapper.type.className) {\n    const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);\n    return modelMapper?.type.additionalProperties;\n  }\n\n  return additionalProperties;\n}\n\n/**\n * Finds the mapper referenced by `className`.\n * @param serializer - The serializer containing the entire set of mappers\n * @param mapper - The composite mapper to resolve\n * @param objectName - Name of the object being serialized\n */\nfunction resolveReferencedMapper(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  objectName: string\n): CompositeMapper | undefined {\n  const className = mapper.type.className;\n  if (!className) {\n    throw new Error(\n      `Class name for model \"${objectName}\" is not provided in the mapper \"${JSON.stringify(\n        mapper,\n        undefined,\n        2\n      )}\".`\n    );\n  }\n\n  return serializer.modelMappers[className];\n}\n\n/**\n * Resolves a composite mapper's modelProperties.\n * @param serializer - The serializer containing the entire set of mappers\n * @param mapper - The composite mapper to resolve\n */\nfunction resolveModelProperties(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  objectName: string\n): { [propertyName: string]: Mapper } {\n  let modelProps = mapper.type.modelProperties;\n  if (!modelProps) {\n    const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);\n    if (!modelMapper) {\n      throw new Error(`mapper() cannot be null or undefined for model \"${mapper.type.className}\".`);\n    }\n    modelProps = modelMapper?.type.modelProperties;\n    if (!modelProps) {\n      throw new Error(\n        `modelProperties cannot be null or undefined in the ` +\n          `mapper \"${JSON.stringify(modelMapper)}\" of type \"${\n            mapper.type.className\n          }\" for object \"${objectName}\".`\n      );\n    }\n  }\n\n  return modelProps;\n}\n\nfunction serializeCompositeType(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  object: any,\n  objectName: string,\n  isXml: boolean,\n  options: Required<SerializerOptions>\n): any {\n  if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {\n    mapper = getPolymorphicMapper(serializer, mapper, object, \"clientName\");\n  }\n\n  if (object != undefined) {\n    const payload: any = {};\n    const modelProps = resolveModelProperties(serializer, mapper, objectName);\n    for (const key of Object.keys(modelProps)) {\n      const propertyMapper = modelProps[key];\n      if (propertyMapper.readOnly) {\n        continue;\n      }\n\n      let propName: string | undefined;\n      let parentObject: any = payload;\n      if (serializer.isXML) {\n        if (propertyMapper.xmlIsWrapped) {\n          propName = propertyMapper.xmlName;\n        } else {\n          propName = propertyMapper.xmlElementName || propertyMapper.xmlName;\n        }\n      } else {\n        const paths = splitSerializeName(propertyMapper.serializedName!);\n        propName = paths.pop();\n\n        for (const pathName of paths) {\n          const childObject = parentObject[pathName];\n          if (\n            childObject == undefined &&\n            (object[key] != undefined || propertyMapper.defaultValue !== undefined)\n          ) {\n            parentObject[pathName] = {};\n          }\n          parentObject = parentObject[pathName];\n        }\n      }\n\n      if (parentObject != undefined) {\n        if (isXml && mapper.xmlNamespace) {\n          const xmlnsKey = mapper.xmlNamespacePrefix\n            ? `xmlns:${mapper.xmlNamespacePrefix}`\n            : \"xmlns\";\n          parentObject[XML_ATTRKEY] = {\n            ...parentObject[XML_ATTRKEY],\n            [xmlnsKey]: mapper.xmlNamespace,\n          };\n        }\n        const propertyObjectName =\n          propertyMapper.serializedName !== \"\"\n            ? objectName + \".\" + propertyMapper.serializedName\n            : objectName;\n\n        let toSerialize = object[key];\n        const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);\n        if (\n          polymorphicDiscriminator &&\n          polymorphicDiscriminator.clientName === key &&\n          toSerialize == undefined\n        ) {\n          toSerialize = mapper.serializedName;\n        }\n\n        const serializedValue = serializer.serialize(\n          propertyMapper,\n          toSerialize,\n          propertyObjectName,\n          options\n        );\n\n        if (serializedValue !== undefined && propName != undefined) {\n          const value = getXmlObjectValue(propertyMapper, serializedValue, isXml, options);\n          if (isXml && propertyMapper.xmlIsAttribute) {\n            // XML_ATTRKEY, i.e., $ is the key attributes are kept under in xml2js.\n            // This keeps things simple while preventing name collision\n            // with names in user documents.\n            parentObject[XML_ATTRKEY] = parentObject[XML_ATTRKEY] || {};\n            parentObject[XML_ATTRKEY][propName] = serializedValue;\n          } else if (isXml && propertyMapper.xmlIsWrapped) {\n            parentObject[propName] = { [propertyMapper.xmlElementName!]: value };\n          } else {\n            parentObject[propName] = value;\n          }\n        }\n      }\n    }\n\n    const additionalPropertiesMapper = resolveAdditionalProperties(serializer, mapper, objectName);\n    if (additionalPropertiesMapper) {\n      const propNames = Object.keys(modelProps);\n      for (const clientPropName in object) {\n        const isAdditionalProperty = propNames.every((pn) => pn !== clientPropName);\n        if (isAdditionalProperty) {\n          payload[clientPropName] = serializer.serialize(\n            additionalPropertiesMapper,\n            object[clientPropName],\n            objectName + '[\"' + clientPropName + '\"]',\n            options\n          );\n        }\n      }\n    }\n\n    return payload;\n  }\n  return object;\n}\n\nfunction getXmlObjectValue(\n  propertyMapper: Mapper,\n  serializedValue: any,\n  isXml: boolean,\n  options: Required<SerializerOptions>\n): any {\n  if (!isXml || !propertyMapper.xmlNamespace) {\n    return serializedValue;\n  }\n\n  const xmlnsKey = propertyMapper.xmlNamespacePrefix\n    ? `xmlns:${propertyMapper.xmlNamespacePrefix}`\n    : \"xmlns\";\n  const xmlNamespace = { [xmlnsKey]: propertyMapper.xmlNamespace };\n\n  if ([\"Composite\"].includes(propertyMapper.type.name)) {\n    if (serializedValue[XML_ATTRKEY]) {\n      return serializedValue;\n    } else {\n      const result: any = { ...serializedValue };\n      result[XML_ATTRKEY] = xmlNamespace;\n      return result;\n    }\n  }\n  const result: any = {};\n  result[options.xmlCharKey] = serializedValue;\n  result[XML_ATTRKEY] = xmlNamespace;\n  return result;\n}\n\nfunction isSpecialXmlProperty(propertyName: string, options: Required<SerializerOptions>): boolean {\n  return [XML_ATTRKEY, options.xmlCharKey].includes(propertyName);\n}\n\nfunction deserializeCompositeType(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  responseBody: any,\n  objectName: string,\n  options: Required<SerializerOptions>\n): any {\n  const xmlCharKey = options.xmlCharKey ?? XML_CHARKEY;\n  if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {\n    mapper = getPolymorphicMapper(serializer, mapper, responseBody, \"serializedName\");\n  }\n\n  const modelProps = resolveModelProperties(serializer, mapper, objectName);\n  let instance: { [key: string]: any } = {};\n  const handledPropertyNames: string[] = [];\n\n  for (const key of Object.keys(modelProps)) {\n    const propertyMapper = modelProps[key];\n    const paths = splitSerializeName(modelProps[key].serializedName!);\n    handledPropertyNames.push(paths[0]);\n    const { serializedName, xmlName, xmlElementName } = propertyMapper;\n    let propertyObjectName = objectName;\n    if (serializedName !== \"\" && serializedName !== undefined) {\n      propertyObjectName = objectName + \".\" + serializedName;\n    }\n\n    const headerCollectionPrefix = (propertyMapper as DictionaryMapper).headerCollectionPrefix;\n    if (headerCollectionPrefix) {\n      const dictionary: any = {};\n      for (const headerKey of Object.keys(responseBody)) {\n        if (headerKey.startsWith(headerCollectionPrefix)) {\n          dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer.deserialize(\n            (propertyMapper as DictionaryMapper).type.value,\n            responseBody[headerKey],\n            propertyObjectName,\n            options\n          );\n        }\n\n        handledPropertyNames.push(headerKey);\n      }\n      instance[key] = dictionary;\n    } else if (serializer.isXML) {\n      if (propertyMapper.xmlIsAttribute && responseBody[XML_ATTRKEY]) {\n        instance[key] = serializer.deserialize(\n          propertyMapper,\n          responseBody[XML_ATTRKEY][xmlName!],\n          propertyObjectName,\n          options\n        );\n      } else if (propertyMapper.xmlIsMsText) {\n        if (responseBody[xmlCharKey] !== undefined) {\n          instance[key] = responseBody[xmlCharKey];\n        } else if (typeof responseBody === \"string\") {\n          // The special case where xml parser parses \"<Name>content</Name>\" into JSON of\n          //   `{ name: \"content\"}` instead of `{ name: { \"_\": \"content\" }}`\n          instance[key] = responseBody;\n        }\n      } else {\n        const propertyName = xmlElementName || xmlName || serializedName;\n        if (propertyMapper.xmlIsWrapped) {\n          /* a list of <xmlElementName> wrapped by <xmlName>\n            For the xml example below\n              <Cors>\n                <CorsRule>...</CorsRule>\n                <CorsRule>...</CorsRule>\n              </Cors>\n            the responseBody has\n              {\n                Cors: {\n                  CorsRule: [{...}, {...}]\n                }\n              }\n            xmlName is \"Cors\" and xmlElementName is\"CorsRule\".\n          */\n          const wrapped = responseBody[xmlName!];\n          const elementList = wrapped?.[xmlElementName!] ?? [];\n          instance[key] = serializer.deserialize(\n            propertyMapper,\n            elementList,\n            propertyObjectName,\n            options\n          );\n        } else {\n          const property = responseBody[propertyName!];\n          instance[key] = serializer.deserialize(\n            propertyMapper,\n            property,\n            propertyObjectName,\n            options\n          );\n        }\n      }\n    } else {\n      // deserialize the property if it is present in the provided responseBody instance\n      let propertyInstance;\n      let res = responseBody;\n      // traversing the object step by step.\n      for (const item of paths) {\n        if (!res) break;\n        res = res[item];\n      }\n      propertyInstance = res;\n      const polymorphicDiscriminator = mapper.type.polymorphicDiscriminator;\n      // checking that the model property name (key)(ex: \"fishtype\") and the\n      // clientName of the polymorphicDiscriminator {metadata} (ex: \"fishtype\")\n      // instead of the serializedName of the polymorphicDiscriminator (ex: \"fish.type\")\n      // is a better approach. The generator is not consistent with escaping '\\.' in the\n      // serializedName of the property (ex: \"fish\\.type\") that is marked as polymorphic discriminator\n      // and the serializedName of the metadata polymorphicDiscriminator (ex: \"fish.type\"). However,\n      // the clientName transformation of the polymorphicDiscriminator (ex: \"fishtype\") and\n      // the transformation of model property name (ex: \"fishtype\") is done consistently.\n      // Hence, it is a safer bet to rely on the clientName of the polymorphicDiscriminator.\n      if (\n        polymorphicDiscriminator &&\n        key === polymorphicDiscriminator.clientName &&\n        propertyInstance == undefined\n      ) {\n        propertyInstance = mapper.serializedName;\n      }\n\n      let serializedValue;\n      // paging\n      if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === \"\") {\n        propertyInstance = responseBody[key];\n        const arrayInstance = serializer.deserialize(\n          propertyMapper,\n          propertyInstance,\n          propertyObjectName,\n          options\n        );\n        // Copy over any properties that have already been added into the instance, where they do\n        // not exist on the newly de-serialized array\n        for (const [k, v] of Object.entries(instance)) {\n          if (!Object.prototype.hasOwnProperty.call(arrayInstance, k)) {\n            arrayInstance[k] = v;\n          }\n        }\n        instance = arrayInstance;\n      } else if (propertyInstance !== undefined || propertyMapper.defaultValue !== undefined) {\n        serializedValue = serializer.deserialize(\n          propertyMapper,\n          propertyInstance,\n          propertyObjectName,\n          options\n        );\n        instance[key] = serializedValue;\n      }\n    }\n  }\n\n  const additionalPropertiesMapper = mapper.type.additionalProperties;\n  if (additionalPropertiesMapper) {\n    const isAdditionalProperty = (responsePropName: string): boolean => {\n      for (const clientPropName in modelProps) {\n        const paths = splitSerializeName(modelProps[clientPropName].serializedName);\n        if (paths[0] === responsePropName) {\n          return false;\n        }\n      }\n      return true;\n    };\n\n    for (const responsePropName in responseBody) {\n      if (isAdditionalProperty(responsePropName)) {\n        instance[responsePropName] = serializer.deserialize(\n          additionalPropertiesMapper,\n          responseBody[responsePropName],\n          objectName + '[\"' + responsePropName + '\"]',\n          options\n        );\n      }\n    }\n  } else if (responseBody) {\n    for (const key of Object.keys(responseBody)) {\n      if (\n        instance[key] === undefined &&\n        !handledPropertyNames.includes(key) &&\n        !isSpecialXmlProperty(key, options)\n      ) {\n        instance[key] = responseBody[key];\n      }\n    }\n  }\n\n  return instance;\n}\n\nfunction deserializeDictionaryType(\n  serializer: Serializer,\n  mapper: DictionaryMapper,\n  responseBody: any,\n  objectName: string,\n  options: Required<SerializerOptions>\n): { [key: string]: any } {\n  const value = mapper.type.value;\n  if (!value || typeof value !== \"object\") {\n    throw new Error(\n      `\"value\" metadata for a Dictionary must be defined in the ` +\n        `mapper and it must of type \"object\" in ${objectName}`\n    );\n  }\n  if (responseBody) {\n    const tempDictionary: { [key: string]: any } = {};\n    for (const key of Object.keys(responseBody)) {\n      tempDictionary[key] = serializer.deserialize(value, responseBody[key], objectName, options);\n    }\n    return tempDictionary;\n  }\n  return responseBody;\n}\n\nfunction deserializeSequenceType(\n  serializer: Serializer,\n  mapper: SequenceMapper,\n  responseBody: any,\n  objectName: string,\n  options: Required<SerializerOptions>\n): any[] {\n  const element = mapper.type.element;\n  if (!element || typeof element !== \"object\") {\n    throw new Error(\n      `element\" metadata for an Array must be defined in the ` +\n        `mapper and it must of type \"object\" in ${objectName}`\n    );\n  }\n  if (responseBody) {\n    if (!Array.isArray(responseBody)) {\n      // xml2js will interpret a single element array as just the element, so force it to be an array\n      responseBody = [responseBody];\n    }\n\n    const tempArray = [];\n    for (let i = 0; i < responseBody.length; i++) {\n      tempArray[i] = serializer.deserialize(\n        element,\n        responseBody[i],\n        `${objectName}[${i}]`,\n        options\n      );\n    }\n    return tempArray;\n  }\n  return responseBody;\n}\n\nfunction getPolymorphicMapper(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  object: any,\n  polymorphicPropertyName: \"clientName\" | \"serializedName\"\n): CompositeMapper {\n  const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);\n  if (polymorphicDiscriminator) {\n    const discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];\n    if (discriminatorName != undefined) {\n      const discriminatorValue = object[discriminatorName];\n      if (discriminatorValue != undefined) {\n        const typeName = mapper.type.uberParent || mapper.type.className;\n        const indexDiscriminator =\n          discriminatorValue === typeName\n            ? discriminatorValue\n            : typeName + \".\" + discriminatorValue;\n        const polymorphicMapper = serializer.modelMappers.discriminators[indexDiscriminator];\n        if (polymorphicMapper) {\n          mapper = polymorphicMapper;\n        }\n      }\n    }\n  }\n  return mapper;\n}\n\nfunction getPolymorphicDiscriminatorRecursively(\n  serializer: Serializer,\n  mapper: CompositeMapper\n): PolymorphicDiscriminator | undefined {\n  return (\n    mapper.type.polymorphicDiscriminator ||\n    getPolymorphicDiscriminatorSafely(serializer, mapper.type.uberParent) ||\n    getPolymorphicDiscriminatorSafely(serializer, mapper.type.className)\n  );\n}\n\nfunction getPolymorphicDiscriminatorSafely(serializer: Serializer, typeName?: string): any {\n  return (\n    typeName &&\n    serializer.modelMappers[typeName] &&\n    serializer.modelMappers[typeName].type.polymorphicDiscriminator\n  );\n}\n\n/**\n * Description of various value constraints such as integer ranges and string regex.\n */\nexport interface MapperConstraints {\n  /**\n   * The value should be less than or equal to the `InclusiveMaximum` value.\n   */\n  InclusiveMaximum?: number;\n  /**\n   * The value should be less than the `ExclusiveMaximum` value.\n   */\n  ExclusiveMaximum?: number;\n  /**\n   * The value should be greater than or equal to the `InclusiveMinimum` value.\n   */\n  InclusiveMinimum?: number;\n  /**\n   * The value should be greater than the `InclusiveMinimum` value.\n   */\n  ExclusiveMinimum?: number;\n  /**\n   * The length should be smaller than the `MaxLength`.\n   */\n  MaxLength?: number;\n  /**\n   * The length should be bigger than the `MinLength`.\n   */\n  MinLength?: number;\n  /**\n   * The value must match the pattern.\n   */\n  Pattern?: RegExp;\n  /**\n   * The value must contain fewer items than the MaxItems value.\n   */\n  MaxItems?: number;\n  /**\n   * The value must contain more items than the `MinItems` value.\n   */\n  MinItems?: number;\n  /**\n   * The value must contain only unique items.\n   */\n  UniqueItems?: true;\n  /**\n   * The value should be exactly divisible by the `MultipleOf` value.\n   */\n  MultipleOf?: number;\n}\n\n/**\n * Type of the mapper. Includes known mappers.\n */\nexport type MapperType =\n  | SimpleMapperType\n  | CompositeMapperType\n  | SequenceMapperType\n  | DictionaryMapperType\n  | EnumMapperType;\n\n/**\n * The type of a simple mapper.\n */\nexport interface SimpleMapperType {\n  /**\n   * Name of the type of the property.\n   */\n  name:\n    | \"Base64Url\"\n    | \"Boolean\"\n    | \"ByteArray\"\n    | \"Date\"\n    | \"DateTime\"\n    | \"DateTimeRfc1123\"\n    | \"Object\"\n    | \"Stream\"\n    | \"String\"\n    | \"TimeSpan\"\n    | \"UnixTime\"\n    | \"Uuid\"\n    | \"Number\"\n    | \"any\";\n}\n\n/**\n * Helps build a mapper that describes how to map a set of properties of an object based on other mappers.\n *\n * Only one of the following properties should be present: `className`, `modelProperties` and `additionalProperties`.\n */\nexport interface CompositeMapperType {\n  /**\n   * Name of the composite mapper type.\n   */\n  name: \"Composite\";\n\n  /**\n   * Use `className` to reference another type definition.\n   */\n  className?: string;\n\n  /**\n   * Use `modelProperties` when the reference to the other type has been resolved.\n   */\n  modelProperties?: { [propertyName: string]: Mapper };\n\n  /**\n   * Used when a model has `additionalProperties: true`. Allows the generic processing of unnamed model properties on the response object.\n   */\n  additionalProperties?: Mapper;\n\n  /**\n   * The name of the top-most parent scheme, the one that has no parents.\n   */\n  uberParent?: string;\n\n  /**\n   * A polymorphic discriminator.\n   */\n  polymorphicDiscriminator?: PolymorphicDiscriminator;\n}\n\n/**\n * Helps build a mapper that describes how to parse a sequence of mapped values.\n */\nexport interface SequenceMapperType {\n  /**\n   * Name of the sequence type mapper.\n   */\n  name: \"Sequence\";\n  /**\n   * The mapper to use to map each one of the properties of the sequence.\n   */\n  element: Mapper;\n}\n\n/**\n * Helps build a mapper that describes how to parse a dictionary of mapped values.\n */\nexport interface DictionaryMapperType {\n  /**\n   * Name of the sequence type mapper.\n   */\n  name: \"Dictionary\";\n  /**\n   * The mapper to use to map the value of each property in the dictionary.\n   */\n  value: Mapper;\n}\n\n/**\n * Helps build a mapper that describes how to parse an enum value.\n */\nexport interface EnumMapperType {\n  /**\n   * Name of the enum type mapper.\n   */\n  name: \"Enum\";\n  /**\n   * Values allowed by this mapper.\n   */\n  allowedValues: any[];\n}\n\n/**\n * The base definition of a mapper. Can be used for XML and plain JavaScript objects.\n */\nexport interface BaseMapper {\n  /**\n   * Name for the xml element\n   */\n  xmlName?: string;\n  /**\n   * Xml element namespace\n   */\n  xmlNamespace?: string;\n  /**\n   * Xml element namespace prefix\n   */\n  xmlNamespacePrefix?: string;\n  /**\n   * Determines if the current property should be serialized as an attribute of the parent xml element\n   */\n  xmlIsAttribute?: boolean;\n  /**\n   * Determines if the current property should be serialized as the inner content of the xml element\n   */\n  xmlIsMsText?: boolean;\n  /**\n   * Name for the xml elements when serializing an array\n   */\n  xmlElementName?: string;\n  /**\n   * Whether or not the current property should have a wrapping XML element\n   */\n  xmlIsWrapped?: boolean;\n  /**\n   * Whether or not the current property is readonly\n   */\n  readOnly?: boolean;\n  /**\n   * Whether or not the current property is a constant\n   */\n  isConstant?: boolean;\n  /**\n   * Whether or not the current property is required\n   */\n  required?: boolean;\n  /**\n   * Whether or not the current property allows mull as a value\n   */\n  nullable?: boolean;\n  /**\n   * The name to use when serializing\n   */\n  serializedName?: string;\n  /**\n   * Type of the mapper\n   */\n  type: MapperType;\n  /**\n   * Default value when one is not explicitly provided\n   */\n  defaultValue?: any;\n  /**\n   * Constraints to test the current value against\n   */\n  constraints?: MapperConstraints;\n}\n\n/**\n * Mappers are definitions of the data models used in the library.\n * These data models are part of the Operation or Client definitions in the responses or parameters.\n */\nexport type Mapper = BaseMapper | CompositeMapper | SequenceMapper | DictionaryMapper | EnumMapper;\n\n/**\n * Used to disambiguate discriminated type unions.\n * For example, if response can have many shapes but also includes a 'kind' field (or similar),\n * that field can be used to determine how to deserialize the response to the correct type.\n */\nexport interface PolymorphicDiscriminator {\n  /**\n   * Name of the discriminant property in the original JSON payload, e.g. `@odata.kind`.\n   */\n  serializedName: string;\n  /**\n   * Name to use on the resulting object instead of the original property name.\n   * Useful since the JSON property could be difficult to work with.\n   * For example: For a field received as `@odata.kind`, the final object could instead include a property simply named `kind`.\n   */\n  clientName: string;\n  /**\n   * It may contain any other property.\n   */\n  [key: string]: string;\n}\n\n/**\n * A mapper composed of other mappers.\n */\nexport interface CompositeMapper extends BaseMapper {\n  /**\n   * The type descriptor of the `CompositeMapper`.\n   */\n  type: CompositeMapperType;\n}\n\n/**\n * A mapper describing arrays.\n */\nexport interface SequenceMapper extends BaseMapper {\n  /**\n   * The type descriptor of the `SequenceMapper`.\n   */\n  type: SequenceMapperType;\n}\n\n/**\n * A mapper describing plain JavaScript objects used as key/value pairs.\n */\nexport interface DictionaryMapper extends BaseMapper {\n  /**\n   * The type descriptor of the `DictionaryMapper`.\n   */\n  type: DictionaryMapperType;\n  /**\n   * Optionally, a prefix to add to the header collection.\n   */\n  headerCollectionPrefix?: string;\n}\n\n/**\n * A mapper describing an enum value.\n */\nexport interface EnumMapper extends BaseMapper {\n  /**\n   * The type descriptor of the `EnumMapper`.\n   */\n  type: EnumMapperType;\n}\n\n/**\n * An interface representing an URL parameter value.\n */\nexport interface UrlParameterValue {\n  /**\n   * The URL value.\n   */\n  value: string;\n  /**\n   * Whether to keep or skip URL encoding.\n   */\n  skipUrlEncoding: boolean;\n}\n\n/**\n * Utility function that serializes an object that might contain binary information into a plain object, array or a string.\n */\nexport function serializeObject(toSerialize: unknown): any {\n  const castToSerialize = toSerialize as Record<string, unknown>;\n  if (toSerialize == undefined) return undefined;\n  if (toSerialize instanceof Uint8Array) {\n    toSerialize = base64.encodeByteArray(toSerialize);\n    return toSerialize;\n  } else if (toSerialize instanceof Date) {\n    return toSerialize.toISOString();\n  } else if (Array.isArray(toSerialize)) {\n    const array = [];\n    for (let i = 0; i < toSerialize.length; i++) {\n      array.push(serializeObject(toSerialize[i]));\n    }\n    return array;\n  } else if (typeof toSerialize === \"object\") {\n    const dictionary: { [key: string]: any } = {};\n    for (const property in toSerialize) {\n      dictionary[property] = serializeObject(castToSerialize[property]);\n    }\n    return dictionary;\n  }\n  return toSerialize;\n}\n\n/**\n * Utility function to create a K:V from a list of strings\n */\nfunction strEnum<T extends string>(o: Array<T>): { [K in T]: K } {\n  const result: any = {};\n  for (const key of o) {\n    result[key] = key;\n  }\n  return result;\n}\n\n/**\n * String enum containing the string types of property mappers.\n */\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const MapperType = strEnum([\n  \"Base64Url\",\n  \"Boolean\",\n  \"ByteArray\",\n  \"Composite\",\n  \"Date\",\n  \"DateTime\",\n  \"DateTimeRfc1123\",\n  \"Dictionary\",\n  \"Enum\",\n  \"Number\",\n  \"Object\",\n  \"Sequence\",\n  \"String\",\n  \"Stream\",\n  \"TimeSpan\",\n  \"UnixTime\",\n]);\n"]},"metadata":{},"sourceType":"module"}