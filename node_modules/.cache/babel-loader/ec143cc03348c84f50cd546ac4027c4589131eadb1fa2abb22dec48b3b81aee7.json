{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { AbortController } from \"@azure/abort-controller\";\nimport { deserializeState, initOperation, pollOperation } from \"./operation\";\nimport { POLL_INTERVAL_IN_MS } from \"./constants\";\nimport { delayMs } from \"./util/delayMs\";\nconst createStateProxy = () => ({\n  /**\n   * The state at this point is created to be of type OperationState<TResult>.\n   * It will be updated later to be of type TState when the\n   * customer-provided callback, `updateState`, is called during polling.\n   */\n  initState: config => ({\n    status: \"running\",\n    config\n  }),\n  setCanceled: state => state.status = \"canceled\",\n  setError: (state, error) => state.error = error,\n  setResult: (state, result) => state.result = result,\n  setRunning: state => state.status = \"running\",\n  setSucceeded: state => state.status = \"succeeded\",\n  setFailed: state => state.status = \"failed\",\n  getError: state => state.error,\n  getResult: state => state.result,\n  isCanceled: state => state.status === \"canceled\",\n  isFailed: state => state.status === \"failed\",\n  isRunning: state => state.status === \"running\",\n  isSucceeded: state => state.status === \"succeeded\"\n});\n/**\n * Returns a poller factory.\n */\nexport function buildCreatePoller(inputs) {\n  const {\n    getOperationLocation,\n    getStatusFromInitialResponse,\n    getStatusFromPollResponse,\n    isOperationError,\n    getResourceLocation,\n    getPollingInterval,\n    resolveOnUnsuccessful\n  } = inputs;\n  return async (_ref, options) => {\n    let {\n      init,\n      poll\n    } = _ref;\n    const {\n      processResult,\n      updateState,\n      withOperationLocation: withOperationLocationCallback,\n      intervalInMs = POLL_INTERVAL_IN_MS,\n      restoreFrom\n    } = options || {};\n    const stateProxy = createStateProxy();\n    const withOperationLocation = withOperationLocationCallback ? (() => {\n      let called = false;\n      return (operationLocation, isUpdated) => {\n        if (isUpdated) withOperationLocationCallback(operationLocation);else if (!called) withOperationLocationCallback(operationLocation);\n        called = true;\n      };\n    })() : undefined;\n    const state = restoreFrom ? deserializeState(restoreFrom) : await initOperation({\n      init,\n      stateProxy,\n      processResult,\n      getOperationStatus: getStatusFromInitialResponse,\n      withOperationLocation,\n      setErrorAsResult: !resolveOnUnsuccessful\n    });\n    let resultPromise;\n    let cancelJob;\n    const abortController = new AbortController();\n    const handlers = new Map();\n    const handleProgressEvents = async () => handlers.forEach(h => h(state));\n    const cancelErrMsg = \"Operation was canceled\";\n    let currentPollIntervalInMs = intervalInMs;\n    const poller = {\n      getOperationState: () => state,\n      getResult: () => state.result,\n      isDone: () => [\"succeeded\", \"failed\", \"canceled\"].includes(state.status),\n      isStopped: () => resultPromise === undefined,\n      stopPolling: () => {\n        abortController.abort();\n        cancelJob === null || cancelJob === void 0 ? void 0 : cancelJob();\n      },\n      toString: () => JSON.stringify({\n        state\n      }),\n      onProgress: callback => {\n        const s = Symbol();\n        handlers.set(s, callback);\n        return () => handlers.delete(s);\n      },\n      pollUntilDone: pollOptions => resultPromise !== null && resultPromise !== void 0 ? resultPromise : resultPromise = (async () => {\n        const {\n          abortSignal: inputAbortSignal\n        } = pollOptions || {};\n        const {\n          signal: abortSignal\n        } = inputAbortSignal ? new AbortController([inputAbortSignal, abortController.signal]) : abortController;\n        if (!poller.isDone()) {\n          await poller.poll({\n            abortSignal\n          });\n          while (!poller.isDone()) {\n            const delay = delayMs(currentPollIntervalInMs);\n            cancelJob = delay.cancel;\n            await delay;\n            await poller.poll({\n              abortSignal\n            });\n          }\n        }\n        if (resolveOnUnsuccessful) {\n          return poller.getResult();\n        } else {\n          switch (state.status) {\n            case \"succeeded\":\n              return poller.getResult();\n            case \"canceled\":\n              throw new Error(cancelErrMsg);\n            case \"failed\":\n              throw state.error;\n            case \"notStarted\":\n            case \"running\":\n              throw new Error(`Polling completed without succeeding or failing`);\n          }\n        }\n      })().finally(() => {\n        resultPromise = undefined;\n      }),\n      async poll(pollOptions) {\n        if (resolveOnUnsuccessful) {\n          if (poller.isDone()) return;\n        } else {\n          switch (state.status) {\n            case \"succeeded\":\n              return;\n            case \"canceled\":\n              throw new Error(cancelErrMsg);\n            case \"failed\":\n              throw state.error;\n          }\n        }\n        await pollOperation({\n          poll,\n          state,\n          stateProxy,\n          getOperationLocation,\n          isOperationError,\n          withOperationLocation,\n          getPollingInterval,\n          getOperationStatus: getStatusFromPollResponse,\n          getResourceLocation,\n          processResult,\n          updateState,\n          options: pollOptions,\n          setDelay: pollIntervalInMs => {\n            currentPollIntervalInMs = pollIntervalInMs;\n          },\n          setErrorAsResult: !resolveOnUnsuccessful\n        });\n        await handleProgressEvents();\n        if (!resolveOnUnsuccessful) {\n          switch (state.status) {\n            case \"canceled\":\n              throw new Error(cancelErrMsg);\n            case \"failed\":\n              throw state.error;\n          }\n        }\n      }\n    };\n    return poller;\n  };\n}","map":{"version":3,"mappings":"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","names":["AbortController","deserializeState","initOperation","pollOperation","POLL_INTERVAL_IN_MS","delayMs","createStateProxy","initState","config","status","setCanceled","state","setError","error","setResult","result","setRunning","setSucceeded","setFailed","getError","getResult","isCanceled","isFailed","isRunning","isSucceeded","buildCreatePoller","inputs","getOperationLocation","getStatusFromInitialResponse","getStatusFromPollResponse","isOperationError","getResourceLocation","getPollingInterval","resolveOnUnsuccessful","options","init","poll","processResult","updateState","withOperationLocation","withOperationLocationCallback","intervalInMs","restoreFrom","stateProxy","called","operationLocation","isUpdated","undefined","getOperationStatus","setErrorAsResult","resultPromise","cancelJob","abortController","handlers","Map","handleProgressEvents","forEach","h","cancelErrMsg","currentPollIntervalInMs","poller","getOperationState","isDone","includes","isStopped","stopPolling","abort","toString","JSON","stringify","onProgress","callback","s","Symbol","set","delete","pollUntilDone","pollOptions","abortSignal","inputAbortSignal","signal","delay","cancel","Error","finally","setDelay","pollIntervalInMs"],"sources":["/Users/yupenglei/Documents/geo-react/node_modules/@azure/core-lro/src/poller/poller.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortController, AbortSignalLike } from \"@azure/abort-controller\";\nimport {\n  BuildCreatePollerOptions,\n  CreatePollerOptions,\n  Operation,\n  OperationState,\n  RestorableOperationState,\n  SimplePollerLike,\n  StateProxy,\n} from \"./models\";\nimport { deserializeState, initOperation, pollOperation } from \"./operation\";\nimport { POLL_INTERVAL_IN_MS } from \"./constants\";\nimport { delayMs } from \"./util/delayMs\";\n\nconst createStateProxy: <TResult, TState extends OperationState<TResult>>() => StateProxy<\n  TState,\n  TResult\n> = () => ({\n  /**\n   * The state at this point is created to be of type OperationState<TResult>.\n   * It will be updated later to be of type TState when the\n   * customer-provided callback, `updateState`, is called during polling.\n   */\n  initState: (config) => ({ status: \"running\", config } as any),\n  setCanceled: (state) => (state.status = \"canceled\"),\n  setError: (state, error) => (state.error = error),\n  setResult: (state, result) => (state.result = result),\n  setRunning: (state) => (state.status = \"running\"),\n  setSucceeded: (state) => (state.status = \"succeeded\"),\n  setFailed: (state) => (state.status = \"failed\"),\n\n  getError: (state) => state.error,\n  getResult: (state) => state.result,\n  isCanceled: (state) => state.status === \"canceled\",\n  isFailed: (state) => state.status === \"failed\",\n  isRunning: (state) => state.status === \"running\",\n  isSucceeded: (state) => state.status === \"succeeded\",\n});\n\n/**\n * Returns a poller factory.\n */\nexport function buildCreatePoller<TResponse, TResult, TState extends OperationState<TResult>>(\n  inputs: BuildCreatePollerOptions<TResponse, TState>\n): (\n  lro: Operation<TResponse, { abortSignal?: AbortSignalLike }>,\n  options?: CreatePollerOptions<TResponse, TResult, TState>\n) => Promise<SimplePollerLike<TState, TResult>> {\n  const {\n    getOperationLocation,\n    getStatusFromInitialResponse,\n    getStatusFromPollResponse,\n    isOperationError,\n    getResourceLocation,\n    getPollingInterval,\n    resolveOnUnsuccessful,\n  } = inputs;\n  return async (\n    { init, poll }: Operation<TResponse, { abortSignal?: AbortSignalLike }>,\n    options?: CreatePollerOptions<TResponse, TResult, TState>\n  ) => {\n    const {\n      processResult,\n      updateState,\n      withOperationLocation: withOperationLocationCallback,\n      intervalInMs = POLL_INTERVAL_IN_MS,\n      restoreFrom,\n    } = options || {};\n    const stateProxy = createStateProxy<TResult, TState>();\n    const withOperationLocation = withOperationLocationCallback\n      ? (() => {\n          let called = false;\n          return (operationLocation: string, isUpdated: boolean) => {\n            if (isUpdated) withOperationLocationCallback(operationLocation);\n            else if (!called) withOperationLocationCallback(operationLocation);\n            called = true;\n          };\n        })()\n      : undefined;\n    const state: RestorableOperationState<TState> = restoreFrom\n      ? deserializeState(restoreFrom)\n      : await initOperation({\n          init,\n          stateProxy,\n          processResult,\n          getOperationStatus: getStatusFromInitialResponse,\n          withOperationLocation,\n          setErrorAsResult: !resolveOnUnsuccessful,\n        });\n    let resultPromise: Promise<TResult> | undefined;\n    let cancelJob: (() => void) | undefined;\n    const abortController = new AbortController();\n    // Progress handlers\n    type Handler = (state: TState) => void;\n    const handlers = new Map<symbol, Handler>();\n    const handleProgressEvents = async (): Promise<void> => handlers.forEach((h) => h(state));\n    const cancelErrMsg = \"Operation was canceled\";\n    let currentPollIntervalInMs = intervalInMs;\n\n    const poller: SimplePollerLike<TState, TResult> = {\n      getOperationState: () => state,\n      getResult: () => state.result,\n      isDone: () => [\"succeeded\", \"failed\", \"canceled\"].includes(state.status),\n      isStopped: () => resultPromise === undefined,\n      stopPolling: () => {\n        abortController.abort();\n        cancelJob?.();\n      },\n      toString: () =>\n        JSON.stringify({\n          state,\n        }),\n      onProgress: (callback: (state: TState) => void) => {\n        const s = Symbol();\n        handlers.set(s, callback);\n        return () => handlers.delete(s);\n      },\n      pollUntilDone: (pollOptions?: { abortSignal?: AbortSignalLike }) =>\n        (resultPromise ??= (async () => {\n          const { abortSignal: inputAbortSignal } = pollOptions || {};\n          const { signal: abortSignal } = inputAbortSignal\n            ? new AbortController([inputAbortSignal, abortController.signal])\n            : abortController;\n          if (!poller.isDone()) {\n            await poller.poll({ abortSignal });\n            while (!poller.isDone()) {\n              const delay = delayMs(currentPollIntervalInMs);\n              cancelJob = delay.cancel;\n              await delay;\n              await poller.poll({ abortSignal });\n            }\n          }\n          if (resolveOnUnsuccessful) {\n            return poller.getResult() as TResult;\n          } else {\n            switch (state.status) {\n              case \"succeeded\":\n                return poller.getResult() as TResult;\n              case \"canceled\":\n                throw new Error(cancelErrMsg);\n              case \"failed\":\n                throw state.error;\n              case \"notStarted\":\n              case \"running\":\n                throw new Error(`Polling completed without succeeding or failing`);\n            }\n          }\n        })().finally(() => {\n          resultPromise = undefined;\n        })),\n      async poll(pollOptions?: { abortSignal?: AbortSignalLike }): Promise<void> {\n        if (resolveOnUnsuccessful) {\n          if (poller.isDone()) return;\n        } else {\n          switch (state.status) {\n            case \"succeeded\":\n              return;\n            case \"canceled\":\n              throw new Error(cancelErrMsg);\n            case \"failed\":\n              throw state.error;\n          }\n        }\n        await pollOperation({\n          poll,\n          state,\n          stateProxy,\n          getOperationLocation,\n          isOperationError,\n          withOperationLocation,\n          getPollingInterval,\n          getOperationStatus: getStatusFromPollResponse,\n          getResourceLocation,\n          processResult,\n          updateState,\n          options: pollOptions,\n          setDelay: (pollIntervalInMs) => {\n            currentPollIntervalInMs = pollIntervalInMs;\n          },\n          setErrorAsResult: !resolveOnUnsuccessful,\n        });\n        await handleProgressEvents();\n        if (!resolveOnUnsuccessful) {\n          switch (state.status) {\n            case \"canceled\":\n              throw new Error(cancelErrMsg);\n            case \"failed\":\n              throw state.error;\n          }\n        }\n      },\n    };\n    return poller;\n  };\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}