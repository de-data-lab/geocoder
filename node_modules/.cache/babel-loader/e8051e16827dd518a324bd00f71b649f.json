{"ast":null,"code":"import _asyncToGenerator from \"/Users/tbeckett/Documents/Azure dev/Azure Test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { AbortController } from \"@azure/abort-controller\";\nimport { deserializeState, initOperation, pollOperation } from \"./operation\";\nimport { POLL_INTERVAL_IN_MS } from \"./constants\";\nimport { delayMs } from \"./util/delayMs\";\nvar createStateProxy = function createStateProxy() {\n  return {\n    /**\n     * The state at this point is created to be of type OperationState<TResult>.\n     * It will be updated later to be of type TState when the\n     * customer-provided callback, `updateState`, is called during polling.\n     */\n    initState: function initState(config) {\n      return {\n        status: \"running\",\n        config: config\n      };\n    },\n    setCanceled: function setCanceled(state) {\n      return state.status = \"canceled\";\n    },\n    setError: function setError(state, error) {\n      return state.error = error;\n    },\n    setResult: function setResult(state, result) {\n      return state.result = result;\n    },\n    setRunning: function setRunning(state) {\n      return state.status = \"running\";\n    },\n    setSucceeded: function setSucceeded(state) {\n      return state.status = \"succeeded\";\n    },\n    setFailed: function setFailed(state) {\n      return state.status = \"failed\";\n    },\n    getError: function getError(state) {\n      return state.error;\n    },\n    getResult: function getResult(state) {\n      return state.result;\n    },\n    isCanceled: function isCanceled(state) {\n      return state.status === \"canceled\";\n    },\n    isFailed: function isFailed(state) {\n      return state.status === \"failed\";\n    },\n    isRunning: function isRunning(state) {\n      return state.status === \"running\";\n    },\n    isSucceeded: function isSucceeded(state) {\n      return state.status === \"succeeded\";\n    }\n  };\n};\n/**\n * Returns a poller factory.\n */\nexport function buildCreatePoller(inputs) {\n  var getOperationLocation = inputs.getOperationLocation,\n    getStatusFromInitialResponse = inputs.getStatusFromInitialResponse,\n    getStatusFromPollResponse = inputs.getStatusFromPollResponse,\n    getResourceLocation = inputs.getResourceLocation,\n    getPollingInterval = inputs.getPollingInterval,\n    resolveOnUnsuccessful = inputs.resolveOnUnsuccessful;\n  return /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(_ref, options) {\n      var init, _poll, _ref3, processResult, updateState, withOperationLocationCallback, _ref3$intervalInMs, intervalInMs, restoreFrom, stateProxy, withOperationLocation, state, resultPromise, cancelJob, abortController, handlers, handleProgressEvents, currentPollIntervalInMs, poller;\n      return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              init = _ref.init, _poll = _ref.poll;\n              _ref3 = options || {}, processResult = _ref3.processResult, updateState = _ref3.updateState, withOperationLocationCallback = _ref3.withOperationLocation, _ref3$intervalInMs = _ref3.intervalInMs, intervalInMs = _ref3$intervalInMs === void 0 ? POLL_INTERVAL_IN_MS : _ref3$intervalInMs, restoreFrom = _ref3.restoreFrom;\n              stateProxy = createStateProxy();\n              withOperationLocation = withOperationLocationCallback ? function () {\n                var called = false;\n                return function (operationLocation, isUpdated) {\n                  if (isUpdated) withOperationLocationCallback(operationLocation);else if (!called) withOperationLocationCallback(operationLocation);\n                  called = true;\n                };\n              }() : undefined;\n              if (!restoreFrom) {\n                _context4.next = 8;\n                break;\n              }\n              _context4.t0 = deserializeState(restoreFrom);\n              _context4.next = 11;\n              break;\n            case 8:\n              _context4.next = 10;\n              return initOperation({\n                init: init,\n                stateProxy: stateProxy,\n                processResult: processResult,\n                getOperationStatus: getStatusFromInitialResponse,\n                withOperationLocation: withOperationLocation,\n                setErrorAsResult: !resolveOnUnsuccessful\n              });\n            case 10:\n              _context4.t0 = _context4.sent;\n            case 11:\n              state = _context4.t0;\n              abortController = new AbortController();\n              handlers = new Map();\n              handleProgressEvents = /*#__PURE__*/function () {\n                var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n                  return _regeneratorRuntime().wrap(function _callee$(_context) {\n                    while (1) {\n                      switch (_context.prev = _context.next) {\n                        case 0:\n                          return _context.abrupt(\"return\", handlers.forEach(function (h) {\n                            return h(state);\n                          }));\n                        case 1:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }\n                  }, _callee);\n                }));\n                return function handleProgressEvents() {\n                  return _ref4.apply(this, arguments);\n                };\n              }();\n              currentPollIntervalInMs = intervalInMs;\n              poller = {\n                getOperationState: function getOperationState() {\n                  return state;\n                },\n                getResult: function getResult() {\n                  return state.result;\n                },\n                isDone: function isDone() {\n                  return [\"succeeded\", \"failed\", \"canceled\"].includes(state.status);\n                },\n                isStopped: function isStopped() {\n                  return resultPromise === undefined;\n                },\n                stopPolling: function stopPolling() {\n                  abortController.abort();\n                  cancelJob === null || cancelJob === void 0 ? void 0 : cancelJob();\n                },\n                toString: function toString() {\n                  return JSON.stringify({\n                    state: state\n                  });\n                },\n                onProgress: function onProgress(callback) {\n                  var s = Symbol();\n                  handlers.set(s, callback);\n                  return function () {\n                    return handlers.delete(s);\n                  };\n                },\n                pollUntilDone: function pollUntilDone(pollOptions) {\n                  return resultPromise !== null && resultPromise !== void 0 ? resultPromise : resultPromise = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n                    var _ref6, inputAbortSignal, _ref7, abortSignal, delay;\n                    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                      while (1) {\n                        switch (_context2.prev = _context2.next) {\n                          case 0:\n                            _ref6 = pollOptions || {}, inputAbortSignal = _ref6.abortSignal;\n                            _ref7 = inputAbortSignal ? new AbortController([inputAbortSignal, abortController.signal]) : abortController, abortSignal = _ref7.signal;\n                            if (poller.isDone()) {\n                              _context2.next = 14;\n                              break;\n                            }\n                            _context2.next = 5;\n                            return poller.poll({\n                              abortSignal: abortSignal\n                            });\n                          case 5:\n                            if (poller.isDone()) {\n                              _context2.next = 14;\n                              break;\n                            }\n                            delay = delayMs(currentPollIntervalInMs);\n                            cancelJob = delay.cancel;\n                            _context2.next = 10;\n                            return delay;\n                          case 10:\n                            _context2.next = 12;\n                            return poller.poll({\n                              abortSignal: abortSignal\n                            });\n                          case 12:\n                            _context2.next = 5;\n                            break;\n                          case 14:\n                            _context2.t0 = state.status;\n                            _context2.next = _context2.t0 === \"succeeded\" ? 17 : _context2.t0 === \"canceled\" ? 18 : _context2.t0 === \"failed\" ? 21 : _context2.t0 === \"notStarted\" ? 24 : _context2.t0 === \"running\" ? 24 : 25;\n                            break;\n                          case 17:\n                            return _context2.abrupt(\"return\", poller.getResult());\n                          case 18:\n                            if (resolveOnUnsuccessful) {\n                              _context2.next = 20;\n                              break;\n                            }\n                            throw new Error(\"Operation was canceled\");\n                          case 20:\n                            return _context2.abrupt(\"return\", poller.getResult());\n                          case 21:\n                            if (resolveOnUnsuccessful) {\n                              _context2.next = 23;\n                              break;\n                            }\n                            throw state.error;\n                          case 23:\n                            return _context2.abrupt(\"return\", poller.getResult());\n                          case 24:\n                            throw new Error(\"polling completed without succeeding or failing\");\n                          case 25:\n                          case \"end\":\n                            return _context2.stop();\n                        }\n                      }\n                    }, _callee2);\n                  }))().finally(function () {\n                    resultPromise = undefined;\n                  });\n                },\n                poll: function poll(pollOptions) {\n                  return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n                    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                      while (1) {\n                        switch (_context3.prev = _context3.next) {\n                          case 0:\n                            _context3.next = 2;\n                            return pollOperation({\n                              poll: _poll,\n                              state: state,\n                              stateProxy: stateProxy,\n                              getOperationLocation: getOperationLocation,\n                              withOperationLocation: withOperationLocation,\n                              getPollingInterval: getPollingInterval,\n                              getOperationStatus: getStatusFromPollResponse,\n                              getResourceLocation: getResourceLocation,\n                              processResult: processResult,\n                              updateState: updateState,\n                              options: pollOptions,\n                              setDelay: function setDelay(pollIntervalInMs) {\n                                currentPollIntervalInMs = pollIntervalInMs;\n                              },\n                              setErrorAsResult: !resolveOnUnsuccessful\n                            });\n                          case 2:\n                            _context3.next = 4;\n                            return handleProgressEvents();\n                          case 4:\n                            if (!(state.status === \"canceled\" && !resolveOnUnsuccessful)) {\n                              _context3.next = 6;\n                              break;\n                            }\n                            throw new Error(\"Operation was canceled\");\n                          case 6:\n                            if (!(state.status === \"failed\" && !resolveOnUnsuccessful)) {\n                              _context3.next = 8;\n                              break;\n                            }\n                            throw state.error;\n                          case 8:\n                          case \"end\":\n                            return _context3.stop();\n                        }\n                      }\n                    }, _callee3);\n                  }))();\n                }\n              };\n              return _context4.abrupt(\"return\", poller);\n            case 18:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }));\n    return function (_x, _x2) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n}","map":{"version":3,"mappings":"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","names":["AbortController","deserializeState","initOperation","pollOperation","POLL_INTERVAL_IN_MS","delayMs","createStateProxy","initState","config","status","setCanceled","state","setError","error","setResult","result","setRunning","setSucceeded","setFailed","getError","getResult","isCanceled","isFailed","isRunning","isSucceeded","buildCreatePoller","inputs","getOperationLocation","getStatusFromInitialResponse","getStatusFromPollResponse","getResourceLocation","getPollingInterval","resolveOnUnsuccessful","options","init","poll","processResult","updateState","withOperationLocationCallback","withOperationLocation","intervalInMs","restoreFrom","stateProxy","called","operationLocation","isUpdated","undefined","getOperationStatus","setErrorAsResult","abortController","handlers","Map","handleProgressEvents","forEach","h","currentPollIntervalInMs","poller","getOperationState","isDone","includes","isStopped","resultPromise","stopPolling","abort","cancelJob","toString","JSON","stringify","onProgress","callback","s","Symbol","set","delete","pollUntilDone","pollOptions","inputAbortSignal","abortSignal","signal","delay","cancel","Error","finally","setDelay","pollIntervalInMs"],"sourceRoot":"","sources":["../../../src/poller/poller.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortController, AbortSignalLike } from \"@azure/abort-controller\";\nimport {\n  BuildCreatePollerOptions,\n  CreatePollerOptions,\n  Operation,\n  OperationState,\n  RestorableOperationState,\n  SimplePollerLike,\n  StateProxy,\n} from \"./models\";\nimport { deserializeState, initOperation, pollOperation } from \"./operation\";\nimport { POLL_INTERVAL_IN_MS } from \"./constants\";\nimport { delayMs } from \"./util/delayMs\";\n\nconst createStateProxy: <TResult, TState extends OperationState<TResult>>() => StateProxy<\n  TState,\n  TResult\n> = () => ({\n  /**\n   * The state at this point is created to be of type OperationState<TResult>.\n   * It will be updated later to be of type TState when the\n   * customer-provided callback, `updateState`, is called during polling.\n   */\n  initState: (config) => ({ status: \"running\", config } as any),\n  setCanceled: (state) => (state.status = \"canceled\"),\n  setError: (state, error) => (state.error = error),\n  setResult: (state, result) => (state.result = result),\n  setRunning: (state) => (state.status = \"running\"),\n  setSucceeded: (state) => (state.status = \"succeeded\"),\n  setFailed: (state) => (state.status = \"failed\"),\n\n  getError: (state) => state.error,\n  getResult: (state) => state.result,\n  isCanceled: (state) => state.status === \"canceled\",\n  isFailed: (state) => state.status === \"failed\",\n  isRunning: (state) => state.status === \"running\",\n  isSucceeded: (state) => state.status === \"succeeded\",\n});\n\n/**\n * Returns a poller factory.\n */\nexport function buildCreatePoller<TResponse, TResult, TState extends OperationState<TResult>>(\n  inputs: BuildCreatePollerOptions<TResponse, TState>\n): (\n  lro: Operation<TResponse, { abortSignal?: AbortSignalLike }>,\n  options?: CreatePollerOptions<TResponse, TResult, TState>\n) => Promise<SimplePollerLike<TState, TResult>> {\n  const {\n    getOperationLocation,\n    getStatusFromInitialResponse,\n    getStatusFromPollResponse,\n    getResourceLocation,\n    getPollingInterval,\n    resolveOnUnsuccessful,\n  } = inputs;\n  return async (\n    { init, poll }: Operation<TResponse, { abortSignal?: AbortSignalLike }>,\n    options?: CreatePollerOptions<TResponse, TResult, TState>\n  ) => {\n    const {\n      processResult,\n      updateState,\n      withOperationLocation: withOperationLocationCallback,\n      intervalInMs = POLL_INTERVAL_IN_MS,\n      restoreFrom,\n    } = options || {};\n    const stateProxy = createStateProxy<TResult, TState>();\n    const withOperationLocation = withOperationLocationCallback\n      ? (() => {\n          let called = false;\n          return (operationLocation: string, isUpdated: boolean) => {\n            if (isUpdated) withOperationLocationCallback(operationLocation);\n            else if (!called) withOperationLocationCallback(operationLocation);\n            called = true;\n          };\n        })()\n      : undefined;\n    const state: RestorableOperationState<TState> = restoreFrom\n      ? deserializeState(restoreFrom)\n      : await initOperation({\n          init,\n          stateProxy,\n          processResult,\n          getOperationStatus: getStatusFromInitialResponse,\n          withOperationLocation,\n          setErrorAsResult: !resolveOnUnsuccessful,\n        });\n    let resultPromise: Promise<TResult> | undefined;\n    let cancelJob: (() => void) | undefined;\n    const abortController = new AbortController();\n    // Progress handlers\n    type Handler = (state: TState) => void;\n    const handlers = new Map<symbol, Handler>();\n    const handleProgressEvents = async (): Promise<void> => handlers.forEach((h) => h(state));\n\n    let currentPollIntervalInMs = intervalInMs;\n\n    const poller: SimplePollerLike<TState, TResult> = {\n      getOperationState: () => state,\n      getResult: () => state.result,\n      isDone: () => [\"succeeded\", \"failed\", \"canceled\"].includes(state.status),\n      isStopped: () => resultPromise === undefined,\n      stopPolling: () => {\n        abortController.abort();\n        cancelJob?.();\n      },\n      toString: () =>\n        JSON.stringify({\n          state,\n        }),\n      onProgress: (callback: (state: TState) => void) => {\n        const s = Symbol();\n        handlers.set(s, callback);\n        return () => handlers.delete(s);\n      },\n      pollUntilDone: (pollOptions?: { abortSignal?: AbortSignalLike }) =>\n        (resultPromise ??= (async () => {\n          const { abortSignal: inputAbortSignal } = pollOptions || {};\n          const { signal: abortSignal } = inputAbortSignal\n            ? new AbortController([inputAbortSignal, abortController.signal])\n            : abortController;\n          if (!poller.isDone()) {\n            await poller.poll({ abortSignal });\n            while (!poller.isDone()) {\n              const delay = delayMs(currentPollIntervalInMs);\n              cancelJob = delay.cancel;\n              await delay;\n              await poller.poll({ abortSignal });\n            }\n          }\n          switch (state.status) {\n            case \"succeeded\": {\n              return poller.getResult() as TResult;\n            }\n            case \"canceled\": {\n              if (!resolveOnUnsuccessful) throw new Error(\"Operation was canceled\");\n              return poller.getResult() as TResult;\n            }\n            case \"failed\": {\n              if (!resolveOnUnsuccessful) throw state.error;\n              return poller.getResult() as TResult;\n            }\n            case \"notStarted\":\n            case \"running\": {\n              // Unreachable\n              throw new Error(`polling completed without succeeding or failing`);\n            }\n          }\n        })().finally(() => {\n          resultPromise = undefined;\n        })),\n      async poll(pollOptions?: { abortSignal?: AbortSignalLike }): Promise<void> {\n        await pollOperation({\n          poll,\n          state,\n          stateProxy,\n          getOperationLocation,\n          withOperationLocation,\n          getPollingInterval,\n          getOperationStatus: getStatusFromPollResponse,\n          getResourceLocation,\n          processResult,\n          updateState,\n          options: pollOptions,\n          setDelay: (pollIntervalInMs) => {\n            currentPollIntervalInMs = pollIntervalInMs;\n          },\n          setErrorAsResult: !resolveOnUnsuccessful,\n        });\n        await handleProgressEvents();\n        if (state.status === \"canceled\" && !resolveOnUnsuccessful) {\n          throw new Error(\"Operation was canceled\");\n        }\n        if (state.status === \"failed\" && !resolveOnUnsuccessful) {\n          throw state.error;\n        }\n      },\n    };\n    return poller;\n  };\n}\n"]},"metadata":{},"sourceType":"module"}