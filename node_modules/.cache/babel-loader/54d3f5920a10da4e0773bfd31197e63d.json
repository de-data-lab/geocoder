{"ast":null,"code":"import _defineProperty from \"/Users/tbeckett/Documents/Azure dev/Azure Test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _asyncToGenerator from \"/Users/tbeckett/Documents/Azure dev/Azure Test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/tbeckett/Documents/Azure dev/Azure Test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/tbeckett/Documents/Azure dev/Azure Test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/tbeckett/Documents/Azure dev/Azure Test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/tbeckett/Documents/Azure dev/Azure Test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nimport { __asyncDelegator, __asyncGenerator, __asyncValues, __await } from \"tslib\";\nimport { generateUuid, getDefaultProxySettings, isNode, isTokenCredential, URLBuilder } from \"@azure/core-http\";\nimport { SpanStatusCode } from \"@azure/core-tracing\";\nimport { BlobDownloadResponse } from \"./BlobDownloadResponse\";\nimport { BlobQueryResponse } from \"./BlobQueryResponse\";\nimport { AnonymousCredential } from \"./credentials/AnonymousCredential\";\nimport { StorageSharedKeyCredential } from \"./credentials/StorageSharedKeyCredential\";\nimport { AppendBlob, Blob as StorageBlob, BlockBlob, PageBlob } from \"./generated/src/operations\";\nimport { ensureCpkIfSpecified, toAccessTier } from \"./models\";\nimport { rangeResponseFromModel } from \"./PageBlobRangeResponse\";\nimport { newPipeline, isPipelineLike } from \"./Pipeline\";\nimport { BlobBeginCopyFromUrlPoller } from \"./pollers/BlobStartCopyFromUrlPoller\";\nimport { rangeToString } from \"./Range\";\nimport { StorageClient } from \"./StorageClient\";\nimport { Batch } from \"./utils/Batch\";\nimport { BufferScheduler } from \"../../storage-common/src\";\nimport { BlobDoesNotUseCustomerSpecifiedEncryption, BlobUsesCustomerSpecifiedEncryptionMsg, BLOCK_BLOB_MAX_BLOCKS, BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES, BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES, DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES, DEFAULT_BLOCK_BUFFER_SIZE_BYTES, DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS, ETagAny, URLConstants } from \"./utils/constants\";\nimport { createSpan, convertTracingToRequestOptionsBase } from \"./utils/tracing\";\nimport { appendToURLPath, appendToURLQuery, extractConnectionStringParts, ExtractPageRangeInfoItems, generateBlockID, getURLParameter, httpAuthorizationToString, isIpEndpointStyle, parseObjectReplicationRecord, setURLParameter, toBlobTags, toBlobTagsString, toQuerySerialization, toTags } from \"./utils/utils.common\";\nimport { fsCreateReadStream, fsStat, readStreamToLocalFile, streamToBuffer } from \"./utils/utils.node\";\nimport { generateBlobSASQueryParameters } from \"./sas/BlobSASSignatureValues\";\nimport { BlobLeaseClient } from \"./BlobLeaseClient\";\n/**\n * A BlobClient represents a URL to an Azure Storage blob; the blob may be a block blob,\n * append blob, or page blob.\n */\nexport var BlobClient = /*#__PURE__*/function (_StorageClient) {\n  _inherits(BlobClient, _StorageClient);\n  var _super = _createSuper(BlobClient);\n  function BlobClient(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions,\n  // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n  /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n  options) {\n    var _this;\n    _classCallCheck(this, BlobClient);\n    options = options || {};\n    var pipeline;\n    var url;\n    if (isPipelineLike(credentialOrPipelineOrContainerName)) {\n      // (url: string, pipeline: Pipeline)\n      url = urlOrConnectionString;\n      pipeline = credentialOrPipelineOrContainerName;\n    } else if (isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential || isTokenCredential(credentialOrPipelineOrContainerName)) {\n      // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n      url = urlOrConnectionString;\n      options = blobNameOrOptions;\n      pipeline = newPipeline(credentialOrPipelineOrContainerName, options);\n    } else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== \"string\") {\n      // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n      // The second parameter is undefined. Use anonymous credential.\n      url = urlOrConnectionString;\n      pipeline = newPipeline(new AnonymousCredential(), options);\n    } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === \"string\" && blobNameOrOptions && typeof blobNameOrOptions === \"string\") {\n      // (connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions)\n      var containerName = credentialOrPipelineOrContainerName;\n      var blobName = blobNameOrOptions;\n      var extractedCreds = extractConnectionStringParts(urlOrConnectionString);\n      if (extractedCreds.kind === \"AccountConnString\") {\n        if (isNode) {\n          var sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);\n          url = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));\n          if (!options.proxyOptions) {\n            options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);\n          }\n          pipeline = newPipeline(sharedKeyCredential, options);\n        } else {\n          throw new Error(\"Account connection string is only supported in Node.js environment\");\n        }\n      } else if (extractedCreds.kind === \"SASConnString\") {\n        url = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + \"?\" + extractedCreds.accountSas;\n        pipeline = newPipeline(new AnonymousCredential(), options);\n      } else {\n        throw new Error(\"Connection string must be either an Account connection string or a SAS connection string\");\n      }\n    } else {\n      throw new Error(\"Expecting non-empty strings for containerName and blobName parameters\");\n    }\n    _this = _super.call(this, url, pipeline);\n    var _this$getBlobAndConta = _this.getBlobAndContainerNamesFromUrl();\n    _this._name = _this$getBlobAndConta.blobName;\n    _this._containerName = _this$getBlobAndConta.containerName;\n    _this.blobContext = new StorageBlob(_this.storageClientContext);\n    _this._snapshot = getURLParameter(_this.url, URLConstants.Parameters.SNAPSHOT);\n    _this._versionId = getURLParameter(_this.url, URLConstants.Parameters.VERSIONID);\n    return _this;\n  }\n  /**\n   * The name of the blob.\n   */\n  _createClass(BlobClient, [{\n    key: \"name\",\n    get: function get() {\n      return this._name;\n    }\n    /**\n     * The name of the storage container the blob is associated with.\n     */\n  }, {\n    key: \"containerName\",\n    get: function get() {\n      return this._containerName;\n    }\n    /**\n     * Creates a new BlobClient object identical to the source but with the specified snapshot timestamp.\n     * Provide \"\" will remove the snapshot and return a Client to the base blob.\n     *\n     * @param snapshot - The snapshot timestamp.\n     * @returns A new BlobClient object identical to the source but with the specified snapshot timestamp\n     */\n  }, {\n    key: \"withSnapshot\",\n    value: function withSnapshot(snapshot) {\n      return new BlobClient(setURLParameter(this.url, URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? undefined : snapshot), this.pipeline);\n    }\n    /**\n     * Creates a new BlobClient object pointing to a version of this blob.\n     * Provide \"\" will remove the versionId and return a Client to the base blob.\n     *\n     * @param versionId - The versionId.\n     * @returns A new BlobClient object pointing to the version of this blob.\n     */\n  }, {\n    key: \"withVersion\",\n    value: function withVersion(versionId) {\n      return new BlobClient(setURLParameter(this.url, URLConstants.Parameters.VERSIONID, versionId.length === 0 ? undefined : versionId), this.pipeline);\n    }\n    /**\n     * Creates a AppendBlobClient object.\n     *\n     */\n  }, {\n    key: \"getAppendBlobClient\",\n    value: function getAppendBlobClient() {\n      return new AppendBlobClient(this.url, this.pipeline);\n    }\n    /**\n     * Creates a BlockBlobClient object.\n     *\n     */\n  }, {\n    key: \"getBlockBlobClient\",\n    value: function getBlockBlobClient() {\n      return new BlockBlobClient(this.url, this.pipeline);\n    }\n    /**\n     * Creates a PageBlobClient object.\n     *\n     */\n  }, {\n    key: \"getPageBlobClient\",\n    value: function getPageBlobClient() {\n      return new PageBlobClient(this.url, this.pipeline);\n    }\n    /**\n     * Reads or downloads a blob from the system, including its metadata and properties.\n     * You can also call Get Blob to read a snapshot.\n     *\n     * * In Node.js, data returns in a Readable stream readableStreamBody\n     * * In browsers, data returns in a promise blobBody\n     *\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-blob\n     *\n     * @param offset - From which position of the blob to download, greater than or equal to 0\n     * @param count - How much data to be downloaded, greater than 0. Will download to the end when undefined\n     * @param options - Optional options to Blob Download operation.\n     *\n     *\n     * Example usage (Node.js):\n     *\n     * ```js\n     * // Download and convert a blob to a string\n     * const downloadBlockBlobResponse = await blobClient.download();\n     * const downloaded = await streamToBuffer(downloadBlockBlobResponse.readableStreamBody);\n     * console.log(\"Downloaded blob content:\", downloaded.toString());\n     *\n     * async function streamToBuffer(readableStream) {\n     * return new Promise((resolve, reject) => {\n     * const chunks = [];\n     * readableStream.on(\"data\", (data) => {\n     * chunks.push(data instanceof Buffer ? data : Buffer.from(data));\n     * });\n     * readableStream.on(\"end\", () => {\n     * resolve(Buffer.concat(chunks));\n     * });\n     * readableStream.on(\"error\", reject);\n     * });\n     * }\n     * ```\n     *\n     * Example usage (browser):\n     *\n     * ```js\n     * // Download and convert a blob to a string\n     * const downloadBlockBlobResponse = await blobClient.download();\n     * const downloaded = await blobToString(await downloadBlockBlobResponse.blobBody);\n     * console.log(\n     *   \"Downloaded blob content\",\n     *   downloaded\n     * );\n     *\n     * async function blobToString(blob: Blob): Promise<string> {\n     *   const fileReader = new FileReader();\n     *   return new Promise<string>((resolve, reject) => {\n     *     fileReader.onloadend = (ev: any) => {\n     *       resolve(ev.target!.result);\n     *     };\n     *     fileReader.onerror = reject;\n     *     fileReader.readAsText(blob);\n     *   });\n     * }\n     * ```\n     */\n  }, {\n    key: \"download\",\n    value: function () {\n      var _download = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var _this2 = this;\n        var offset,\n          count,\n          options,\n          _a,\n          _createSpan,\n          span,\n          updatedOptions,\n          res,\n          wrappedRes,\n          _args2 = arguments;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                offset = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : 0;\n                count = _args2.length > 1 ? _args2[1] : undefined;\n                options = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : {};\n                options.conditions = options.conditions || {};\n                options.conditions = options.conditions || {};\n                ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n                _createSpan = createSpan(\"BlobClient-download\", options), span = _createSpan.span, updatedOptions = _createSpan.updatedOptions;\n                _context2.prev = 7;\n                _context2.next = 10;\n                return this.blobContext.download(Object.assign({\n                  abortSignal: options.abortSignal,\n                  leaseAccessConditions: options.conditions,\n                  modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n                    ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n                  }),\n                  requestOptions: {\n                    onDownloadProgress: isNode ? undefined : options.onProgress // for Node.js, progress is reported by RetriableReadableStream\n                  },\n                  range: offset === 0 && !count ? undefined : rangeToString({\n                    offset: offset,\n                    count: count\n                  }),\n                  rangeGetContentMD5: options.rangeGetContentMD5,\n                  rangeGetContentCRC64: options.rangeGetContentCrc64,\n                  snapshot: options.snapshot,\n                  cpkInfo: options.customerProvidedKey\n                }, convertTracingToRequestOptionsBase(updatedOptions)));\n              case 10:\n                res = _context2.sent;\n                wrappedRes = Object.assign(Object.assign({}, res), {\n                  _response: res._response,\n                  objectReplicationDestinationPolicyId: res.objectReplicationPolicyId,\n                  objectReplicationSourceProperties: parseObjectReplicationRecord(res.objectReplicationRules)\n                }); // Return browser response immediately\n                if (isNode) {\n                  _context2.next = 14;\n                  break;\n                }\n                return _context2.abrupt(\"return\", wrappedRes);\n              case 14:\n                // We support retrying when download stream unexpected ends in Node.js runtime\n                // Following code shouldn't be bundled into browser build, however some\n                // bundlers may try to bundle following code and \"FileReadResponse.ts\".\n                // In this case, \"FileDownloadResponse.browser.ts\" will be used as a shim of \"FileDownloadResponse.ts\"\n                // The config is in package.json \"browser\" field\n                if (options.maxRetryRequests === undefined || options.maxRetryRequests < 0) {\n                  // TODO: Default value or make it a required parameter?\n                  options.maxRetryRequests = DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS;\n                }\n                if (!(res.contentLength === undefined)) {\n                  _context2.next = 17;\n                  break;\n                }\n                throw new RangeError(\"File download response doesn't contain valid content length header\");\n              case 17:\n                if (res.etag) {\n                  _context2.next = 19;\n                  break;\n                }\n                throw new RangeError(\"File download response doesn't contain valid etag header\");\n              case 19:\n                return _context2.abrupt(\"return\", new BlobDownloadResponse(wrappedRes, /*#__PURE__*/function () {\n                  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(start) {\n                    var _a, updatedDownloadOptions;\n                    return _regeneratorRuntime().wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            updatedDownloadOptions = {\n                              leaseAccessConditions: options.conditions,\n                              modifiedAccessConditions: {\n                                ifMatch: options.conditions.ifMatch || res.etag,\n                                ifModifiedSince: options.conditions.ifModifiedSince,\n                                ifNoneMatch: options.conditions.ifNoneMatch,\n                                ifUnmodifiedSince: options.conditions.ifUnmodifiedSince,\n                                ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n                              },\n                              range: rangeToString({\n                                count: offset + res.contentLength - start,\n                                offset: start\n                              }),\n                              rangeGetContentMD5: options.rangeGetContentMD5,\n                              rangeGetContentCRC64: options.rangeGetContentCrc64,\n                              snapshot: options.snapshot,\n                              cpkInfo: options.customerProvidedKey\n                            }; // Debug purpose only\n                            // console.log(\n                            //   `Read from internal stream, range: ${\n                            //     updatedOptions.range\n                            //   }, options: ${JSON.stringify(updatedOptions)}`\n                            // );\n                            _context.next = 3;\n                            return _this2.blobContext.download(Object.assign({\n                              abortSignal: options.abortSignal\n                            }, updatedDownloadOptions));\n                          case 3:\n                            return _context.abrupt(\"return\", _context.sent.readableStreamBody);\n                          case 4:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee);\n                  }));\n                  return function (_x) {\n                    return _ref.apply(this, arguments);\n                  };\n                }(), offset, res.contentLength, {\n                  maxRetryRequests: options.maxRetryRequests,\n                  onProgress: options.onProgress\n                }));\n              case 22:\n                _context2.prev = 22;\n                _context2.t0 = _context2[\"catch\"](7);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context2.t0.message\n                });\n                throw _context2.t0;\n              case 26:\n                _context2.prev = 26;\n                span.end();\n                return _context2.finish(26);\n              case 29:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[7, 22, 26, 29]]);\n      }));\n      function download() {\n        return _download.apply(this, arguments);\n      }\n      return download;\n    }()\n    /**\n     * Returns true if the Azure blob resource represented by this client exists; false otherwise.\n     *\n     * NOTE: use this function with care since an existing blob might be deleted by other clients or\n     * applications. Vice versa new blobs might be added by other clients or applications after this\n     * function completes.\n     *\n     * @param options - options to Exists operation.\n     */\n  }, {\n    key: \"exists\",\n    value: function () {\n      var _exists = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var options,\n          _createSpan2,\n          span,\n          updatedOptions,\n          _args3 = arguments;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                options = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : {};\n                _createSpan2 = createSpan(\"BlobClient-exists\", options), span = _createSpan2.span, updatedOptions = _createSpan2.updatedOptions;\n                _context3.prev = 2;\n                ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n                _context3.next = 6;\n                return this.getProperties({\n                  abortSignal: options.abortSignal,\n                  customerProvidedKey: options.customerProvidedKey,\n                  conditions: options.conditions,\n                  tracingOptions: updatedOptions.tracingOptions\n                });\n              case 6:\n                return _context3.abrupt(\"return\", true);\n              case 9:\n                _context3.prev = 9;\n                _context3.t0 = _context3[\"catch\"](2);\n                if (!(_context3.t0.statusCode === 404)) {\n                  _context3.next = 15;\n                  break;\n                }\n                return _context3.abrupt(\"return\", false);\n              case 15:\n                if (!(_context3.t0.statusCode === 409 && (_context3.t0.details.errorCode === BlobUsesCustomerSpecifiedEncryptionMsg || _context3.t0.details.errorCode === BlobDoesNotUseCustomerSpecifiedEncryption))) {\n                  _context3.next = 17;\n                  break;\n                }\n                return _context3.abrupt(\"return\", true);\n              case 17:\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context3.t0.message\n                });\n                throw _context3.t0;\n              case 19:\n                _context3.prev = 19;\n                span.end();\n                return _context3.finish(19);\n              case 22:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[2, 9, 19, 22]]);\n      }));\n      function exists() {\n        return _exists.apply(this, arguments);\n      }\n      return exists;\n    }()\n    /**\n     * Returns all user-defined metadata, standard HTTP properties, and system properties\n     * for the blob. It does not return the content of the blob.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-blob-properties\n     *\n     * WARNING: The `metadata` object returned in the response will have its keys in lowercase, even if\n     * they originally contained uppercase characters. This differs from the metadata keys returned by\n     * the methods of {@link ContainerClient} that list blobs using the `includeMetadata` option, which\n     * will retain their original casing.\n     *\n     * @param options - Optional options to Get Properties operation.\n     */\n  }, {\n    key: \"getProperties\",\n    value: function () {\n      var _getProperties = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var options,\n          _a,\n          _createSpan3,\n          span,\n          updatedOptions,\n          res,\n          _args4 = arguments;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                options = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : {};\n                _createSpan3 = createSpan(\"BlobClient-getProperties\", options), span = _createSpan3.span, updatedOptions = _createSpan3.updatedOptions;\n                _context4.prev = 2;\n                options.conditions = options.conditions || {};\n                ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n                _context4.next = 7;\n                return this.blobContext.getProperties(Object.assign({\n                  abortSignal: options.abortSignal,\n                  leaseAccessConditions: options.conditions,\n                  modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n                    ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n                  }),\n                  cpkInfo: options.customerProvidedKey\n                }, convertTracingToRequestOptionsBase(updatedOptions)));\n              case 7:\n                res = _context4.sent;\n                return _context4.abrupt(\"return\", Object.assign(Object.assign({}, res), {\n                  _response: res._response,\n                  objectReplicationDestinationPolicyId: res.objectReplicationPolicyId,\n                  objectReplicationSourceProperties: parseObjectReplicationRecord(res.objectReplicationRules)\n                }));\n              case 11:\n                _context4.prev = 11;\n                _context4.t0 = _context4[\"catch\"](2);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context4.t0.message\n                });\n                throw _context4.t0;\n              case 15:\n                _context4.prev = 15;\n                span.end();\n                return _context4.finish(15);\n              case 18:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[2, 11, 15, 18]]);\n      }));\n      function getProperties() {\n        return _getProperties.apply(this, arguments);\n      }\n      return getProperties;\n    }()\n    /**\n     * Marks the specified blob or snapshot for deletion. The blob is later deleted\n     * during garbage collection. Note that in order to delete a blob, you must delete\n     * all of its snapshots. You can delete both at the same time with the Delete\n     * Blob operation.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-blob\n     *\n     * @param options - Optional options to Blob Delete operation.\n     */\n  }, {\n    key: \"delete\",\n    value: function () {\n      var _delete2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var options,\n          _a,\n          _createSpan4,\n          span,\n          updatedOptions,\n          _args5 = arguments;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                options = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : {};\n                _createSpan4 = createSpan(\"BlobClient-delete\", options), span = _createSpan4.span, updatedOptions = _createSpan4.updatedOptions;\n                options.conditions = options.conditions || {};\n                _context5.prev = 3;\n                _context5.next = 6;\n                return this.blobContext.delete(Object.assign({\n                  abortSignal: options.abortSignal,\n                  deleteSnapshots: options.deleteSnapshots,\n                  leaseAccessConditions: options.conditions,\n                  modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n                    ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n                  })\n                }, convertTracingToRequestOptionsBase(updatedOptions)));\n              case 6:\n                return _context5.abrupt(\"return\", _context5.sent);\n              case 9:\n                _context5.prev = 9;\n                _context5.t0 = _context5[\"catch\"](3);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context5.t0.message\n                });\n                throw _context5.t0;\n              case 13:\n                _context5.prev = 13;\n                span.end();\n                return _context5.finish(13);\n              case 16:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[3, 9, 13, 16]]);\n      }));\n      function _delete() {\n        return _delete2.apply(this, arguments);\n      }\n      return _delete;\n    }()\n    /**\n     * Marks the specified blob or snapshot for deletion if it exists. The blob is later deleted\n     * during garbage collection. Note that in order to delete a blob, you must delete\n     * all of its snapshots. You can delete both at the same time with the Delete\n     * Blob operation.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-blob\n     *\n     * @param options - Optional options to Blob Delete operation.\n     */\n  }, {\n    key: \"deleteIfExists\",\n    value: function () {\n      var _deleteIfExists = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        var options,\n          _a,\n          _b,\n          _createSpan5,\n          span,\n          updatedOptions,\n          res,\n          _args6 = arguments;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                options = _args6.length > 0 && _args6[0] !== undefined ? _args6[0] : {};\n                _createSpan5 = createSpan(\"BlobClient-deleteIfExists\", options), span = _createSpan5.span, updatedOptions = _createSpan5.updatedOptions;\n                _context6.prev = 2;\n                _context6.next = 5;\n                return this.delete(updatedOptions);\n              case 5:\n                res = _context6.sent;\n                return _context6.abrupt(\"return\", Object.assign(Object.assign({\n                  succeeded: true\n                }, res), {\n                  _response: res._response\n                }));\n              case 9:\n                _context6.prev = 9;\n                _context6.t0 = _context6[\"catch\"](2);\n                if (!(((_a = _context6.t0.details) === null || _a === void 0 ? void 0 : _a.errorCode) === \"BlobNotFound\")) {\n                  _context6.next = 14;\n                  break;\n                }\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: \"Expected exception when deleting a blob or snapshot only if it exists.\"\n                });\n                return _context6.abrupt(\"return\", Object.assign(Object.assign({\n                  succeeded: false\n                }, (_b = _context6.t0.response) === null || _b === void 0 ? void 0 : _b.parsedHeaders), {\n                  _response: _context6.t0.response\n                }));\n              case 14:\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context6.t0.message\n                });\n                throw _context6.t0;\n              case 16:\n                _context6.prev = 16;\n                span.end();\n                return _context6.finish(16);\n              case 19:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this, [[2, 9, 16, 19]]);\n      }));\n      function deleteIfExists() {\n        return _deleteIfExists.apply(this, arguments);\n      }\n      return deleteIfExists;\n    }()\n    /**\n     * Restores the contents and metadata of soft deleted blob and any associated\n     * soft deleted snapshots. Undelete Blob is supported only on version 2017-07-29\n     * or later.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/undelete-blob\n     *\n     * @param options - Optional options to Blob Undelete operation.\n     */\n  }, {\n    key: \"undelete\",\n    value: function () {\n      var _undelete = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        var options,\n          _createSpan6,\n          span,\n          updatedOptions,\n          _args7 = arguments;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                options = _args7.length > 0 && _args7[0] !== undefined ? _args7[0] : {};\n                _createSpan6 = createSpan(\"BlobClient-undelete\", options), span = _createSpan6.span, updatedOptions = _createSpan6.updatedOptions;\n                _context7.prev = 2;\n                _context7.next = 5;\n                return this.blobContext.undelete(Object.assign({\n                  abortSignal: options.abortSignal\n                }, convertTracingToRequestOptionsBase(updatedOptions)));\n              case 5:\n                return _context7.abrupt(\"return\", _context7.sent);\n              case 8:\n                _context7.prev = 8;\n                _context7.t0 = _context7[\"catch\"](2);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context7.t0.message\n                });\n                throw _context7.t0;\n              case 12:\n                _context7.prev = 12;\n                span.end();\n                return _context7.finish(12);\n              case 15:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[2, 8, 12, 15]]);\n      }));\n      function undelete() {\n        return _undelete.apply(this, arguments);\n      }\n      return undelete;\n    }()\n    /**\n     * Sets system properties on the blob.\n     *\n     * If no value provided, or no value provided for the specified blob HTTP headers,\n     * these blob HTTP headers without a value will be cleared.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-properties\n     *\n     * @param blobHTTPHeaders - If no value provided, or no value provided for\n     *                                                   the specified blob HTTP headers, these blob HTTP\n     *                                                   headers without a value will be cleared.\n     *                                                   A common header to set is `blobContentType`\n     *                                                   enabling the browser to provide functionality\n     *                                                   based on file type.\n     * @param options - Optional options to Blob Set HTTP Headers operation.\n     */\n  }, {\n    key: \"setHTTPHeaders\",\n    value: function () {\n      var _setHTTPHeaders = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(blobHTTPHeaders) {\n        var options,\n          _a,\n          _createSpan7,\n          span,\n          updatedOptions,\n          _args8 = arguments;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                options = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : {};\n                _createSpan7 = createSpan(\"BlobClient-setHTTPHeaders\", options), span = _createSpan7.span, updatedOptions = _createSpan7.updatedOptions;\n                options.conditions = options.conditions || {};\n                _context8.prev = 3;\n                ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n                _context8.next = 7;\n                return this.blobContext.setHttpHeaders(Object.assign({\n                  abortSignal: options.abortSignal,\n                  blobHttpHeaders: blobHTTPHeaders,\n                  leaseAccessConditions: options.conditions,\n                  modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n                    ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n                  })\n                }, convertTracingToRequestOptionsBase(updatedOptions)));\n              case 7:\n                return _context8.abrupt(\"return\", _context8.sent);\n              case 10:\n                _context8.prev = 10;\n                _context8.t0 = _context8[\"catch\"](3);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context8.t0.message\n                });\n                throw _context8.t0;\n              case 14:\n                _context8.prev = 14;\n                span.end();\n                return _context8.finish(14);\n              case 17:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this, [[3, 10, 14, 17]]);\n      }));\n      function setHTTPHeaders(_x2) {\n        return _setHTTPHeaders.apply(this, arguments);\n      }\n      return setHTTPHeaders;\n    }()\n    /**\n     * Sets user-defined metadata for the specified blob as one or more name-value pairs.\n     *\n     * If no option provided, or no metadata defined in the parameter, the blob\n     * metadata will be removed.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-metadata\n     *\n     * @param metadata - Replace existing metadata with this value.\n     *                               If no value provided the existing metadata will be removed.\n     * @param options - Optional options to Set Metadata operation.\n     */\n  }, {\n    key: \"setMetadata\",\n    value: function () {\n      var _setMetadata = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(metadata) {\n        var options,\n          _a,\n          _createSpan8,\n          span,\n          updatedOptions,\n          _args9 = arguments;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                options = _args9.length > 1 && _args9[1] !== undefined ? _args9[1] : {};\n                _createSpan8 = createSpan(\"BlobClient-setMetadata\", options), span = _createSpan8.span, updatedOptions = _createSpan8.updatedOptions;\n                options.conditions = options.conditions || {};\n                _context9.prev = 3;\n                ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n                _context9.next = 7;\n                return this.blobContext.setMetadata(Object.assign({\n                  abortSignal: options.abortSignal,\n                  leaseAccessConditions: options.conditions,\n                  metadata: metadata,\n                  modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n                    ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n                  }),\n                  cpkInfo: options.customerProvidedKey,\n                  encryptionScope: options.encryptionScope\n                }, convertTracingToRequestOptionsBase(updatedOptions)));\n              case 7:\n                return _context9.abrupt(\"return\", _context9.sent);\n              case 10:\n                _context9.prev = 10;\n                _context9.t0 = _context9[\"catch\"](3);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context9.t0.message\n                });\n                throw _context9.t0;\n              case 14:\n                _context9.prev = 14;\n                span.end();\n                return _context9.finish(14);\n              case 17:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this, [[3, 10, 14, 17]]);\n      }));\n      function setMetadata(_x3) {\n        return _setMetadata.apply(this, arguments);\n      }\n      return setMetadata;\n    }()\n    /**\n     * Sets tags on the underlying blob.\n     * A blob can have up to 10 tags. Tag keys must be between 1 and 128 characters.  Tag values must be between 0 and 256 characters.\n     * Valid tag key and value characters include lower and upper case letters, digits (0-9),\n     * space (' '), plus ('+'), minus ('-'), period ('.'), foward slash ('/'), colon (':'), equals ('='), and underscore ('_').\n     *\n     * @param tags -\n     * @param options -\n     */\n  }, {\n    key: \"setTags\",\n    value: function () {\n      var _setTags = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(tags) {\n        var options,\n          _a,\n          _createSpan9,\n          span,\n          updatedOptions,\n          _args10 = arguments;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                options = _args10.length > 1 && _args10[1] !== undefined ? _args10[1] : {};\n                _createSpan9 = createSpan(\"BlobClient-setTags\", options), span = _createSpan9.span, updatedOptions = _createSpan9.updatedOptions;\n                _context10.prev = 2;\n                _context10.next = 5;\n                return this.blobContext.setTags(Object.assign(Object.assign({\n                  abortSignal: options.abortSignal,\n                  leaseAccessConditions: options.conditions,\n                  modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n                    ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n                  })\n                }, convertTracingToRequestOptionsBase(updatedOptions)), {\n                  tags: toBlobTags(tags)\n                }));\n              case 5:\n                return _context10.abrupt(\"return\", _context10.sent);\n              case 8:\n                _context10.prev = 8;\n                _context10.t0 = _context10[\"catch\"](2);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context10.t0.message\n                });\n                throw _context10.t0;\n              case 12:\n                _context10.prev = 12;\n                span.end();\n                return _context10.finish(12);\n              case 15:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this, [[2, 8, 12, 15]]);\n      }));\n      function setTags(_x4) {\n        return _setTags.apply(this, arguments);\n      }\n      return setTags;\n    }()\n    /**\n     * Gets the tags associated with the underlying blob.\n     *\n     * @param options -\n     */\n  }, {\n    key: \"getTags\",\n    value: function () {\n      var _getTags = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n        var options,\n          _a,\n          _createSpan10,\n          span,\n          updatedOptions,\n          response,\n          wrappedResponse,\n          _args11 = arguments;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                options = _args11.length > 0 && _args11[0] !== undefined ? _args11[0] : {};\n                _createSpan10 = createSpan(\"BlobClient-getTags\", options), span = _createSpan10.span, updatedOptions = _createSpan10.updatedOptions;\n                _context11.prev = 2;\n                _context11.next = 5;\n                return this.blobContext.getTags(Object.assign({\n                  abortSignal: options.abortSignal,\n                  leaseAccessConditions: options.conditions,\n                  modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n                    ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n                  })\n                }, convertTracingToRequestOptionsBase(updatedOptions)));\n              case 5:\n                response = _context11.sent;\n                wrappedResponse = Object.assign(Object.assign({}, response), {\n                  _response: response._response,\n                  tags: toTags({\n                    blobTagSet: response.blobTagSet\n                  }) || {}\n                });\n                return _context11.abrupt(\"return\", wrappedResponse);\n              case 10:\n                _context11.prev = 10;\n                _context11.t0 = _context11[\"catch\"](2);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context11.t0.message\n                });\n                throw _context11.t0;\n              case 14:\n                _context11.prev = 14;\n                span.end();\n                return _context11.finish(14);\n              case 17:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this, [[2, 10, 14, 17]]);\n      }));\n      function getTags() {\n        return _getTags.apply(this, arguments);\n      }\n      return getTags;\n    }()\n    /**\n     * Get a {@link BlobLeaseClient} that manages leases on the blob.\n     *\n     * @param proposeLeaseId - Initial proposed lease Id.\n     * @returns A new BlobLeaseClient object for managing leases on the blob.\n     */\n  }, {\n    key: \"getBlobLeaseClient\",\n    value: function getBlobLeaseClient(proposeLeaseId) {\n      return new BlobLeaseClient(this, proposeLeaseId);\n    }\n    /**\n     * Creates a read-only snapshot of a blob.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/snapshot-blob\n     *\n     * @param options - Optional options to the Blob Create Snapshot operation.\n     */\n  }, {\n    key: \"createSnapshot\",\n    value: function () {\n      var _createSnapshot = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {\n        var options,\n          _a,\n          _createSpan11,\n          span,\n          updatedOptions,\n          _args12 = arguments;\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                options = _args12.length > 0 && _args12[0] !== undefined ? _args12[0] : {};\n                _createSpan11 = createSpan(\"BlobClient-createSnapshot\", options), span = _createSpan11.span, updatedOptions = _createSpan11.updatedOptions;\n                options.conditions = options.conditions || {};\n                _context12.prev = 3;\n                ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n                _context12.next = 7;\n                return this.blobContext.createSnapshot(Object.assign({\n                  abortSignal: options.abortSignal,\n                  leaseAccessConditions: options.conditions,\n                  metadata: options.metadata,\n                  modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n                    ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n                  }),\n                  cpkInfo: options.customerProvidedKey,\n                  encryptionScope: options.encryptionScope\n                }, convertTracingToRequestOptionsBase(updatedOptions)));\n              case 7:\n                return _context12.abrupt(\"return\", _context12.sent);\n              case 10:\n                _context12.prev = 10;\n                _context12.t0 = _context12[\"catch\"](3);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context12.t0.message\n                });\n                throw _context12.t0;\n              case 14:\n                _context12.prev = 14;\n                span.end();\n                return _context12.finish(14);\n              case 17:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this, [[3, 10, 14, 17]]);\n      }));\n      function createSnapshot() {\n        return _createSnapshot.apply(this, arguments);\n      }\n      return createSnapshot;\n    }()\n    /**\n     * Asynchronously copies a blob to a destination within the storage account.\n     * This method returns a long running operation poller that allows you to wait\n     * indefinitely until the copy is completed.\n     * You can also cancel a copy before it is completed by calling `cancelOperation` on the poller.\n     * Note that the onProgress callback will not be invoked if the operation completes in the first\n     * request, and attempting to cancel a completed copy will result in an error being thrown.\n     *\n     * In version 2012-02-12 and later, the source for a Copy Blob operation can be\n     * a committed blob in any Azure storage account.\n     * Beginning with version 2015-02-21, the source for a Copy Blob operation can be\n     * an Azure file in any Azure storage account.\n     * Only storage accounts created on or after June 7th, 2012 allow the Copy Blob\n     * operation to copy from another storage account.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/copy-blob\n     *\n     * Example using automatic polling:\n     *\n     * ```js\n     * const copyPoller = await blobClient.beginCopyFromURL('url');\n     * const result = await copyPoller.pollUntilDone();\n     * ```\n     *\n     * Example using manual polling:\n     *\n     * ```js\n     * const copyPoller = await blobClient.beginCopyFromURL('url');\n     * while (!poller.isDone()) {\n     *    await poller.poll();\n     * }\n     * const result = copyPoller.getResult();\n     * ```\n     *\n     * Example using progress updates:\n     *\n     * ```js\n     * const copyPoller = await blobClient.beginCopyFromURL('url', {\n     *   onProgress(state) {\n     *     console.log(`Progress: ${state.copyProgress}`);\n     *   }\n     * });\n     * const result = await copyPoller.pollUntilDone();\n     * ```\n     *\n     * Example using a changing polling interval (default 15 seconds):\n     *\n     * ```js\n     * const copyPoller = await blobClient.beginCopyFromURL('url', {\n     *   intervalInMs: 1000 // poll blob every 1 second for copy progress\n     * });\n     * const result = await copyPoller.pollUntilDone();\n     * ```\n     *\n     * Example using copy cancellation:\n     *\n     * ```js\n     * const copyPoller = await blobClient.beginCopyFromURL('url');\n     * // cancel operation after starting it.\n     * try {\n     *   await copyPoller.cancelOperation();\n     *   // calls to get the result now throw PollerCancelledError\n     *   await copyPoller.getResult();\n     * } catch (err) {\n     *   if (err.name === 'PollerCancelledError') {\n     *     console.log('The copy was cancelled.');\n     *   }\n     * }\n     * ```\n     *\n     * @param copySource - url to the source Azure Blob/File.\n     * @param options - Optional options to the Blob Start Copy From URL operation.\n     */\n  }, {\n    key: \"beginCopyFromURL\",\n    value: function () {\n      var _beginCopyFromURL = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(copySource) {\n        var _this3 = this;\n        var options,\n          client,\n          poller,\n          _args13 = arguments;\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                options = _args13.length > 1 && _args13[1] !== undefined ? _args13[1] : {};\n                client = {\n                  abortCopyFromURL: function abortCopyFromURL() {\n                    return _this3.abortCopyFromURL.apply(_this3, arguments);\n                  },\n                  getProperties: function getProperties() {\n                    return _this3.getProperties.apply(_this3, arguments);\n                  },\n                  startCopyFromURL: function startCopyFromURL() {\n                    return _this3.startCopyFromURL.apply(_this3, arguments);\n                  }\n                };\n                poller = new BlobBeginCopyFromUrlPoller({\n                  blobClient: client,\n                  copySource: copySource,\n                  intervalInMs: options.intervalInMs,\n                  onProgress: options.onProgress,\n                  resumeFrom: options.resumeFrom,\n                  startCopyFromURLOptions: options\n                }); // Trigger the startCopyFromURL call by calling poll.\n                // Any errors from this method should be surfaced to the user.\n                _context13.next = 5;\n                return poller.poll();\n              case 5:\n                return _context13.abrupt(\"return\", poller);\n              case 6:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13);\n      }));\n      function beginCopyFromURL(_x5) {\n        return _beginCopyFromURL.apply(this, arguments);\n      }\n      return beginCopyFromURL;\n    }()\n    /**\n     * Aborts a pending asynchronous Copy Blob operation, and leaves a destination blob with zero\n     * length and full metadata. Version 2012-02-12 and newer.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/abort-copy-blob\n     *\n     * @param copyId - Id of the Copy From URL operation.\n     * @param options - Optional options to the Blob Abort Copy From URL operation.\n     */\n  }, {\n    key: \"abortCopyFromURL\",\n    value: function () {\n      var _abortCopyFromURL = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(copyId) {\n        var options,\n          _createSpan12,\n          span,\n          updatedOptions,\n          _args14 = arguments;\n        return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                options = _args14.length > 1 && _args14[1] !== undefined ? _args14[1] : {};\n                _createSpan12 = createSpan(\"BlobClient-abortCopyFromURL\", options), span = _createSpan12.span, updatedOptions = _createSpan12.updatedOptions;\n                _context14.prev = 2;\n                _context14.next = 5;\n                return this.blobContext.abortCopyFromURL(copyId, Object.assign({\n                  abortSignal: options.abortSignal,\n                  leaseAccessConditions: options.conditions\n                }, convertTracingToRequestOptionsBase(updatedOptions)));\n              case 5:\n                return _context14.abrupt(\"return\", _context14.sent);\n              case 8:\n                _context14.prev = 8;\n                _context14.t0 = _context14[\"catch\"](2);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context14.t0.message\n                });\n                throw _context14.t0;\n              case 12:\n                _context14.prev = 12;\n                span.end();\n                return _context14.finish(12);\n              case 15:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this, [[2, 8, 12, 15]]);\n      }));\n      function abortCopyFromURL(_x6) {\n        return _abortCopyFromURL.apply(this, arguments);\n      }\n      return abortCopyFromURL;\n    }()\n    /**\n     * The synchronous Copy From URL operation copies a blob or an internet resource to a new blob. It will not\n     * return a response until the copy is complete.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/copy-blob-from-url\n     *\n     * @param copySource - The source URL to copy from, Shared Access Signature(SAS) maybe needed for authentication\n     * @param options -\n     */\n  }, {\n    key: \"syncCopyFromURL\",\n    value: function () {\n      var _syncCopyFromURL = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(copySource) {\n        var options,\n          _a,\n          _b,\n          _c,\n          _createSpan13,\n          span,\n          updatedOptions,\n          _args15 = arguments;\n        return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                options = _args15.length > 1 && _args15[1] !== undefined ? _args15[1] : {};\n                _createSpan13 = createSpan(\"BlobClient-syncCopyFromURL\", options), span = _createSpan13.span, updatedOptions = _createSpan13.updatedOptions;\n                options.conditions = options.conditions || {};\n                options.sourceConditions = options.sourceConditions || {};\n                _context15.prev = 4;\n                _context15.next = 7;\n                return this.blobContext.copyFromURL(copySource, Object.assign({\n                  abortSignal: options.abortSignal,\n                  metadata: options.metadata,\n                  leaseAccessConditions: options.conditions,\n                  modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n                    ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n                  }),\n                  sourceModifiedAccessConditions: {\n                    sourceIfMatch: options.sourceConditions.ifMatch,\n                    sourceIfModifiedSince: options.sourceConditions.ifModifiedSince,\n                    sourceIfNoneMatch: options.sourceConditions.ifNoneMatch,\n                    sourceIfUnmodifiedSince: options.sourceConditions.ifUnmodifiedSince\n                  },\n                  sourceContentMD5: options.sourceContentMD5,\n                  copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization),\n                  blobTagsString: toBlobTagsString(options.tags),\n                  immutabilityPolicyExpiry: (_b = options.immutabilityPolicy) === null || _b === void 0 ? void 0 : _b.expiriesOn,\n                  immutabilityPolicyMode: (_c = options.immutabilityPolicy) === null || _c === void 0 ? void 0 : _c.policyMode,\n                  legalHold: options.legalHold,\n                  encryptionScope: options.encryptionScope,\n                  copySourceTags: options.copySourceTags\n                }, convertTracingToRequestOptionsBase(updatedOptions)));\n              case 7:\n                return _context15.abrupt(\"return\", _context15.sent);\n              case 10:\n                _context15.prev = 10;\n                _context15.t0 = _context15[\"catch\"](4);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context15.t0.message\n                });\n                throw _context15.t0;\n              case 14:\n                _context15.prev = 14;\n                span.end();\n                return _context15.finish(14);\n              case 17:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this, [[4, 10, 14, 17]]);\n      }));\n      function syncCopyFromURL(_x7) {\n        return _syncCopyFromURL.apply(this, arguments);\n      }\n      return syncCopyFromURL;\n    }()\n    /**\n     * Sets the tier on a blob. The operation is allowed on a page blob in a premium\n     * storage account and on a block blob in a blob storage account (locally redundant\n     * storage only). A premium page blob's tier determines the allowed size, IOPS,\n     * and bandwidth of the blob. A block blob's tier determines Hot/Cool/Archive\n     * storage type. This operation does not update the blob's ETag.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-tier\n     *\n     * @param tier - The tier to be set on the blob. Valid values are Hot, Cool, or Archive.\n     * @param options - Optional options to the Blob Set Tier operation.\n     */\n  }, {\n    key: \"setAccessTier\",\n    value: function () {\n      var _setAccessTier = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(tier) {\n        var options,\n          _a,\n          _createSpan14,\n          span,\n          updatedOptions,\n          _args16 = arguments;\n        return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                options = _args16.length > 1 && _args16[1] !== undefined ? _args16[1] : {};\n                _createSpan14 = createSpan(\"BlobClient-setAccessTier\", options), span = _createSpan14.span, updatedOptions = _createSpan14.updatedOptions;\n                _context16.prev = 2;\n                _context16.next = 5;\n                return this.blobContext.setTier(toAccessTier(tier), Object.assign({\n                  abortSignal: options.abortSignal,\n                  leaseAccessConditions: options.conditions,\n                  modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n                    ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n                  }),\n                  rehydratePriority: options.rehydratePriority\n                }, convertTracingToRequestOptionsBase(updatedOptions)));\n              case 5:\n                return _context16.abrupt(\"return\", _context16.sent);\n              case 8:\n                _context16.prev = 8;\n                _context16.t0 = _context16[\"catch\"](2);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context16.t0.message\n                });\n                throw _context16.t0;\n              case 12:\n                _context16.prev = 12;\n                span.end();\n                return _context16.finish(12);\n              case 15:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this, [[2, 8, 12, 15]]);\n      }));\n      function setAccessTier(_x8) {\n        return _setAccessTier.apply(this, arguments);\n      }\n      return setAccessTier;\n    }()\n  }, {\n    key: \"downloadToBuffer\",\n    value: function () {\n      var _downloadToBuffer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(param1, param2, param3) {\n        var _this4 = this;\n        var param4,\n          buffer,\n          offset,\n          count,\n          options,\n          _createSpan15,\n          span,\n          updatedOptions,\n          _ret,\n          _args19 = arguments;\n        return _regeneratorRuntime().wrap(function _callee19$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                param4 = _args19.length > 3 && _args19[3] !== undefined ? _args19[3] : {};\n                offset = 0;\n                count = 0;\n                options = param4;\n                if (param1 instanceof Buffer) {\n                  buffer = param1;\n                  offset = param2 || 0;\n                  count = typeof param3 === \"number\" ? param3 : 0;\n                } else {\n                  offset = typeof param1 === \"number\" ? param1 : 0;\n                  count = typeof param2 === \"number\" ? param2 : 0;\n                  options = param3 || {};\n                }\n                _createSpan15 = createSpan(\"BlobClient-downloadToBuffer\", options), span = _createSpan15.span, updatedOptions = _createSpan15.updatedOptions;\n                _context19.prev = 6;\n                return _context19.delegateYield( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18() {\n                  var response, transferProgress, batch, _loop, off;\n                  return _regeneratorRuntime().wrap(function _callee18$(_context18) {\n                    while (1) {\n                      switch (_context18.prev = _context18.next) {\n                        case 0:\n                          if (!options.blockSize) {\n                            options.blockSize = 0;\n                          }\n                          if (!(options.blockSize < 0)) {\n                            _context18.next = 3;\n                            break;\n                          }\n                          throw new RangeError(\"blockSize option must be >= 0\");\n                        case 3:\n                          if (options.blockSize === 0) {\n                            options.blockSize = DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES;\n                          }\n                          if (!(offset < 0)) {\n                            _context18.next = 6;\n                            break;\n                          }\n                          throw new RangeError(\"offset option must be >= 0\");\n                        case 6:\n                          if (!(count && count <= 0)) {\n                            _context18.next = 8;\n                            break;\n                          }\n                          throw new RangeError(\"count option must be greater than 0\");\n                        case 8:\n                          if (!options.conditions) {\n                            options.conditions = {};\n                          }\n                          // Customer doesn't specify length, get it\n                          if (count) {\n                            _context18.next = 16;\n                            break;\n                          }\n                          _context18.next = 12;\n                          return _this4.getProperties(Object.assign(Object.assign({}, options), {\n                            tracingOptions: Object.assign(Object.assign({}, options.tracingOptions), convertTracingToRequestOptionsBase(updatedOptions))\n                          }));\n                        case 12:\n                          response = _context18.sent;\n                          count = response.contentLength - offset;\n                          if (!(count < 0)) {\n                            _context18.next = 16;\n                            break;\n                          }\n                          throw new RangeError(\"offset \".concat(offset, \" shouldn't be larger than blob size \").concat(response.contentLength));\n                        case 16:\n                          if (buffer) {\n                            _context18.next = 24;\n                            break;\n                          }\n                          _context18.prev = 17;\n                          buffer = Buffer.alloc(count);\n                          _context18.next = 24;\n                          break;\n                        case 21:\n                          _context18.prev = 21;\n                          _context18.t0 = _context18[\"catch\"](17);\n                          throw new Error(\"Unable to allocate the buffer of size: \".concat(count, \"(in bytes). Please try passing your own buffer to the \\\"downloadToBuffer\\\" method or try using other methods like \\\"download\\\" or \\\"downloadToFile\\\".\\t \").concat(_context18.t0.message));\n                        case 24:\n                          if (!(buffer.length < count)) {\n                            _context18.next = 26;\n                            break;\n                          }\n                          throw new RangeError(\"The buffer's size should be equal to or larger than the request count of bytes: \".concat(count));\n                        case 26:\n                          transferProgress = 0;\n                          batch = new Batch(options.concurrency);\n                          _loop = function _loop(off) {\n                            batch.addOperation( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17() {\n                              var chunkEnd, response, stream;\n                              return _regeneratorRuntime().wrap(function _callee17$(_context17) {\n                                while (1) {\n                                  switch (_context17.prev = _context17.next) {\n                                    case 0:\n                                      // Exclusive chunk end position\n                                      chunkEnd = offset + count;\n                                      if (off + options.blockSize < chunkEnd) {\n                                        chunkEnd = off + options.blockSize;\n                                      }\n                                      _context17.next = 4;\n                                      return _this4.download(off, chunkEnd - off, {\n                                        abortSignal: options.abortSignal,\n                                        conditions: options.conditions,\n                                        maxRetryRequests: options.maxRetryRequestsPerBlock,\n                                        customerProvidedKey: options.customerProvidedKey,\n                                        tracingOptions: Object.assign(Object.assign({}, options.tracingOptions), convertTracingToRequestOptionsBase(updatedOptions))\n                                      });\n                                    case 4:\n                                      response = _context17.sent;\n                                      stream = response.readableStreamBody;\n                                      _context17.next = 8;\n                                      return streamToBuffer(stream, buffer, off - offset, chunkEnd - offset);\n                                    case 8:\n                                      // Update progress after block is downloaded, in case of block trying\n                                      // Could provide finer grained progress updating inside HTTP requests,\n                                      // only if convenience layer download try is enabled\n                                      transferProgress += chunkEnd - off;\n                                      if (options.onProgress) {\n                                        options.onProgress({\n                                          loadedBytes: transferProgress\n                                        });\n                                      }\n                                    case 10:\n                                    case \"end\":\n                                      return _context17.stop();\n                                  }\n                                }\n                              }, _callee17);\n                            })));\n                          };\n                          for (off = offset; off < offset + count; off = off + options.blockSize) {\n                            _loop(off);\n                          }\n                          _context18.next = 32;\n                          return batch.do();\n                        case 32:\n                          return _context18.abrupt(\"return\", {\n                            v: buffer\n                          });\n                        case 33:\n                        case \"end\":\n                          return _context18.stop();\n                      }\n                    }\n                  }, _callee18, null, [[17, 21]]);\n                })(), \"t0\", 8);\n              case 8:\n                _ret = _context19.t0;\n                if (!(typeof _ret === \"object\")) {\n                  _context19.next = 11;\n                  break;\n                }\n                return _context19.abrupt(\"return\", _ret.v);\n              case 11:\n                _context19.next = 17;\n                break;\n              case 13:\n                _context19.prev = 13;\n                _context19.t1 = _context19[\"catch\"](6);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context19.t1.message\n                });\n                throw _context19.t1;\n              case 17:\n                _context19.prev = 17;\n                span.end();\n                return _context19.finish(17);\n              case 20:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n        }, _callee19, null, [[6, 13, 17, 20]]);\n      }));\n      function downloadToBuffer(_x9, _x10, _x11) {\n        return _downloadToBuffer.apply(this, arguments);\n      }\n      return downloadToBuffer;\n    }()\n    /**\n     * ONLY AVAILABLE IN NODE.JS RUNTIME.\n     *\n     * Downloads an Azure Blob to a local file.\n     * Fails if the the given file path already exits.\n     * Offset and count are optional, pass 0 and undefined respectively to download the entire blob.\n     *\n     * @param filePath -\n     * @param offset - From which position of the block blob to download.\n     * @param count - How much data to be downloaded. Will download to the end when passing undefined.\n     * @param options - Options to Blob download options.\n     * @returns The response data for blob download operation,\n     *                                                 but with readableStreamBody set to undefined since its\n     *                                                 content is already read and written into a local file\n     *                                                 at the specified path.\n     */\n  }, {\n    key: \"downloadToFile\",\n    value: function () {\n      var _downloadToFile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20(filePath) {\n        var offset,\n          count,\n          options,\n          _createSpan16,\n          span,\n          updatedOptions,\n          response,\n          _args20 = arguments;\n        return _regeneratorRuntime().wrap(function _callee20$(_context20) {\n          while (1) {\n            switch (_context20.prev = _context20.next) {\n              case 0:\n                offset = _args20.length > 1 && _args20[1] !== undefined ? _args20[1] : 0;\n                count = _args20.length > 2 ? _args20[2] : undefined;\n                options = _args20.length > 3 && _args20[3] !== undefined ? _args20[3] : {};\n                _createSpan16 = createSpan(\"BlobClient-downloadToFile\", options), span = _createSpan16.span, updatedOptions = _createSpan16.updatedOptions;\n                _context20.prev = 4;\n                _context20.next = 7;\n                return this.download(offset, count, Object.assign(Object.assign({}, options), {\n                  tracingOptions: Object.assign(Object.assign({}, options.tracingOptions), convertTracingToRequestOptionsBase(updatedOptions))\n                }));\n              case 7:\n                response = _context20.sent;\n                if (!response.readableStreamBody) {\n                  _context20.next = 11;\n                  break;\n                }\n                _context20.next = 11;\n                return readStreamToLocalFile(response.readableStreamBody, filePath);\n              case 11:\n                // The stream is no longer accessible so setting it to undefined.\n                response.blobDownloadStream = undefined;\n                return _context20.abrupt(\"return\", response);\n              case 15:\n                _context20.prev = 15;\n                _context20.t0 = _context20[\"catch\"](4);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context20.t0.message\n                });\n                throw _context20.t0;\n              case 19:\n                _context20.prev = 19;\n                span.end();\n                return _context20.finish(19);\n              case 22:\n              case \"end\":\n                return _context20.stop();\n            }\n          }\n        }, _callee20, this, [[4, 15, 19, 22]]);\n      }));\n      function downloadToFile(_x12) {\n        return _downloadToFile.apply(this, arguments);\n      }\n      return downloadToFile;\n    }()\n  }, {\n    key: \"getBlobAndContainerNamesFromUrl\",\n    value: function getBlobAndContainerNamesFromUrl() {\n      var containerName;\n      var blobName;\n      try {\n        //  URL may look like the following\n        // \"https://myaccount.blob.core.windows.net/mycontainer/blob?sasString\";\n        // \"https://myaccount.blob.core.windows.net/mycontainer/blob\";\n        // \"https://myaccount.blob.core.windows.net/mycontainer/blob/a.txt?sasString\";\n        // \"https://myaccount.blob.core.windows.net/mycontainer/blob/a.txt\";\n        // IPv4/IPv6 address hosts, Endpoints - `http://127.0.0.1:10000/devstoreaccount1/containername/blob`\n        // http://localhost:10001/devstoreaccount1/containername/blob\n        var parsedUrl = URLBuilder.parse(this.url);\n        if (parsedUrl.getHost().split(\".\")[1] === \"blob\") {\n          // \"https://myaccount.blob.core.windows.net/containername/blob\".\n          // .getPath() -> /containername/blob\n          var pathComponents = parsedUrl.getPath().match(\"/([^/]*)(/(.*))?\");\n          containerName = pathComponents[1];\n          blobName = pathComponents[3];\n        } else if (isIpEndpointStyle(parsedUrl)) {\n          // IPv4/IPv6 address hosts... Example - http://192.0.0.10:10001/devstoreaccount1/containername/blob\n          // Single word domain without a [dot] in the endpoint... Example - http://localhost:10001/devstoreaccount1/containername/blob\n          // .getPath() -> /devstoreaccount1/containername/blob\n          var _pathComponents = parsedUrl.getPath().match(\"/([^/]*)/([^/]*)(/(.*))?\");\n          containerName = _pathComponents[2];\n          blobName = _pathComponents[4];\n        } else {\n          // \"https://customdomain.com/containername/blob\".\n          // .getPath() -> /containername/blob\n          var _pathComponents2 = parsedUrl.getPath().match(\"/([^/]*)(/(.*))?\");\n          containerName = _pathComponents2[1];\n          blobName = _pathComponents2[3];\n        }\n        // decode the encoded blobName, containerName - to get all the special characters that might be present in them\n        containerName = decodeURIComponent(containerName);\n        blobName = decodeURIComponent(blobName);\n        // Azure Storage Server will replace \"\\\" with \"/\" in the blob names\n        //   doing the same in the SDK side so that the user doesn't have to replace \"\\\" instances in the blobName\n        blobName = blobName.replace(/\\\\/g, \"/\");\n        if (!containerName) {\n          throw new Error(\"Provided containerName is invalid.\");\n        }\n        return {\n          blobName: blobName,\n          containerName: containerName\n        };\n      } catch (error) {\n        throw new Error(\"Unable to extract blobName and containerName with provided information.\");\n      }\n    }\n    /**\n     * Asynchronously copies a blob to a destination within the storage account.\n     * In version 2012-02-12 and later, the source for a Copy Blob operation can be\n     * a committed blob in any Azure storage account.\n     * Beginning with version 2015-02-21, the source for a Copy Blob operation can be\n     * an Azure file in any Azure storage account.\n     * Only storage accounts created on or after June 7th, 2012 allow the Copy Blob\n     * operation to copy from another storage account.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/copy-blob\n     *\n     * @param copySource - url to the source Azure Blob/File.\n     * @param options - Optional options to the Blob Start Copy From URL operation.\n     */\n  }, {\n    key: \"startCopyFromURL\",\n    value: function () {\n      var _startCopyFromURL = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21(copySource) {\n        var options,\n          _a,\n          _b,\n          _c,\n          _createSpan17,\n          span,\n          updatedOptions,\n          _args21 = arguments;\n        return _regeneratorRuntime().wrap(function _callee21$(_context21) {\n          while (1) {\n            switch (_context21.prev = _context21.next) {\n              case 0:\n                options = _args21.length > 1 && _args21[1] !== undefined ? _args21[1] : {};\n                _createSpan17 = createSpan(\"BlobClient-startCopyFromURL\", options), span = _createSpan17.span, updatedOptions = _createSpan17.updatedOptions;\n                options.conditions = options.conditions || {};\n                options.sourceConditions = options.sourceConditions || {};\n                _context21.prev = 4;\n                _context21.next = 7;\n                return this.blobContext.startCopyFromURL(copySource, Object.assign({\n                  abortSignal: options.abortSignal,\n                  leaseAccessConditions: options.conditions,\n                  metadata: options.metadata,\n                  modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n                    ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n                  }),\n                  sourceModifiedAccessConditions: {\n                    sourceIfMatch: options.sourceConditions.ifMatch,\n                    sourceIfModifiedSince: options.sourceConditions.ifModifiedSince,\n                    sourceIfNoneMatch: options.sourceConditions.ifNoneMatch,\n                    sourceIfUnmodifiedSince: options.sourceConditions.ifUnmodifiedSince,\n                    sourceIfTags: options.sourceConditions.tagConditions\n                  },\n                  immutabilityPolicyExpiry: (_b = options.immutabilityPolicy) === null || _b === void 0 ? void 0 : _b.expiriesOn,\n                  immutabilityPolicyMode: (_c = options.immutabilityPolicy) === null || _c === void 0 ? void 0 : _c.policyMode,\n                  legalHold: options.legalHold,\n                  rehydratePriority: options.rehydratePriority,\n                  tier: toAccessTier(options.tier),\n                  blobTagsString: toBlobTagsString(options.tags),\n                  sealBlob: options.sealBlob\n                }, convertTracingToRequestOptionsBase(updatedOptions)));\n              case 7:\n                return _context21.abrupt(\"return\", _context21.sent);\n              case 10:\n                _context21.prev = 10;\n                _context21.t0 = _context21[\"catch\"](4);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context21.t0.message\n                });\n                throw _context21.t0;\n              case 14:\n                _context21.prev = 14;\n                span.end();\n                return _context21.finish(14);\n              case 17:\n              case \"end\":\n                return _context21.stop();\n            }\n          }\n        }, _callee21, this, [[4, 10, 14, 17]]);\n      }));\n      function startCopyFromURL(_x13) {\n        return _startCopyFromURL.apply(this, arguments);\n      }\n      return startCopyFromURL;\n    }()\n    /**\n     * Only available for BlobClient constructed with a shared key credential.\n     *\n     * Generates a Blob Service Shared Access Signature (SAS) URI based on the client properties\n     * and parameters passed in. The SAS is signed by the shared key credential of the client.\n     *\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas\n     *\n     * @param options - Optional parameters.\n     * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.\n     */\n  }, {\n    key: \"generateSasUrl\",\n    value: function generateSasUrl(options) {\n      var _this5 = this;\n      return new Promise(function (resolve) {\n        if (!(_this5.credential instanceof StorageSharedKeyCredential)) {\n          throw new RangeError(\"Can only generate the SAS when the client is initialized with a shared key credential\");\n        }\n        var sas = generateBlobSASQueryParameters(Object.assign({\n          containerName: _this5._containerName,\n          blobName: _this5._name,\n          snapshotTime: _this5._snapshot,\n          versionId: _this5._versionId\n        }, options), _this5.credential).toString();\n        resolve(appendToURLQuery(_this5.url, sas));\n      });\n    }\n    /**\n     * Delete the immutablility policy on the blob.\n     *\n     * @param options - Optional options to delete immutability policy on the blob.\n     */\n  }, {\n    key: \"deleteImmutabilityPolicy\",\n    value: function () {\n      var _deleteImmutabilityPolicy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee22(options) {\n        var _createSpan18, span, updatedOptions;\n        return _regeneratorRuntime().wrap(function _callee22$(_context22) {\n          while (1) {\n            switch (_context22.prev = _context22.next) {\n              case 0:\n                _createSpan18 = createSpan(\"BlobClient-deleteImmutabilityPolicy\", options), span = _createSpan18.span, updatedOptions = _createSpan18.updatedOptions;\n                _context22.prev = 1;\n                _context22.next = 4;\n                return this.blobContext.deleteImmutabilityPolicy(Object.assign({\n                  abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal\n                }, convertTracingToRequestOptionsBase(updatedOptions)));\n              case 4:\n                return _context22.abrupt(\"return\", _context22.sent);\n              case 7:\n                _context22.prev = 7;\n                _context22.t0 = _context22[\"catch\"](1);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context22.t0.message\n                });\n                throw _context22.t0;\n              case 11:\n                _context22.prev = 11;\n                span.end();\n                return _context22.finish(11);\n              case 14:\n              case \"end\":\n                return _context22.stop();\n            }\n          }\n        }, _callee22, this, [[1, 7, 11, 14]]);\n      }));\n      function deleteImmutabilityPolicy(_x14) {\n        return _deleteImmutabilityPolicy.apply(this, arguments);\n      }\n      return deleteImmutabilityPolicy;\n    }()\n    /**\n     * Set immutablility policy on the blob.\n     *\n     * @param options - Optional options to set immutability policy on the blob.\n     */\n  }, {\n    key: \"setImmutabilityPolicy\",\n    value: function () {\n      var _setImmutabilityPolicy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee23(immutabilityPolicy, options) {\n        var _createSpan19, span, updatedOptions;\n        return _regeneratorRuntime().wrap(function _callee23$(_context23) {\n          while (1) {\n            switch (_context23.prev = _context23.next) {\n              case 0:\n                _createSpan19 = createSpan(\"BlobClient-setImmutabilityPolicy\", options), span = _createSpan19.span, updatedOptions = _createSpan19.updatedOptions;\n                _context23.prev = 1;\n                _context23.next = 4;\n                return this.blobContext.setImmutabilityPolicy(Object.assign({\n                  abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal,\n                  immutabilityPolicyExpiry: immutabilityPolicy.expiriesOn,\n                  immutabilityPolicyMode: immutabilityPolicy.policyMode,\n                  modifiedAccessConditions: options === null || options === void 0 ? void 0 : options.modifiedAccessCondition\n                }, convertTracingToRequestOptionsBase(updatedOptions)));\n              case 4:\n                return _context23.abrupt(\"return\", _context23.sent);\n              case 7:\n                _context23.prev = 7;\n                _context23.t0 = _context23[\"catch\"](1);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context23.t0.message\n                });\n                throw _context23.t0;\n              case 11:\n                _context23.prev = 11;\n                span.end();\n                return _context23.finish(11);\n              case 14:\n              case \"end\":\n                return _context23.stop();\n            }\n          }\n        }, _callee23, this, [[1, 7, 11, 14]]);\n      }));\n      function setImmutabilityPolicy(_x15, _x16) {\n        return _setImmutabilityPolicy.apply(this, arguments);\n      }\n      return setImmutabilityPolicy;\n    }()\n    /**\n     * Set legal hold on the blob.\n     *\n     * @param options - Optional options to set legal hold on the blob.\n     */\n  }, {\n    key: \"setLegalHold\",\n    value: function () {\n      var _setLegalHold = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee24(legalHoldEnabled, options) {\n        var _createSpan20, span, updatedOptions;\n        return _regeneratorRuntime().wrap(function _callee24$(_context24) {\n          while (1) {\n            switch (_context24.prev = _context24.next) {\n              case 0:\n                _createSpan20 = createSpan(\"BlobClient-setLegalHold\", options), span = _createSpan20.span, updatedOptions = _createSpan20.updatedOptions;\n                _context24.prev = 1;\n                _context24.next = 4;\n                return this.blobContext.setLegalHold(legalHoldEnabled, Object.assign({\n                  abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal\n                }, convertTracingToRequestOptionsBase(updatedOptions)));\n              case 4:\n                return _context24.abrupt(\"return\", _context24.sent);\n              case 7:\n                _context24.prev = 7;\n                _context24.t0 = _context24[\"catch\"](1);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context24.t0.message\n                });\n                throw _context24.t0;\n              case 11:\n                _context24.prev = 11;\n                span.end();\n                return _context24.finish(11);\n              case 14:\n              case \"end\":\n                return _context24.stop();\n            }\n          }\n        }, _callee24, this, [[1, 7, 11, 14]]);\n      }));\n      function setLegalHold(_x17, _x18) {\n        return _setLegalHold.apply(this, arguments);\n      }\n      return setLegalHold;\n    }()\n  }]);\n  return BlobClient;\n}(StorageClient);\n/**\n * AppendBlobClient defines a set of operations applicable to append blobs.\n */\nexport var AppendBlobClient = /*#__PURE__*/function (_BlobClient) {\n  _inherits(AppendBlobClient, _BlobClient);\n  var _super2 = _createSuper(AppendBlobClient);\n  function AppendBlobClient(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions,\n  // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n  /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n  options) {\n    var _this6;\n    _classCallCheck(this, AppendBlobClient);\n    // In TypeScript we cannot simply pass all parameters to super() like below so have to duplicate the code instead.\n    //   super(s, credentialOrPipelineOrContainerNameOrOptions, blobNameOrOptions, options);\n    var pipeline;\n    var url;\n    options = options || {};\n    if (isPipelineLike(credentialOrPipelineOrContainerName)) {\n      // (url: string, pipeline: Pipeline)\n      url = urlOrConnectionString;\n      pipeline = credentialOrPipelineOrContainerName;\n    } else if (isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential || isTokenCredential(credentialOrPipelineOrContainerName)) {\n      // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)      url = urlOrConnectionString;\n      url = urlOrConnectionString;\n      options = blobNameOrOptions;\n      pipeline = newPipeline(credentialOrPipelineOrContainerName, options);\n    } else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== \"string\") {\n      // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n      url = urlOrConnectionString;\n      // The second parameter is undefined. Use anonymous credential.\n      pipeline = newPipeline(new AnonymousCredential(), options);\n    } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === \"string\" && blobNameOrOptions && typeof blobNameOrOptions === \"string\") {\n      // (connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions)\n      var containerName = credentialOrPipelineOrContainerName;\n      var blobName = blobNameOrOptions;\n      var extractedCreds = extractConnectionStringParts(urlOrConnectionString);\n      if (extractedCreds.kind === \"AccountConnString\") {\n        if (isNode) {\n          var sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);\n          url = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));\n          if (!options.proxyOptions) {\n            options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);\n          }\n          pipeline = newPipeline(sharedKeyCredential, options);\n        } else {\n          throw new Error(\"Account connection string is only supported in Node.js environment\");\n        }\n      } else if (extractedCreds.kind === \"SASConnString\") {\n        url = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + \"?\" + extractedCreds.accountSas;\n        pipeline = newPipeline(new AnonymousCredential(), options);\n      } else {\n        throw new Error(\"Connection string must be either an Account connection string or a SAS connection string\");\n      }\n    } else {\n      throw new Error(\"Expecting non-empty strings for containerName and blobName parameters\");\n    }\n    _this6 = _super2.call(this, url, pipeline);\n    _this6.appendBlobContext = new AppendBlob(_this6.storageClientContext);\n    return _this6;\n  }\n  /**\n   * Creates a new AppendBlobClient object identical to the source but with the\n   * specified snapshot timestamp.\n   * Provide \"\" will remove the snapshot and return a Client to the base blob.\n   *\n   * @param snapshot - The snapshot timestamp.\n   * @returns A new AppendBlobClient object identical to the source but with the specified snapshot timestamp.\n   */\n  _createClass(AppendBlobClient, [{\n    key: \"withSnapshot\",\n    value: function withSnapshot(snapshot) {\n      return new AppendBlobClient(setURLParameter(this.url, URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? undefined : snapshot), this.pipeline);\n    }\n    /**\n     * Creates a 0-length append blob. Call AppendBlock to append data to an append blob.\n     * @see https://docs.microsoft.com/rest/api/storageservices/put-blob\n     *\n     * @param options - Options to the Append Block Create operation.\n     *\n     *\n     * Example usage:\n     *\n     * ```js\n     * const appendBlobClient = containerClient.getAppendBlobClient(\"<blob name>\");\n     * await appendBlobClient.create();\n     * ```\n     */\n  }, {\n    key: \"create\",\n    value: function () {\n      var _create = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee25() {\n        var options,\n          _a,\n          _b,\n          _c,\n          _createSpan21,\n          span,\n          updatedOptions,\n          _args25 = arguments;\n        return _regeneratorRuntime().wrap(function _callee25$(_context25) {\n          while (1) {\n            switch (_context25.prev = _context25.next) {\n              case 0:\n                options = _args25.length > 0 && _args25[0] !== undefined ? _args25[0] : {};\n                _createSpan21 = createSpan(\"AppendBlobClient-create\", options), span = _createSpan21.span, updatedOptions = _createSpan21.updatedOptions;\n                options.conditions = options.conditions || {};\n                _context25.prev = 3;\n                ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n                _context25.next = 7;\n                return this.appendBlobContext.create(0, Object.assign({\n                  abortSignal: options.abortSignal,\n                  blobHttpHeaders: options.blobHTTPHeaders,\n                  leaseAccessConditions: options.conditions,\n                  metadata: options.metadata,\n                  modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n                    ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n                  }),\n                  cpkInfo: options.customerProvidedKey,\n                  encryptionScope: options.encryptionScope,\n                  immutabilityPolicyExpiry: (_b = options.immutabilityPolicy) === null || _b === void 0 ? void 0 : _b.expiriesOn,\n                  immutabilityPolicyMode: (_c = options.immutabilityPolicy) === null || _c === void 0 ? void 0 : _c.policyMode,\n                  legalHold: options.legalHold,\n                  blobTagsString: toBlobTagsString(options.tags)\n                }, convertTracingToRequestOptionsBase(updatedOptions)));\n              case 7:\n                return _context25.abrupt(\"return\", _context25.sent);\n              case 10:\n                _context25.prev = 10;\n                _context25.t0 = _context25[\"catch\"](3);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context25.t0.message\n                });\n                throw _context25.t0;\n              case 14:\n                _context25.prev = 14;\n                span.end();\n                return _context25.finish(14);\n              case 17:\n              case \"end\":\n                return _context25.stop();\n            }\n          }\n        }, _callee25, this, [[3, 10, 14, 17]]);\n      }));\n      function create() {\n        return _create.apply(this, arguments);\n      }\n      return create;\n    }()\n    /**\n     * Creates a 0-length append blob. Call AppendBlock to append data to an append blob.\n     * If the blob with the same name already exists, the content of the existing blob will remain unchanged.\n     * @see https://docs.microsoft.com/rest/api/storageservices/put-blob\n     *\n     * @param options -\n     */\n  }, {\n    key: \"createIfNotExists\",\n    value: function () {\n      var _createIfNotExists = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee26() {\n        var options,\n          _a,\n          _b,\n          _createSpan22,\n          span,\n          updatedOptions,\n          conditions,\n          res,\n          _args26 = arguments;\n        return _regeneratorRuntime().wrap(function _callee26$(_context26) {\n          while (1) {\n            switch (_context26.prev = _context26.next) {\n              case 0:\n                options = _args26.length > 0 && _args26[0] !== undefined ? _args26[0] : {};\n                _createSpan22 = createSpan(\"AppendBlobClient-createIfNotExists\", options), span = _createSpan22.span, updatedOptions = _createSpan22.updatedOptions;\n                conditions = {\n                  ifNoneMatch: ETagAny\n                };\n                _context26.prev = 3;\n                _context26.next = 6;\n                return this.create(Object.assign(Object.assign({}, updatedOptions), {\n                  conditions: conditions\n                }));\n              case 6:\n                res = _context26.sent;\n                return _context26.abrupt(\"return\", Object.assign(Object.assign({\n                  succeeded: true\n                }, res), {\n                  _response: res._response\n                }));\n              case 10:\n                _context26.prev = 10;\n                _context26.t0 = _context26[\"catch\"](3);\n                if (!(((_a = _context26.t0.details) === null || _a === void 0 ? void 0 : _a.errorCode) === \"BlobAlreadyExists\")) {\n                  _context26.next = 15;\n                  break;\n                }\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: \"Expected exception when creating a blob only if it does not already exist.\"\n                });\n                return _context26.abrupt(\"return\", Object.assign(Object.assign({\n                  succeeded: false\n                }, (_b = _context26.t0.response) === null || _b === void 0 ? void 0 : _b.parsedHeaders), {\n                  _response: _context26.t0.response\n                }));\n              case 15:\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context26.t0.message\n                });\n                throw _context26.t0;\n              case 17:\n                _context26.prev = 17;\n                span.end();\n                return _context26.finish(17);\n              case 20:\n              case \"end\":\n                return _context26.stop();\n            }\n          }\n        }, _callee26, this, [[3, 10, 17, 20]]);\n      }));\n      function createIfNotExists() {\n        return _createIfNotExists.apply(this, arguments);\n      }\n      return createIfNotExists;\n    }()\n    /**\n     * Seals the append blob, making it read only.\n     *\n     * @param options -\n     */\n  }, {\n    key: \"seal\",\n    value: function () {\n      var _seal = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee27() {\n        var options,\n          _a,\n          _createSpan23,\n          span,\n          updatedOptions,\n          _args27 = arguments;\n        return _regeneratorRuntime().wrap(function _callee27$(_context27) {\n          while (1) {\n            switch (_context27.prev = _context27.next) {\n              case 0:\n                options = _args27.length > 0 && _args27[0] !== undefined ? _args27[0] : {};\n                _createSpan23 = createSpan(\"AppendBlobClient-seal\", options), span = _createSpan23.span, updatedOptions = _createSpan23.updatedOptions;\n                options.conditions = options.conditions || {};\n                _context27.prev = 3;\n                _context27.next = 6;\n                return this.appendBlobContext.seal(Object.assign({\n                  abortSignal: options.abortSignal,\n                  appendPositionAccessConditions: options.conditions,\n                  leaseAccessConditions: options.conditions,\n                  modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n                    ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n                  })\n                }, convertTracingToRequestOptionsBase(updatedOptions)));\n              case 6:\n                return _context27.abrupt(\"return\", _context27.sent);\n              case 9:\n                _context27.prev = 9;\n                _context27.t0 = _context27[\"catch\"](3);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context27.t0.message\n                });\n                throw _context27.t0;\n              case 13:\n                _context27.prev = 13;\n                span.end();\n                return _context27.finish(13);\n              case 16:\n              case \"end\":\n                return _context27.stop();\n            }\n          }\n        }, _callee27, this, [[3, 9, 13, 16]]);\n      }));\n      function seal() {\n        return _seal.apply(this, arguments);\n      }\n      return seal;\n    }()\n    /**\n     * Commits a new block of data to the end of the existing append blob.\n     * @see https://docs.microsoft.com/rest/api/storageservices/append-block\n     *\n     * @param body - Data to be appended.\n     * @param contentLength - Length of the body in bytes.\n     * @param options - Options to the Append Block operation.\n     *\n     *\n     * Example usage:\n     *\n     * ```js\n     * const content = \"Hello World!\";\n     *\n     * // Create a new append blob and append data to the blob.\n     * const newAppendBlobClient = containerClient.getAppendBlobClient(\"<blob name>\");\n     * await newAppendBlobClient.create();\n     * await newAppendBlobClient.appendBlock(content, content.length);\n     *\n     * // Append data to an existing append blob.\n     * const existingAppendBlobClient = containerClient.getAppendBlobClient(\"<blob name>\");\n     * await existingAppendBlobClient.appendBlock(content, content.length);\n     * ```\n     */\n  }, {\n    key: \"appendBlock\",\n    value: function () {\n      var _appendBlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee28(body, contentLength) {\n        var options,\n          _a,\n          _createSpan24,\n          span,\n          updatedOptions,\n          _args28 = arguments;\n        return _regeneratorRuntime().wrap(function _callee28$(_context28) {\n          while (1) {\n            switch (_context28.prev = _context28.next) {\n              case 0:\n                options = _args28.length > 2 && _args28[2] !== undefined ? _args28[2] : {};\n                _createSpan24 = createSpan(\"AppendBlobClient-appendBlock\", options), span = _createSpan24.span, updatedOptions = _createSpan24.updatedOptions;\n                options.conditions = options.conditions || {};\n                _context28.prev = 3;\n                ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n                _context28.next = 7;\n                return this.appendBlobContext.appendBlock(contentLength, body, Object.assign({\n                  abortSignal: options.abortSignal,\n                  appendPositionAccessConditions: options.conditions,\n                  leaseAccessConditions: options.conditions,\n                  modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n                    ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n                  }),\n                  requestOptions: {\n                    onUploadProgress: options.onProgress\n                  },\n                  transactionalContentMD5: options.transactionalContentMD5,\n                  transactionalContentCrc64: options.transactionalContentCrc64,\n                  cpkInfo: options.customerProvidedKey,\n                  encryptionScope: options.encryptionScope\n                }, convertTracingToRequestOptionsBase(updatedOptions)));\n              case 7:\n                return _context28.abrupt(\"return\", _context28.sent);\n              case 10:\n                _context28.prev = 10;\n                _context28.t0 = _context28[\"catch\"](3);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context28.t0.message\n                });\n                throw _context28.t0;\n              case 14:\n                _context28.prev = 14;\n                span.end();\n                return _context28.finish(14);\n              case 17:\n              case \"end\":\n                return _context28.stop();\n            }\n          }\n        }, _callee28, this, [[3, 10, 14, 17]]);\n      }));\n      function appendBlock(_x19, _x20) {\n        return _appendBlock.apply(this, arguments);\n      }\n      return appendBlock;\n    }()\n    /**\n     * The Append Block operation commits a new block of data to the end of an existing append blob\n     * where the contents are read from a source url.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/append-block-from-url\n     *\n     * @param sourceURL -\n     *                 The url to the blob that will be the source of the copy. A source blob in the same storage account can\n     *                 be authenticated via Shared Key. However, if the source is a blob in another account, the source blob\n     *                 must either be public or must be authenticated via a shared access signature. If the source blob is\n     *                 public, no authentication is required to perform the operation.\n     * @param sourceOffset - Offset in source to be appended\n     * @param count - Number of bytes to be appended as a block\n     * @param options -\n     */\n  }, {\n    key: \"appendBlockFromURL\",\n    value: function () {\n      var _appendBlockFromURL = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee29(sourceURL, sourceOffset, count) {\n        var options,\n          _a,\n          _createSpan25,\n          span,\n          updatedOptions,\n          _args29 = arguments;\n        return _regeneratorRuntime().wrap(function _callee29$(_context29) {\n          while (1) {\n            switch (_context29.prev = _context29.next) {\n              case 0:\n                options = _args29.length > 3 && _args29[3] !== undefined ? _args29[3] : {};\n                _createSpan25 = createSpan(\"AppendBlobClient-appendBlockFromURL\", options), span = _createSpan25.span, updatedOptions = _createSpan25.updatedOptions;\n                options.conditions = options.conditions || {};\n                options.sourceConditions = options.sourceConditions || {};\n                _context29.prev = 4;\n                ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n                _context29.next = 8;\n                return this.appendBlobContext.appendBlockFromUrl(sourceURL, 0, Object.assign({\n                  abortSignal: options.abortSignal,\n                  sourceRange: rangeToString({\n                    offset: sourceOffset,\n                    count: count\n                  }),\n                  sourceContentMD5: options.sourceContentMD5,\n                  sourceContentCrc64: options.sourceContentCrc64,\n                  leaseAccessConditions: options.conditions,\n                  appendPositionAccessConditions: options.conditions,\n                  modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n                    ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n                  }),\n                  sourceModifiedAccessConditions: {\n                    sourceIfMatch: options.sourceConditions.ifMatch,\n                    sourceIfModifiedSince: options.sourceConditions.ifModifiedSince,\n                    sourceIfNoneMatch: options.sourceConditions.ifNoneMatch,\n                    sourceIfUnmodifiedSince: options.sourceConditions.ifUnmodifiedSince\n                  },\n                  copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization),\n                  cpkInfo: options.customerProvidedKey,\n                  encryptionScope: options.encryptionScope\n                }, convertTracingToRequestOptionsBase(updatedOptions)));\n              case 8:\n                return _context29.abrupt(\"return\", _context29.sent);\n              case 11:\n                _context29.prev = 11;\n                _context29.t0 = _context29[\"catch\"](4);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context29.t0.message\n                });\n                throw _context29.t0;\n              case 15:\n                _context29.prev = 15;\n                span.end();\n                return _context29.finish(15);\n              case 18:\n              case \"end\":\n                return _context29.stop();\n            }\n          }\n        }, _callee29, this, [[4, 11, 15, 18]]);\n      }));\n      function appendBlockFromURL(_x21, _x22, _x23) {\n        return _appendBlockFromURL.apply(this, arguments);\n      }\n      return appendBlockFromURL;\n    }()\n  }]);\n  return AppendBlobClient;\n}(BlobClient);\n/**\n * BlockBlobClient defines a set of operations applicable to block blobs.\n */\nexport var BlockBlobClient = /*#__PURE__*/function (_BlobClient2) {\n  _inherits(BlockBlobClient, _BlobClient2);\n  var _super3 = _createSuper(BlockBlobClient);\n  function BlockBlobClient(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions,\n  // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n  /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n  options) {\n    var _this7;\n    _classCallCheck(this, BlockBlobClient);\n    // In TypeScript we cannot simply pass all parameters to super() like below so have to duplicate the code instead.\n    //   super(s, credentialOrPipelineOrContainerNameOrOptions, blobNameOrOptions, options);\n    var pipeline;\n    var url;\n    options = options || {};\n    if (isPipelineLike(credentialOrPipelineOrContainerName)) {\n      // (url: string, pipeline: Pipeline)\n      url = urlOrConnectionString;\n      pipeline = credentialOrPipelineOrContainerName;\n    } else if (isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential || isTokenCredential(credentialOrPipelineOrContainerName)) {\n      // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n      url = urlOrConnectionString;\n      options = blobNameOrOptions;\n      pipeline = newPipeline(credentialOrPipelineOrContainerName, options);\n    } else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== \"string\") {\n      // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n      // The second parameter is undefined. Use anonymous credential.\n      url = urlOrConnectionString;\n      pipeline = newPipeline(new AnonymousCredential(), options);\n    } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === \"string\" && blobNameOrOptions && typeof blobNameOrOptions === \"string\") {\n      // (connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions)\n      var containerName = credentialOrPipelineOrContainerName;\n      var blobName = blobNameOrOptions;\n      var extractedCreds = extractConnectionStringParts(urlOrConnectionString);\n      if (extractedCreds.kind === \"AccountConnString\") {\n        if (isNode) {\n          var sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);\n          url = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));\n          if (!options.proxyOptions) {\n            options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);\n          }\n          pipeline = newPipeline(sharedKeyCredential, options);\n        } else {\n          throw new Error(\"Account connection string is only supported in Node.js environment\");\n        }\n      } else if (extractedCreds.kind === \"SASConnString\") {\n        url = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + \"?\" + extractedCreds.accountSas;\n        pipeline = newPipeline(new AnonymousCredential(), options);\n      } else {\n        throw new Error(\"Connection string must be either an Account connection string or a SAS connection string\");\n      }\n    } else {\n      throw new Error(\"Expecting non-empty strings for containerName and blobName parameters\");\n    }\n    _this7 = _super3.call(this, url, pipeline);\n    _this7.blockBlobContext = new BlockBlob(_this7.storageClientContext);\n    _this7._blobContext = new StorageBlob(_this7.storageClientContext);\n    return _this7;\n  }\n  /**\n   * Creates a new BlockBlobClient object identical to the source but with the\n   * specified snapshot timestamp.\n   * Provide \"\" will remove the snapshot and return a URL to the base blob.\n   *\n   * @param snapshot - The snapshot timestamp.\n   * @returns A new BlockBlobClient object identical to the source but with the specified snapshot timestamp.\n   */\n  _createClass(BlockBlobClient, [{\n    key: \"withSnapshot\",\n    value: function withSnapshot(snapshot) {\n      return new BlockBlobClient(setURLParameter(this.url, URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? undefined : snapshot), this.pipeline);\n    }\n    /**\n     * ONLY AVAILABLE IN NODE.JS RUNTIME.\n     *\n     * Quick query for a JSON or CSV formatted blob.\n     *\n     * Example usage (Node.js):\n     *\n     * ```js\n     * // Query and convert a blob to a string\n     * const queryBlockBlobResponse = await blockBlobClient.query(\"select * from BlobStorage\");\n     * const downloaded = (await streamToBuffer(queryBlockBlobResponse.readableStreamBody)).toString();\n     * console.log(\"Query blob content:\", downloaded);\n     *\n     * async function streamToBuffer(readableStream) {\n     *   return new Promise((resolve, reject) => {\n     *     const chunks = [];\n     *     readableStream.on(\"data\", (data) => {\n     *       chunks.push(data instanceof Buffer ? data : Buffer.from(data));\n     *     });\n     *     readableStream.on(\"end\", () => {\n     *       resolve(Buffer.concat(chunks));\n     *     });\n     *     readableStream.on(\"error\", reject);\n     *   });\n     * }\n     * ```\n     *\n     * @param query -\n     * @param options -\n     */\n  }, {\n    key: \"query\",\n    value: function () {\n      var _query2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee30(_query) {\n        var options,\n          _a,\n          _createSpan26,\n          span,\n          updatedOptions,\n          response,\n          _args30 = arguments;\n        return _regeneratorRuntime().wrap(function _callee30$(_context30) {\n          while (1) {\n            switch (_context30.prev = _context30.next) {\n              case 0:\n                options = _args30.length > 1 && _args30[1] !== undefined ? _args30[1] : {};\n                ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n                _createSpan26 = createSpan(\"BlockBlobClient-query\", options), span = _createSpan26.span, updatedOptions = _createSpan26.updatedOptions;\n                _context30.prev = 3;\n                if (isNode) {\n                  _context30.next = 6;\n                  break;\n                }\n                throw new Error(\"This operation currently is only supported in Node.js.\");\n              case 6:\n                ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n                _context30.next = 9;\n                return this._blobContext.query(Object.assign({\n                  abortSignal: options.abortSignal,\n                  queryRequest: {\n                    queryType: \"SQL\",\n                    expression: _query,\n                    inputSerialization: toQuerySerialization(options.inputTextConfiguration),\n                    outputSerialization: toQuerySerialization(options.outputTextConfiguration)\n                  },\n                  leaseAccessConditions: options.conditions,\n                  modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n                    ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n                  }),\n                  cpkInfo: options.customerProvidedKey\n                }, convertTracingToRequestOptionsBase(updatedOptions)));\n              case 9:\n                response = _context30.sent;\n                return _context30.abrupt(\"return\", new BlobQueryResponse(response, {\n                  abortSignal: options.abortSignal,\n                  onProgress: options.onProgress,\n                  onError: options.onError\n                }));\n              case 13:\n                _context30.prev = 13;\n                _context30.t0 = _context30[\"catch\"](3);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context30.t0.message\n                });\n                throw _context30.t0;\n              case 17:\n                _context30.prev = 17;\n                span.end();\n                return _context30.finish(17);\n              case 20:\n              case \"end\":\n                return _context30.stop();\n            }\n          }\n        }, _callee30, this, [[3, 13, 17, 20]]);\n      }));\n      function query(_x24) {\n        return _query2.apply(this, arguments);\n      }\n      return query;\n    }()\n    /**\n     * Creates a new block blob, or updates the content of an existing block blob.\n     * Updating an existing block blob overwrites any existing metadata on the blob.\n     * Partial updates are not supported; the content of the existing blob is\n     * overwritten with the new content. To perform a partial update of a block blob's,\n     * use {@link stageBlock} and {@link commitBlockList}.\n     *\n     * This is a non-parallel uploading method, please use {@link uploadFile},\n     * {@link uploadStream} or {@link uploadBrowserData} for better performance\n     * with concurrency uploading.\n     *\n     * @see https://docs.microsoft.com/rest/api/storageservices/put-blob\n     *\n     * @param body - Blob, string, ArrayBuffer, ArrayBufferView or a function\n     *                               which returns a new Readable stream whose offset is from data source beginning.\n     * @param contentLength - Length of body in bytes. Use Buffer.byteLength() to calculate body length for a\n     *                               string including non non-Base64/Hex-encoded characters.\n     * @param options - Options to the Block Blob Upload operation.\n     * @returns Response data for the Block Blob Upload operation.\n     *\n     * Example usage:\n     *\n     * ```js\n     * const content = \"Hello world!\";\n     * const uploadBlobResponse = await blockBlobClient.upload(content, content.length);\n     * ```\n     */\n  }, {\n    key: \"upload\",\n    value: function () {\n      var _upload = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee31(body, contentLength) {\n        var options,\n          _a,\n          _b,\n          _c,\n          _createSpan27,\n          span,\n          updatedOptions,\n          _args31 = arguments;\n        return _regeneratorRuntime().wrap(function _callee31$(_context31) {\n          while (1) {\n            switch (_context31.prev = _context31.next) {\n              case 0:\n                options = _args31.length > 2 && _args31[2] !== undefined ? _args31[2] : {};\n                options.conditions = options.conditions || {};\n                _createSpan27 = createSpan(\"BlockBlobClient-upload\", options), span = _createSpan27.span, updatedOptions = _createSpan27.updatedOptions;\n                _context31.prev = 3;\n                ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n                _context31.next = 7;\n                return this.blockBlobContext.upload(contentLength, body, Object.assign({\n                  abortSignal: options.abortSignal,\n                  blobHttpHeaders: options.blobHTTPHeaders,\n                  leaseAccessConditions: options.conditions,\n                  metadata: options.metadata,\n                  modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n                    ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n                  }),\n                  requestOptions: {\n                    onUploadProgress: options.onProgress\n                  },\n                  cpkInfo: options.customerProvidedKey,\n                  encryptionScope: options.encryptionScope,\n                  immutabilityPolicyExpiry: (_b = options.immutabilityPolicy) === null || _b === void 0 ? void 0 : _b.expiriesOn,\n                  immutabilityPolicyMode: (_c = options.immutabilityPolicy) === null || _c === void 0 ? void 0 : _c.policyMode,\n                  legalHold: options.legalHold,\n                  tier: toAccessTier(options.tier),\n                  blobTagsString: toBlobTagsString(options.tags)\n                }, convertTracingToRequestOptionsBase(updatedOptions)));\n              case 7:\n                return _context31.abrupt(\"return\", _context31.sent);\n              case 10:\n                _context31.prev = 10;\n                _context31.t0 = _context31[\"catch\"](3);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context31.t0.message\n                });\n                throw _context31.t0;\n              case 14:\n                _context31.prev = 14;\n                span.end();\n                return _context31.finish(14);\n              case 17:\n              case \"end\":\n                return _context31.stop();\n            }\n          }\n        }, _callee31, this, [[3, 10, 14, 17]]);\n      }));\n      function upload(_x25, _x26) {\n        return _upload.apply(this, arguments);\n      }\n      return upload;\n    }()\n    /**\n     * Creates a new Block Blob where the contents of the blob are read from a given URL.\n     * This API is supported beginning with the 2020-04-08 version. Partial updates\n     * are not supported with Put Blob from URL; the content of an existing blob is overwritten with\n     * the content of the new blob.  To perform partial updates to a block blob’s contents using a\n     * source URL, use {@link stageBlockFromURL} and {@link commitBlockList}.\n     *\n     * @param sourceURL - Specifies the URL of the blob. The value\n     *                           may be a URL of up to 2 KB in length that specifies a blob.\n     *                           The value should be URL-encoded as it would appear\n     *                           in a request URI. The source blob must either be public\n     *                           or must be authenticated via a shared access signature.\n     *                           If the source blob is public, no authentication is required\n     *                           to perform the operation. Here are some examples of source object URLs:\n     *                           - https://myaccount.blob.core.windows.net/mycontainer/myblob\n     *                           - https://myaccount.blob.core.windows.net/mycontainer/myblob?snapshot=<DateTime>\n     * @param options - Optional parameters.\n     */\n  }, {\n    key: \"syncUploadFromURL\",\n    value: function () {\n      var _syncUploadFromURL = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee32(sourceURL) {\n        var options,\n          _a,\n          _b,\n          _c,\n          _d,\n          _e,\n          _createSpan28,\n          span,\n          updatedOptions,\n          _args32 = arguments;\n        return _regeneratorRuntime().wrap(function _callee32$(_context32) {\n          while (1) {\n            switch (_context32.prev = _context32.next) {\n              case 0:\n                options = _args32.length > 1 && _args32[1] !== undefined ? _args32[1] : {};\n                options.conditions = options.conditions || {};\n                _createSpan28 = createSpan(\"BlockBlobClient-syncUploadFromURL\", options), span = _createSpan28.span, updatedOptions = _createSpan28.updatedOptions;\n                _context32.prev = 3;\n                ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n                _context32.next = 7;\n                return this.blockBlobContext.putBlobFromUrl(0, sourceURL, Object.assign(Object.assign(Object.assign({}, options), {\n                  blobHttpHeaders: options.blobHTTPHeaders,\n                  leaseAccessConditions: options.conditions,\n                  modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n                    ifTags: options.conditions.tagConditions\n                  }),\n                  sourceModifiedAccessConditions: {\n                    sourceIfMatch: (_a = options.sourceConditions) === null || _a === void 0 ? void 0 : _a.ifMatch,\n                    sourceIfModifiedSince: (_b = options.sourceConditions) === null || _b === void 0 ? void 0 : _b.ifModifiedSince,\n                    sourceIfNoneMatch: (_c = options.sourceConditions) === null || _c === void 0 ? void 0 : _c.ifNoneMatch,\n                    sourceIfUnmodifiedSince: (_d = options.sourceConditions) === null || _d === void 0 ? void 0 : _d.ifUnmodifiedSince,\n                    sourceIfTags: (_e = options.sourceConditions) === null || _e === void 0 ? void 0 : _e.tagConditions\n                  },\n                  cpkInfo: options.customerProvidedKey,\n                  copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization),\n                  tier: toAccessTier(options.tier),\n                  blobTagsString: toBlobTagsString(options.tags),\n                  copySourceTags: options.copySourceTags\n                }), convertTracingToRequestOptionsBase(updatedOptions)));\n              case 7:\n                return _context32.abrupt(\"return\", _context32.sent);\n              case 10:\n                _context32.prev = 10;\n                _context32.t0 = _context32[\"catch\"](3);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context32.t0.message\n                });\n                throw _context32.t0;\n              case 14:\n                _context32.prev = 14;\n                span.end();\n                return _context32.finish(14);\n              case 17:\n              case \"end\":\n                return _context32.stop();\n            }\n          }\n        }, _callee32, this, [[3, 10, 14, 17]]);\n      }));\n      function syncUploadFromURL(_x27) {\n        return _syncUploadFromURL.apply(this, arguments);\n      }\n      return syncUploadFromURL;\n    }()\n    /**\n     * Uploads the specified block to the block blob's \"staging area\" to be later\n     * committed by a call to commitBlockList.\n     * @see https://docs.microsoft.com/rest/api/storageservices/put-block\n     *\n     * @param blockId - A 64-byte value that is base64-encoded\n     * @param body - Data to upload to the staging area.\n     * @param contentLength - Number of bytes to upload.\n     * @param options - Options to the Block Blob Stage Block operation.\n     * @returns Response data for the Block Blob Stage Block operation.\n     */\n  }, {\n    key: \"stageBlock\",\n    value: function () {\n      var _stageBlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee33(blockId, body, contentLength) {\n        var options,\n          _createSpan29,\n          span,\n          updatedOptions,\n          _args33 = arguments;\n        return _regeneratorRuntime().wrap(function _callee33$(_context33) {\n          while (1) {\n            switch (_context33.prev = _context33.next) {\n              case 0:\n                options = _args33.length > 3 && _args33[3] !== undefined ? _args33[3] : {};\n                _createSpan29 = createSpan(\"BlockBlobClient-stageBlock\", options), span = _createSpan29.span, updatedOptions = _createSpan29.updatedOptions;\n                _context33.prev = 2;\n                ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n                _context33.next = 6;\n                return this.blockBlobContext.stageBlock(blockId, contentLength, body, Object.assign({\n                  abortSignal: options.abortSignal,\n                  leaseAccessConditions: options.conditions,\n                  requestOptions: {\n                    onUploadProgress: options.onProgress\n                  },\n                  transactionalContentMD5: options.transactionalContentMD5,\n                  transactionalContentCrc64: options.transactionalContentCrc64,\n                  cpkInfo: options.customerProvidedKey,\n                  encryptionScope: options.encryptionScope\n                }, convertTracingToRequestOptionsBase(updatedOptions)));\n              case 6:\n                return _context33.abrupt(\"return\", _context33.sent);\n              case 9:\n                _context33.prev = 9;\n                _context33.t0 = _context33[\"catch\"](2);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context33.t0.message\n                });\n                throw _context33.t0;\n              case 13:\n                _context33.prev = 13;\n                span.end();\n                return _context33.finish(13);\n              case 16:\n              case \"end\":\n                return _context33.stop();\n            }\n          }\n        }, _callee33, this, [[2, 9, 13, 16]]);\n      }));\n      function stageBlock(_x28, _x29, _x30) {\n        return _stageBlock.apply(this, arguments);\n      }\n      return stageBlock;\n    }()\n    /**\n     * The Stage Block From URL operation creates a new block to be committed as part\n     * of a blob where the contents are read from a URL.\n     * This API is available starting in version 2018-03-28.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/put-block-from-url\n     *\n     * @param blockId - A 64-byte value that is base64-encoded\n     * @param sourceURL - Specifies the URL of the blob. The value\n     *                           may be a URL of up to 2 KB in length that specifies a blob.\n     *                           The value should be URL-encoded as it would appear\n     *                           in a request URI. The source blob must either be public\n     *                           or must be authenticated via a shared access signature.\n     *                           If the source blob is public, no authentication is required\n     *                           to perform the operation. Here are some examples of source object URLs:\n     *                           - https://myaccount.blob.core.windows.net/mycontainer/myblob\n     *                           - https://myaccount.blob.core.windows.net/mycontainer/myblob?snapshot=<DateTime>\n     * @param offset - From which position of the blob to download, greater than or equal to 0\n     * @param count - How much data to be downloaded, greater than 0. Will download to the end when undefined\n     * @param options - Options to the Block Blob Stage Block From URL operation.\n     * @returns Response data for the Block Blob Stage Block From URL operation.\n     */\n  }, {\n    key: \"stageBlockFromURL\",\n    value: function () {\n      var _stageBlockFromURL = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee34(blockId, sourceURL) {\n        var offset,\n          count,\n          options,\n          _createSpan30,\n          span,\n          updatedOptions,\n          _args34 = arguments;\n        return _regeneratorRuntime().wrap(function _callee34$(_context34) {\n          while (1) {\n            switch (_context34.prev = _context34.next) {\n              case 0:\n                offset = _args34.length > 2 && _args34[2] !== undefined ? _args34[2] : 0;\n                count = _args34.length > 3 ? _args34[3] : undefined;\n                options = _args34.length > 4 && _args34[4] !== undefined ? _args34[4] : {};\n                _createSpan30 = createSpan(\"BlockBlobClient-stageBlockFromURL\", options), span = _createSpan30.span, updatedOptions = _createSpan30.updatedOptions;\n                _context34.prev = 4;\n                ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n                _context34.next = 8;\n                return this.blockBlobContext.stageBlockFromURL(blockId, 0, sourceURL, Object.assign({\n                  abortSignal: options.abortSignal,\n                  leaseAccessConditions: options.conditions,\n                  sourceContentMD5: options.sourceContentMD5,\n                  sourceContentCrc64: options.sourceContentCrc64,\n                  sourceRange: offset === 0 && !count ? undefined : rangeToString({\n                    offset: offset,\n                    count: count\n                  }),\n                  cpkInfo: options.customerProvidedKey,\n                  encryptionScope: options.encryptionScope,\n                  copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization)\n                }, convertTracingToRequestOptionsBase(updatedOptions)));\n              case 8:\n                return _context34.abrupt(\"return\", _context34.sent);\n              case 11:\n                _context34.prev = 11;\n                _context34.t0 = _context34[\"catch\"](4);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context34.t0.message\n                });\n                throw _context34.t0;\n              case 15:\n                _context34.prev = 15;\n                span.end();\n                return _context34.finish(15);\n              case 18:\n              case \"end\":\n                return _context34.stop();\n            }\n          }\n        }, _callee34, this, [[4, 11, 15, 18]]);\n      }));\n      function stageBlockFromURL(_x31, _x32) {\n        return _stageBlockFromURL.apply(this, arguments);\n      }\n      return stageBlockFromURL;\n    }()\n    /**\n     * Writes a blob by specifying the list of block IDs that make up the blob.\n     * In order to be written as part of a blob, a block must have been successfully written\n     * to the server in a prior {@link stageBlock} operation. You can call {@link commitBlockList} to\n     * update a blob by uploading only those blocks that have changed, then committing the new and existing\n     * blocks together. Any blocks not specified in the block list and permanently deleted.\n     * @see https://docs.microsoft.com/rest/api/storageservices/put-block-list\n     *\n     * @param blocks -  Array of 64-byte value that is base64-encoded\n     * @param options - Options to the Block Blob Commit Block List operation.\n     * @returns Response data for the Block Blob Commit Block List operation.\n     */\n  }, {\n    key: \"commitBlockList\",\n    value: function () {\n      var _commitBlockList = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee35(blocks) {\n        var options,\n          _a,\n          _b,\n          _c,\n          _createSpan31,\n          span,\n          updatedOptions,\n          _args35 = arguments;\n        return _regeneratorRuntime().wrap(function _callee35$(_context35) {\n          while (1) {\n            switch (_context35.prev = _context35.next) {\n              case 0:\n                options = _args35.length > 1 && _args35[1] !== undefined ? _args35[1] : {};\n                options.conditions = options.conditions || {};\n                _createSpan31 = createSpan(\"BlockBlobClient-commitBlockList\", options), span = _createSpan31.span, updatedOptions = _createSpan31.updatedOptions;\n                _context35.prev = 3;\n                ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n                _context35.next = 7;\n                return this.blockBlobContext.commitBlockList({\n                  latest: blocks\n                }, Object.assign({\n                  abortSignal: options.abortSignal,\n                  blobHttpHeaders: options.blobHTTPHeaders,\n                  leaseAccessConditions: options.conditions,\n                  metadata: options.metadata,\n                  modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n                    ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n                  }),\n                  cpkInfo: options.customerProvidedKey,\n                  encryptionScope: options.encryptionScope,\n                  immutabilityPolicyExpiry: (_b = options.immutabilityPolicy) === null || _b === void 0 ? void 0 : _b.expiriesOn,\n                  immutabilityPolicyMode: (_c = options.immutabilityPolicy) === null || _c === void 0 ? void 0 : _c.policyMode,\n                  legalHold: options.legalHold,\n                  tier: toAccessTier(options.tier),\n                  blobTagsString: toBlobTagsString(options.tags)\n                }, convertTracingToRequestOptionsBase(updatedOptions)));\n              case 7:\n                return _context35.abrupt(\"return\", _context35.sent);\n              case 10:\n                _context35.prev = 10;\n                _context35.t0 = _context35[\"catch\"](3);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context35.t0.message\n                });\n                throw _context35.t0;\n              case 14:\n                _context35.prev = 14;\n                span.end();\n                return _context35.finish(14);\n              case 17:\n              case \"end\":\n                return _context35.stop();\n            }\n          }\n        }, _callee35, this, [[3, 10, 14, 17]]);\n      }));\n      function commitBlockList(_x33) {\n        return _commitBlockList.apply(this, arguments);\n      }\n      return commitBlockList;\n    }()\n    /**\n     * Returns the list of blocks that have been uploaded as part of a block blob\n     * using the specified block list filter.\n     * @see https://docs.microsoft.com/rest/api/storageservices/get-block-list\n     *\n     * @param listType - Specifies whether to return the list of committed blocks,\n     *                                        the list of uncommitted blocks, or both lists together.\n     * @param options - Options to the Block Blob Get Block List operation.\n     * @returns Response data for the Block Blob Get Block List operation.\n     */\n  }, {\n    key: \"getBlockList\",\n    value: function () {\n      var _getBlockList = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee36(listType) {\n        var options,\n          _a,\n          _createSpan32,\n          span,\n          updatedOptions,\n          res,\n          _args36 = arguments;\n        return _regeneratorRuntime().wrap(function _callee36$(_context36) {\n          while (1) {\n            switch (_context36.prev = _context36.next) {\n              case 0:\n                options = _args36.length > 1 && _args36[1] !== undefined ? _args36[1] : {};\n                _createSpan32 = createSpan(\"BlockBlobClient-getBlockList\", options), span = _createSpan32.span, updatedOptions = _createSpan32.updatedOptions;\n                _context36.prev = 2;\n                _context36.next = 5;\n                return this.blockBlobContext.getBlockList(listType, Object.assign({\n                  abortSignal: options.abortSignal,\n                  leaseAccessConditions: options.conditions,\n                  modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n                    ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n                  })\n                }, convertTracingToRequestOptionsBase(updatedOptions)));\n              case 5:\n                res = _context36.sent;\n                if (!res.committedBlocks) {\n                  res.committedBlocks = [];\n                }\n                if (!res.uncommittedBlocks) {\n                  res.uncommittedBlocks = [];\n                }\n                return _context36.abrupt(\"return\", res);\n              case 11:\n                _context36.prev = 11;\n                _context36.t0 = _context36[\"catch\"](2);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context36.t0.message\n                });\n                throw _context36.t0;\n              case 15:\n                _context36.prev = 15;\n                span.end();\n                return _context36.finish(15);\n              case 18:\n              case \"end\":\n                return _context36.stop();\n            }\n          }\n        }, _callee36, this, [[2, 11, 15, 18]]);\n      }));\n      function getBlockList(_x34) {\n        return _getBlockList.apply(this, arguments);\n      }\n      return getBlockList;\n    }() // High level functions\n    /**\n     * Uploads a Buffer(Node.js)/Blob(browsers)/ArrayBuffer/ArrayBufferView object to a BlockBlob.\n     *\n     * When data length is no more than the specifiled {@link BlockBlobParallelUploadOptions.maxSingleShotSize} (default is\n     * {@link BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES}), this method will use 1 {@link upload} call to finish the upload.\n     * Otherwise, this method will call {@link stageBlock} to upload blocks, and finally call {@link commitBlockList}\n     * to commit the block list.\n     *\n     * A common {@link BlockBlobParallelUploadOptions.blobHTTPHeaders} option to set is\n     * `blobContentType`, enabling the browser to provide\n     * functionality based on file type.\n     *\n     * @param data - Buffer(Node.js), Blob, ArrayBuffer or ArrayBufferView\n     * @param options -\n     */\n  }, {\n    key: \"uploadData\",\n    value: function () {\n      var _uploadData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee37(data) {\n        var options,\n          _createSpan33,\n          span,\n          updatedOptions,\n          buffer,\n          browserBlob,\n          _args37 = arguments;\n        return _regeneratorRuntime().wrap(function _callee37$(_context37) {\n          while (1) {\n            switch (_context37.prev = _context37.next) {\n              case 0:\n                options = _args37.length > 1 && _args37[1] !== undefined ? _args37[1] : {};\n                _createSpan33 = createSpan(\"BlockBlobClient-uploadData\", options), span = _createSpan33.span, updatedOptions = _createSpan33.updatedOptions;\n                _context37.prev = 2;\n                if (!isNode) {\n                  _context37.next = 8;\n                  break;\n                }\n                if (data instanceof Buffer) {\n                  buffer = data;\n                } else if (data instanceof ArrayBuffer) {\n                  buffer = Buffer.from(data);\n                } else {\n                  data = data;\n                  buffer = Buffer.from(data.buffer, data.byteOffset, data.byteLength);\n                }\n                return _context37.abrupt(\"return\", this.uploadSeekableInternal(function (offset, size) {\n                  return buffer.slice(offset, offset + size);\n                }, buffer.byteLength, updatedOptions));\n              case 8:\n                browserBlob = new Blob([data]);\n                return _context37.abrupt(\"return\", this.uploadSeekableInternal(function (offset, size) {\n                  return browserBlob.slice(offset, offset + size);\n                }, browserBlob.size, updatedOptions));\n              case 10:\n                _context37.next = 16;\n                break;\n              case 12:\n                _context37.prev = 12;\n                _context37.t0 = _context37[\"catch\"](2);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context37.t0.message\n                });\n                throw _context37.t0;\n              case 16:\n                _context37.prev = 16;\n                span.end();\n                return _context37.finish(16);\n              case 19:\n              case \"end\":\n                return _context37.stop();\n            }\n          }\n        }, _callee37, this, [[2, 12, 16, 19]]);\n      }));\n      function uploadData(_x35) {\n        return _uploadData.apply(this, arguments);\n      }\n      return uploadData;\n    }()\n    /**\n     * ONLY AVAILABLE IN BROWSERS.\n     *\n     * Uploads a browser Blob/File/ArrayBuffer/ArrayBufferView object to block blob.\n     *\n     * When buffer length lesser than or equal to 256MB, this method will use 1 upload call to finish the upload.\n     * Otherwise, this method will call {@link stageBlock} to upload blocks, and finally call\n     * {@link commitBlockList} to commit the block list.\n     *\n     * A common {@link BlockBlobParallelUploadOptions.blobHTTPHeaders} option to set is\n     * `blobContentType`, enabling the browser to provide\n     * functionality based on file type.\n     *\n     * @deprecated Use {@link uploadData} instead.\n     *\n     * @param browserData - Blob, File, ArrayBuffer or ArrayBufferView\n     * @param options - Options to upload browser data.\n     * @returns Response data for the Blob Upload operation.\n     */\n  }, {\n    key: \"uploadBrowserData\",\n    value: function () {\n      var _uploadBrowserData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee38(browserData) {\n        var options,\n          _createSpan34,\n          span,\n          updatedOptions,\n          browserBlob,\n          _args38 = arguments;\n        return _regeneratorRuntime().wrap(function _callee38$(_context38) {\n          while (1) {\n            switch (_context38.prev = _context38.next) {\n              case 0:\n                options = _args38.length > 1 && _args38[1] !== undefined ? _args38[1] : {};\n                _createSpan34 = createSpan(\"BlockBlobClient-uploadBrowserData\", options), span = _createSpan34.span, updatedOptions = _createSpan34.updatedOptions;\n                _context38.prev = 2;\n                browserBlob = new Blob([browserData]);\n                _context38.next = 6;\n                return this.uploadSeekableInternal(function (offset, size) {\n                  return browserBlob.slice(offset, offset + size);\n                }, browserBlob.size, updatedOptions);\n              case 6:\n                return _context38.abrupt(\"return\", _context38.sent);\n              case 9:\n                _context38.prev = 9;\n                _context38.t0 = _context38[\"catch\"](2);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context38.t0.message\n                });\n                throw _context38.t0;\n              case 13:\n                _context38.prev = 13;\n                span.end();\n                return _context38.finish(13);\n              case 16:\n              case \"end\":\n                return _context38.stop();\n            }\n          }\n        }, _callee38, this, [[2, 9, 13, 16]]);\n      }));\n      function uploadBrowserData(_x36) {\n        return _uploadBrowserData.apply(this, arguments);\n      }\n      return uploadBrowserData;\n    }()\n    /**\n     *\n     * Uploads data to block blob. Requires a bodyFactory as the data source,\n     * which need to return a {@link HttpRequestBody} object with the offset and size provided.\n     *\n     * When data length is no more than the specified {@link BlockBlobParallelUploadOptions.maxSingleShotSize} (default is\n     * {@link BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES}), this method will use 1 {@link upload} call to finish the upload.\n     * Otherwise, this method will call {@link stageBlock} to upload blocks, and finally call {@link commitBlockList}\n     * to commit the block list.\n     *\n     * @param bodyFactory -\n     * @param size - size of the data to upload.\n     * @param options - Options to Upload to Block Blob operation.\n     * @returns Response data for the Blob Upload operation.\n     */\n  }, {\n    key: \"uploadSeekableInternal\",\n    value: function () {\n      var _uploadSeekableInternal = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee41(bodyFactory, size) {\n        var _this8 = this;\n        var options,\n          _createSpan35,\n          span,\n          updatedOptions,\n          _ret2,\n          _args41 = arguments;\n        return _regeneratorRuntime().wrap(function _callee41$(_context41) {\n          while (1) {\n            switch (_context41.prev = _context41.next) {\n              case 0:\n                options = _args41.length > 2 && _args41[2] !== undefined ? _args41[2] : {};\n                if (!options.blockSize) {\n                  options.blockSize = 0;\n                }\n                if (!(options.blockSize < 0 || options.blockSize > BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES)) {\n                  _context41.next = 4;\n                  break;\n                }\n                throw new RangeError(\"blockSize option must be >= 0 and <= \".concat(BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES));\n              case 4:\n                if (options.maxSingleShotSize !== 0 && !options.maxSingleShotSize) {\n                  options.maxSingleShotSize = BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES;\n                }\n                if (!(options.maxSingleShotSize < 0 || options.maxSingleShotSize > BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES)) {\n                  _context41.next = 7;\n                  break;\n                }\n                throw new RangeError(\"maxSingleShotSize option must be >= 0 and <= \".concat(BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES));\n              case 7:\n                if (!(options.blockSize === 0)) {\n                  _context41.next = 11;\n                  break;\n                }\n                if (!(size > BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES * BLOCK_BLOB_MAX_BLOCKS)) {\n                  _context41.next = 10;\n                  break;\n                }\n                throw new RangeError(\"\".concat(size, \" is too larger to upload to a block blob.\"));\n              case 10:\n                if (size > options.maxSingleShotSize) {\n                  options.blockSize = Math.ceil(size / BLOCK_BLOB_MAX_BLOCKS);\n                  if (options.blockSize < DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES) {\n                    options.blockSize = DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES;\n                  }\n                }\n              case 11:\n                if (!options.blobHTTPHeaders) {\n                  options.blobHTTPHeaders = {};\n                }\n                if (!options.conditions) {\n                  options.conditions = {};\n                }\n                _createSpan35 = createSpan(\"BlockBlobClient-uploadSeekableInternal\", options), span = _createSpan35.span, updatedOptions = _createSpan35.updatedOptions;\n                _context41.prev = 14;\n                return _context41.delegateYield( /*#__PURE__*/_regeneratorRuntime().mark(function _callee40() {\n                  var numBlocks, blockList, blockIDPrefix, transferProgress, batch, _loop2, i;\n                  return _regeneratorRuntime().wrap(function _callee40$(_context40) {\n                    while (1) {\n                      switch (_context40.prev = _context40.next) {\n                        case 0:\n                          if (!(size <= options.maxSingleShotSize)) {\n                            _context40.next = 5;\n                            break;\n                          }\n                          _context40.next = 3;\n                          return _this8.upload(bodyFactory(0, size), size, updatedOptions);\n                        case 3:\n                          _context40.t0 = _context40.sent;\n                          return _context40.abrupt(\"return\", {\n                            v: _context40.t0\n                          });\n                        case 5:\n                          numBlocks = Math.floor((size - 1) / options.blockSize) + 1;\n                          if (!(numBlocks > BLOCK_BLOB_MAX_BLOCKS)) {\n                            _context40.next = 8;\n                            break;\n                          }\n                          throw new RangeError(\"The buffer's size is too big or the BlockSize is too small;\" + \"the number of blocks must be <= \".concat(BLOCK_BLOB_MAX_BLOCKS));\n                        case 8:\n                          blockList = [];\n                          blockIDPrefix = generateUuid();\n                          transferProgress = 0;\n                          batch = new Batch(options.concurrency);\n                          _loop2 = function _loop2(i) {\n                            batch.addOperation( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee39() {\n                              var blockID, start, end, contentLength;\n                              return _regeneratorRuntime().wrap(function _callee39$(_context39) {\n                                while (1) {\n                                  switch (_context39.prev = _context39.next) {\n                                    case 0:\n                                      blockID = generateBlockID(blockIDPrefix, i);\n                                      start = options.blockSize * i;\n                                      end = i === numBlocks - 1 ? size : start + options.blockSize;\n                                      contentLength = end - start;\n                                      blockList.push(blockID);\n                                      _context39.next = 7;\n                                      return _this8.stageBlock(blockID, bodyFactory(start, contentLength), contentLength, {\n                                        abortSignal: options.abortSignal,\n                                        conditions: options.conditions,\n                                        encryptionScope: options.encryptionScope,\n                                        tracingOptions: updatedOptions.tracingOptions\n                                      });\n                                    case 7:\n                                      // Update progress after block is successfully uploaded to server, in case of block trying\n                                      // TODO: Hook with convenience layer progress event in finer level\n                                      transferProgress += contentLength;\n                                      if (options.onProgress) {\n                                        options.onProgress({\n                                          loadedBytes: transferProgress\n                                        });\n                                      }\n                                    case 9:\n                                    case \"end\":\n                                      return _context39.stop();\n                                  }\n                                }\n                              }, _callee39);\n                            })));\n                          };\n                          for (i = 0; i < numBlocks; i++) {\n                            _loop2(i);\n                          }\n                          _context40.next = 16;\n                          return batch.do();\n                        case 16:\n                          return _context40.abrupt(\"return\", {\n                            v: _this8.commitBlockList(blockList, updatedOptions)\n                          });\n                        case 17:\n                        case \"end\":\n                          return _context40.stop();\n                      }\n                    }\n                  }, _callee40);\n                })(), \"t0\", 16);\n              case 16:\n                _ret2 = _context41.t0;\n                if (!(typeof _ret2 === \"object\")) {\n                  _context41.next = 19;\n                  break;\n                }\n                return _context41.abrupt(\"return\", _ret2.v);\n              case 19:\n                _context41.next = 25;\n                break;\n              case 21:\n                _context41.prev = 21;\n                _context41.t1 = _context41[\"catch\"](14);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context41.t1.message\n                });\n                throw _context41.t1;\n              case 25:\n                _context41.prev = 25;\n                span.end();\n                return _context41.finish(25);\n              case 28:\n              case \"end\":\n                return _context41.stop();\n            }\n          }\n        }, _callee41, null, [[14, 21, 25, 28]]);\n      }));\n      function uploadSeekableInternal(_x37, _x38) {\n        return _uploadSeekableInternal.apply(this, arguments);\n      }\n      return uploadSeekableInternal;\n    }()\n    /**\n     * ONLY AVAILABLE IN NODE.JS RUNTIME.\n     *\n     * Uploads a local file in blocks to a block blob.\n     *\n     * When file size lesser than or equal to 256MB, this method will use 1 upload call to finish the upload.\n     * Otherwise, this method will call stageBlock to upload blocks, and finally call commitBlockList\n     * to commit the block list.\n     *\n     * @param filePath - Full path of local file\n     * @param options - Options to Upload to Block Blob operation.\n     * @returns Response data for the Blob Upload operation.\n     */\n  }, {\n    key: \"uploadFile\",\n    value: function () {\n      var _uploadFile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee42(filePath) {\n        var options,\n          _createSpan36,\n          span,\n          updatedOptions,\n          size,\n          _args42 = arguments;\n        return _regeneratorRuntime().wrap(function _callee42$(_context42) {\n          while (1) {\n            switch (_context42.prev = _context42.next) {\n              case 0:\n                options = _args42.length > 1 && _args42[1] !== undefined ? _args42[1] : {};\n                _createSpan36 = createSpan(\"BlockBlobClient-uploadFile\", options), span = _createSpan36.span, updatedOptions = _createSpan36.updatedOptions;\n                _context42.prev = 2;\n                _context42.next = 5;\n                return fsStat(filePath);\n              case 5:\n                size = _context42.sent.size;\n                _context42.next = 8;\n                return this.uploadSeekableInternal(function (offset, count) {\n                  return function () {\n                    return fsCreateReadStream(filePath, {\n                      autoClose: true,\n                      end: count ? offset + count - 1 : Infinity,\n                      start: offset\n                    });\n                  };\n                }, size, Object.assign(Object.assign({}, options), {\n                  tracingOptions: Object.assign(Object.assign({}, options.tracingOptions), convertTracingToRequestOptionsBase(updatedOptions))\n                }));\n              case 8:\n                return _context42.abrupt(\"return\", _context42.sent);\n              case 11:\n                _context42.prev = 11;\n                _context42.t0 = _context42[\"catch\"](2);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context42.t0.message\n                });\n                throw _context42.t0;\n              case 15:\n                _context42.prev = 15;\n                span.end();\n                return _context42.finish(15);\n              case 18:\n              case \"end\":\n                return _context42.stop();\n            }\n          }\n        }, _callee42, this, [[2, 11, 15, 18]]);\n      }));\n      function uploadFile(_x39) {\n        return _uploadFile.apply(this, arguments);\n      }\n      return uploadFile;\n    }()\n    /**\n     * ONLY AVAILABLE IN NODE.JS RUNTIME.\n     *\n     * Uploads a Node.js Readable stream into block blob.\n     *\n     * PERFORMANCE IMPROVEMENT TIPS:\n     * * Input stream highWaterMark is better to set a same value with bufferSize\n     *    parameter, which will avoid Buffer.concat() operations.\n     *\n     * @param stream - Node.js Readable stream\n     * @param bufferSize - Size of every buffer allocated, also the block size in the uploaded block blob. Default value is 8MB\n     * @param maxConcurrency -  Max concurrency indicates the max number of buffers that can be allocated,\n     *                                 positive correlation with max uploading concurrency. Default value is 5\n     * @param options - Options to Upload Stream to Block Blob operation.\n     * @returns Response data for the Blob Upload operation.\n     */\n  }, {\n    key: \"uploadStream\",\n    value: function () {\n      var _uploadStream = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee44(stream) {\n        var _this9 = this;\n        var bufferSize,\n          maxConcurrency,\n          options,\n          _createSpan37,\n          span,\n          updatedOptions,\n          blockNum,\n          _blockIDPrefix,\n          _transferProgress,\n          _blockList,\n          scheduler,\n          _args44 = arguments;\n        return _regeneratorRuntime().wrap(function _callee44$(_context44) {\n          while (1) {\n            switch (_context44.prev = _context44.next) {\n              case 0:\n                bufferSize = _args44.length > 1 && _args44[1] !== undefined ? _args44[1] : DEFAULT_BLOCK_BUFFER_SIZE_BYTES;\n                maxConcurrency = _args44.length > 2 && _args44[2] !== undefined ? _args44[2] : 5;\n                options = _args44.length > 3 && _args44[3] !== undefined ? _args44[3] : {};\n                if (!options.blobHTTPHeaders) {\n                  options.blobHTTPHeaders = {};\n                }\n                if (!options.conditions) {\n                  options.conditions = {};\n                }\n                _createSpan37 = createSpan(\"BlockBlobClient-uploadStream\", options), span = _createSpan37.span, updatedOptions = _createSpan37.updatedOptions;\n                _context44.prev = 6;\n                blockNum = 0;\n                _blockIDPrefix = generateUuid();\n                _transferProgress = 0;\n                _blockList = [];\n                scheduler = new BufferScheduler(stream, bufferSize, maxConcurrency, /*#__PURE__*/function () {\n                  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee43(body, length) {\n                    var blockID;\n                    return _regeneratorRuntime().wrap(function _callee43$(_context43) {\n                      while (1) {\n                        switch (_context43.prev = _context43.next) {\n                          case 0:\n                            blockID = generateBlockID(_blockIDPrefix, blockNum);\n                            _blockList.push(blockID);\n                            blockNum++;\n                            _context43.next = 5;\n                            return _this9.stageBlock(blockID, body, length, {\n                              conditions: options.conditions,\n                              encryptionScope: options.encryptionScope,\n                              tracingOptions: updatedOptions.tracingOptions\n                            });\n                          case 5:\n                            // Update progress after block is successfully uploaded to server, in case of block trying\n                            _transferProgress += length;\n                            if (options.onProgress) {\n                              options.onProgress({\n                                loadedBytes: _transferProgress\n                              });\n                            }\n                          case 7:\n                          case \"end\":\n                            return _context43.stop();\n                        }\n                      }\n                    }, _callee43);\n                  }));\n                  return function (_x41, _x42) {\n                    return _ref4.apply(this, arguments);\n                  };\n                }(),\n                // concurrency should set a smaller value than maxConcurrency, which is helpful to\n                // reduce the possibility when a outgoing handler waits for stream data, in\n                // this situation, outgoing handlers are blocked.\n                // Outgoing queue shouldn't be empty.\n                Math.ceil(maxConcurrency / 4 * 3));\n                _context44.next = 14;\n                return scheduler.do();\n              case 14:\n                _context44.next = 16;\n                return this.commitBlockList(_blockList, Object.assign(Object.assign({}, options), {\n                  tracingOptions: Object.assign(Object.assign({}, options.tracingOptions), convertTracingToRequestOptionsBase(updatedOptions))\n                }));\n              case 16:\n                return _context44.abrupt(\"return\", _context44.sent);\n              case 19:\n                _context44.prev = 19;\n                _context44.t0 = _context44[\"catch\"](6);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context44.t0.message\n                });\n                throw _context44.t0;\n              case 23:\n                _context44.prev = 23;\n                span.end();\n                return _context44.finish(23);\n              case 26:\n              case \"end\":\n                return _context44.stop();\n            }\n          }\n        }, _callee44, this, [[6, 19, 23, 26]]);\n      }));\n      function uploadStream(_x40) {\n        return _uploadStream.apply(this, arguments);\n      }\n      return uploadStream;\n    }()\n  }]);\n  return BlockBlobClient;\n}(BlobClient);\n/**\n * PageBlobClient defines a set of operations applicable to page blobs.\n */\nexport var PageBlobClient = /*#__PURE__*/function (_BlobClient3) {\n  _inherits(PageBlobClient, _BlobClient3);\n  var _super4 = _createSuper(PageBlobClient);\n  function PageBlobClient(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions,\n  // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n  /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n  options) {\n    var _this10;\n    _classCallCheck(this, PageBlobClient);\n    // In TypeScript we cannot simply pass all parameters to super() like below so have to duplicate the code instead.\n    //   super(s, credentialOrPipelineOrContainerNameOrOptions, blobNameOrOptions, options);\n    var pipeline;\n    var url;\n    options = options || {};\n    if (isPipelineLike(credentialOrPipelineOrContainerName)) {\n      // (url: string, pipeline: Pipeline)\n      url = urlOrConnectionString;\n      pipeline = credentialOrPipelineOrContainerName;\n    } else if (isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential || isTokenCredential(credentialOrPipelineOrContainerName)) {\n      // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n      url = urlOrConnectionString;\n      options = blobNameOrOptions;\n      pipeline = newPipeline(credentialOrPipelineOrContainerName, options);\n    } else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== \"string\") {\n      // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n      // The second parameter is undefined. Use anonymous credential.\n      url = urlOrConnectionString;\n      pipeline = newPipeline(new AnonymousCredential(), options);\n    } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === \"string\" && blobNameOrOptions && typeof blobNameOrOptions === \"string\") {\n      // (connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions)\n      var containerName = credentialOrPipelineOrContainerName;\n      var blobName = blobNameOrOptions;\n      var extractedCreds = extractConnectionStringParts(urlOrConnectionString);\n      if (extractedCreds.kind === \"AccountConnString\") {\n        if (isNode) {\n          var sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);\n          url = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));\n          if (!options.proxyOptions) {\n            options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);\n          }\n          pipeline = newPipeline(sharedKeyCredential, options);\n        } else {\n          throw new Error(\"Account connection string is only supported in Node.js environment\");\n        }\n      } else if (extractedCreds.kind === \"SASConnString\") {\n        url = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + \"?\" + extractedCreds.accountSas;\n        pipeline = newPipeline(new AnonymousCredential(), options);\n      } else {\n        throw new Error(\"Connection string must be either an Account connection string or a SAS connection string\");\n      }\n    } else {\n      throw new Error(\"Expecting non-empty strings for containerName and blobName parameters\");\n    }\n    _this10 = _super4.call(this, url, pipeline);\n    _this10.pageBlobContext = new PageBlob(_this10.storageClientContext);\n    return _this10;\n  }\n  /**\n   * Creates a new PageBlobClient object identical to the source but with the\n   * specified snapshot timestamp.\n   * Provide \"\" will remove the snapshot and return a Client to the base blob.\n   *\n   * @param snapshot - The snapshot timestamp.\n   * @returns A new PageBlobClient object identical to the source but with the specified snapshot timestamp.\n   */\n  _createClass(PageBlobClient, [{\n    key: \"withSnapshot\",\n    value: function withSnapshot(snapshot) {\n      return new PageBlobClient(setURLParameter(this.url, URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? undefined : snapshot), this.pipeline);\n    }\n    /**\n     * Creates a page blob of the specified length. Call uploadPages to upload data\n     * data to a page blob.\n     * @see https://docs.microsoft.com/rest/api/storageservices/put-blob\n     *\n     * @param size - size of the page blob.\n     * @param options - Options to the Page Blob Create operation.\n     * @returns Response data for the Page Blob Create operation.\n     */\n  }, {\n    key: \"create\",\n    value: function () {\n      var _create2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee45(size) {\n        var options,\n          _a,\n          _b,\n          _c,\n          _createSpan38,\n          span,\n          updatedOptions,\n          _args45 = arguments;\n        return _regeneratorRuntime().wrap(function _callee45$(_context45) {\n          while (1) {\n            switch (_context45.prev = _context45.next) {\n              case 0:\n                options = _args45.length > 1 && _args45[1] !== undefined ? _args45[1] : {};\n                options.conditions = options.conditions || {};\n                _createSpan38 = createSpan(\"PageBlobClient-create\", options), span = _createSpan38.span, updatedOptions = _createSpan38.updatedOptions;\n                _context45.prev = 3;\n                ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n                _context45.next = 7;\n                return this.pageBlobContext.create(0, size, Object.assign({\n                  abortSignal: options.abortSignal,\n                  blobHttpHeaders: options.blobHTTPHeaders,\n                  blobSequenceNumber: options.blobSequenceNumber,\n                  leaseAccessConditions: options.conditions,\n                  metadata: options.metadata,\n                  modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n                    ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n                  }),\n                  cpkInfo: options.customerProvidedKey,\n                  encryptionScope: options.encryptionScope,\n                  immutabilityPolicyExpiry: (_b = options.immutabilityPolicy) === null || _b === void 0 ? void 0 : _b.expiriesOn,\n                  immutabilityPolicyMode: (_c = options.immutabilityPolicy) === null || _c === void 0 ? void 0 : _c.policyMode,\n                  legalHold: options.legalHold,\n                  tier: toAccessTier(options.tier),\n                  blobTagsString: toBlobTagsString(options.tags)\n                }, convertTracingToRequestOptionsBase(updatedOptions)));\n              case 7:\n                return _context45.abrupt(\"return\", _context45.sent);\n              case 10:\n                _context45.prev = 10;\n                _context45.t0 = _context45[\"catch\"](3);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context45.t0.message\n                });\n                throw _context45.t0;\n              case 14:\n                _context45.prev = 14;\n                span.end();\n                return _context45.finish(14);\n              case 17:\n              case \"end\":\n                return _context45.stop();\n            }\n          }\n        }, _callee45, this, [[3, 10, 14, 17]]);\n      }));\n      function create(_x43) {\n        return _create2.apply(this, arguments);\n      }\n      return create;\n    }()\n    /**\n     * Creates a page blob of the specified length. Call uploadPages to upload data\n     * data to a page blob. If the blob with the same name already exists, the content\n     * of the existing blob will remain unchanged.\n     * @see https://docs.microsoft.com/rest/api/storageservices/put-blob\n     *\n     * @param size - size of the page blob.\n     * @param options -\n     */\n  }, {\n    key: \"createIfNotExists\",\n    value: function () {\n      var _createIfNotExists2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee46(size) {\n        var options,\n          _a,\n          _b,\n          _createSpan39,\n          span,\n          updatedOptions,\n          conditions,\n          res,\n          _args46 = arguments;\n        return _regeneratorRuntime().wrap(function _callee46$(_context46) {\n          while (1) {\n            switch (_context46.prev = _context46.next) {\n              case 0:\n                options = _args46.length > 1 && _args46[1] !== undefined ? _args46[1] : {};\n                _createSpan39 = createSpan(\"PageBlobClient-createIfNotExists\", options), span = _createSpan39.span, updatedOptions = _createSpan39.updatedOptions;\n                _context46.prev = 2;\n                conditions = {\n                  ifNoneMatch: ETagAny\n                };\n                _context46.next = 6;\n                return this.create(size, Object.assign(Object.assign({}, options), {\n                  conditions: conditions,\n                  tracingOptions: updatedOptions.tracingOptions\n                }));\n              case 6:\n                res = _context46.sent;\n                return _context46.abrupt(\"return\", Object.assign(Object.assign({\n                  succeeded: true\n                }, res), {\n                  _response: res._response\n                }));\n              case 10:\n                _context46.prev = 10;\n                _context46.t0 = _context46[\"catch\"](2);\n                if (!(((_a = _context46.t0.details) === null || _a === void 0 ? void 0 : _a.errorCode) === \"BlobAlreadyExists\")) {\n                  _context46.next = 15;\n                  break;\n                }\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: \"Expected exception when creating a blob only if it does not already exist.\"\n                });\n                return _context46.abrupt(\"return\", Object.assign(Object.assign({\n                  succeeded: false\n                }, (_b = _context46.t0.response) === null || _b === void 0 ? void 0 : _b.parsedHeaders), {\n                  _response: _context46.t0.response\n                }));\n              case 15:\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context46.t0.message\n                });\n                throw _context46.t0;\n              case 17:\n                _context46.prev = 17;\n                span.end();\n                return _context46.finish(17);\n              case 20:\n              case \"end\":\n                return _context46.stop();\n            }\n          }\n        }, _callee46, this, [[2, 10, 17, 20]]);\n      }));\n      function createIfNotExists(_x44) {\n        return _createIfNotExists2.apply(this, arguments);\n      }\n      return createIfNotExists;\n    }()\n    /**\n     * Writes 1 or more pages to the page blob. The start and end offsets must be a multiple of 512.\n     * @see https://docs.microsoft.com/rest/api/storageservices/put-page\n     *\n     * @param body - Data to upload\n     * @param offset - Offset of destination page blob\n     * @param count - Content length of the body, also number of bytes to be uploaded\n     * @param options - Options to the Page Blob Upload Pages operation.\n     * @returns Response data for the Page Blob Upload Pages operation.\n     */\n  }, {\n    key: \"uploadPages\",\n    value: function () {\n      var _uploadPages = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee47(body, offset, count) {\n        var options,\n          _a,\n          _createSpan40,\n          span,\n          updatedOptions,\n          _args47 = arguments;\n        return _regeneratorRuntime().wrap(function _callee47$(_context47) {\n          while (1) {\n            switch (_context47.prev = _context47.next) {\n              case 0:\n                options = _args47.length > 3 && _args47[3] !== undefined ? _args47[3] : {};\n                options.conditions = options.conditions || {};\n                _createSpan40 = createSpan(\"PageBlobClient-uploadPages\", options), span = _createSpan40.span, updatedOptions = _createSpan40.updatedOptions;\n                _context47.prev = 3;\n                ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n                _context47.next = 7;\n                return this.pageBlobContext.uploadPages(count, body, Object.assign({\n                  abortSignal: options.abortSignal,\n                  leaseAccessConditions: options.conditions,\n                  modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n                    ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n                  }),\n                  requestOptions: {\n                    onUploadProgress: options.onProgress\n                  },\n                  range: rangeToString({\n                    offset: offset,\n                    count: count\n                  }),\n                  sequenceNumberAccessConditions: options.conditions,\n                  transactionalContentMD5: options.transactionalContentMD5,\n                  transactionalContentCrc64: options.transactionalContentCrc64,\n                  cpkInfo: options.customerProvidedKey,\n                  encryptionScope: options.encryptionScope\n                }, convertTracingToRequestOptionsBase(updatedOptions)));\n              case 7:\n                return _context47.abrupt(\"return\", _context47.sent);\n              case 10:\n                _context47.prev = 10;\n                _context47.t0 = _context47[\"catch\"](3);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context47.t0.message\n                });\n                throw _context47.t0;\n              case 14:\n                _context47.prev = 14;\n                span.end();\n                return _context47.finish(14);\n              case 17:\n              case \"end\":\n                return _context47.stop();\n            }\n          }\n        }, _callee47, this, [[3, 10, 14, 17]]);\n      }));\n      function uploadPages(_x45, _x46, _x47) {\n        return _uploadPages.apply(this, arguments);\n      }\n      return uploadPages;\n    }()\n    /**\n     * The Upload Pages operation writes a range of pages to a page blob where the\n     * contents are read from a URL.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/put-page-from-url\n     *\n     * @param sourceURL - Specify a URL to the copy source, Shared Access Signature(SAS) maybe needed for authentication\n     * @param sourceOffset - The source offset to copy from. Pass 0 to copy from the beginning of source page blob\n     * @param destOffset - Offset of destination page blob\n     * @param count - Number of bytes to be uploaded from source page blob\n     * @param options -\n     */\n  }, {\n    key: \"uploadPagesFromURL\",\n    value: function () {\n      var _uploadPagesFromURL = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee48(sourceURL, sourceOffset, destOffset, count) {\n        var options,\n          _a,\n          _createSpan41,\n          span,\n          updatedOptions,\n          _args48 = arguments;\n        return _regeneratorRuntime().wrap(function _callee48$(_context48) {\n          while (1) {\n            switch (_context48.prev = _context48.next) {\n              case 0:\n                options = _args48.length > 4 && _args48[4] !== undefined ? _args48[4] : {};\n                options.conditions = options.conditions || {};\n                options.sourceConditions = options.sourceConditions || {};\n                _createSpan41 = createSpan(\"PageBlobClient-uploadPagesFromURL\", options), span = _createSpan41.span, updatedOptions = _createSpan41.updatedOptions;\n                _context48.prev = 4;\n                ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n                _context48.next = 8;\n                return this.pageBlobContext.uploadPagesFromURL(sourceURL, rangeToString({\n                  offset: sourceOffset,\n                  count: count\n                }), 0, rangeToString({\n                  offset: destOffset,\n                  count: count\n                }), Object.assign({\n                  abortSignal: options.abortSignal,\n                  sourceContentMD5: options.sourceContentMD5,\n                  sourceContentCrc64: options.sourceContentCrc64,\n                  leaseAccessConditions: options.conditions,\n                  sequenceNumberAccessConditions: options.conditions,\n                  modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n                    ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n                  }),\n                  sourceModifiedAccessConditions: {\n                    sourceIfMatch: options.sourceConditions.ifMatch,\n                    sourceIfModifiedSince: options.sourceConditions.ifModifiedSince,\n                    sourceIfNoneMatch: options.sourceConditions.ifNoneMatch,\n                    sourceIfUnmodifiedSince: options.sourceConditions.ifUnmodifiedSince\n                  },\n                  cpkInfo: options.customerProvidedKey,\n                  encryptionScope: options.encryptionScope,\n                  copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization)\n                }, convertTracingToRequestOptionsBase(updatedOptions)));\n              case 8:\n                return _context48.abrupt(\"return\", _context48.sent);\n              case 11:\n                _context48.prev = 11;\n                _context48.t0 = _context48[\"catch\"](4);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context48.t0.message\n                });\n                throw _context48.t0;\n              case 15:\n                _context48.prev = 15;\n                span.end();\n                return _context48.finish(15);\n              case 18:\n              case \"end\":\n                return _context48.stop();\n            }\n          }\n        }, _callee48, this, [[4, 11, 15, 18]]);\n      }));\n      function uploadPagesFromURL(_x48, _x49, _x50, _x51) {\n        return _uploadPagesFromURL.apply(this, arguments);\n      }\n      return uploadPagesFromURL;\n    }()\n    /**\n     * Frees the specified pages from the page blob.\n     * @see https://docs.microsoft.com/rest/api/storageservices/put-page\n     *\n     * @param offset - Starting byte position of the pages to clear.\n     * @param count - Number of bytes to clear.\n     * @param options - Options to the Page Blob Clear Pages operation.\n     * @returns Response data for the Page Blob Clear Pages operation.\n     */\n  }, {\n    key: \"clearPages\",\n    value: function () {\n      var _clearPages = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee49() {\n        var offset,\n          count,\n          options,\n          _a,\n          _createSpan42,\n          span,\n          updatedOptions,\n          _args49 = arguments;\n        return _regeneratorRuntime().wrap(function _callee49$(_context49) {\n          while (1) {\n            switch (_context49.prev = _context49.next) {\n              case 0:\n                offset = _args49.length > 0 && _args49[0] !== undefined ? _args49[0] : 0;\n                count = _args49.length > 1 ? _args49[1] : undefined;\n                options = _args49.length > 2 && _args49[2] !== undefined ? _args49[2] : {};\n                options.conditions = options.conditions || {};\n                _createSpan42 = createSpan(\"PageBlobClient-clearPages\", options), span = _createSpan42.span, updatedOptions = _createSpan42.updatedOptions;\n                _context49.prev = 5;\n                _context49.next = 8;\n                return this.pageBlobContext.clearPages(0, Object.assign({\n                  abortSignal: options.abortSignal,\n                  leaseAccessConditions: options.conditions,\n                  modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n                    ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n                  }),\n                  range: rangeToString({\n                    offset: offset,\n                    count: count\n                  }),\n                  sequenceNumberAccessConditions: options.conditions,\n                  cpkInfo: options.customerProvidedKey,\n                  encryptionScope: options.encryptionScope\n                }, convertTracingToRequestOptionsBase(updatedOptions)));\n              case 8:\n                return _context49.abrupt(\"return\", _context49.sent);\n              case 11:\n                _context49.prev = 11;\n                _context49.t0 = _context49[\"catch\"](5);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context49.t0.message\n                });\n                throw _context49.t0;\n              case 15:\n                _context49.prev = 15;\n                span.end();\n                return _context49.finish(15);\n              case 18:\n              case \"end\":\n                return _context49.stop();\n            }\n          }\n        }, _callee49, this, [[5, 11, 15, 18]]);\n      }));\n      function clearPages() {\n        return _clearPages.apply(this, arguments);\n      }\n      return clearPages;\n    }()\n    /**\n     * Returns the list of valid page ranges for a page blob or snapshot of a page blob.\n     * @see https://docs.microsoft.com/rest/api/storageservices/get-page-ranges\n     *\n     * @param offset - Starting byte position of the page ranges.\n     * @param count - Number of bytes to get.\n     * @param options - Options to the Page Blob Get Ranges operation.\n     * @returns Response data for the Page Blob Get Ranges operation.\n     */\n  }, {\n    key: \"getPageRanges\",\n    value: function () {\n      var _getPageRanges = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee50() {\n        var offset,\n          count,\n          options,\n          _a,\n          _createSpan43,\n          span,\n          updatedOptions,\n          _args50 = arguments;\n        return _regeneratorRuntime().wrap(function _callee50$(_context50) {\n          while (1) {\n            switch (_context50.prev = _context50.next) {\n              case 0:\n                offset = _args50.length > 0 && _args50[0] !== undefined ? _args50[0] : 0;\n                count = _args50.length > 1 ? _args50[1] : undefined;\n                options = _args50.length > 2 && _args50[2] !== undefined ? _args50[2] : {};\n                options.conditions = options.conditions || {};\n                _createSpan43 = createSpan(\"PageBlobClient-getPageRanges\", options), span = _createSpan43.span, updatedOptions = _createSpan43.updatedOptions;\n                _context50.prev = 5;\n                _context50.next = 8;\n                return this.pageBlobContext.getPageRanges(Object.assign({\n                  abortSignal: options.abortSignal,\n                  leaseAccessConditions: options.conditions,\n                  modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n                    ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n                  }),\n                  range: rangeToString({\n                    offset: offset,\n                    count: count\n                  })\n                }, convertTracingToRequestOptionsBase(updatedOptions))).then(rangeResponseFromModel);\n              case 8:\n                return _context50.abrupt(\"return\", _context50.sent);\n              case 11:\n                _context50.prev = 11;\n                _context50.t0 = _context50[\"catch\"](5);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context50.t0.message\n                });\n                throw _context50.t0;\n              case 15:\n                _context50.prev = 15;\n                span.end();\n                return _context50.finish(15);\n              case 18:\n              case \"end\":\n                return _context50.stop();\n            }\n          }\n        }, _callee50, this, [[5, 11, 15, 18]]);\n      }));\n      function getPageRanges() {\n        return _getPageRanges.apply(this, arguments);\n      }\n      return getPageRanges;\n    }()\n    /**\n     * getPageRangesSegment returns a single segment of page ranges starting from the\n     * specified Marker. Use an empty Marker to start enumeration from the beginning.\n     * After getting a segment, process it, and then call getPageRangesSegment again\n     * (passing the the previously-returned Marker) to get the next segment.\n     * @see https://docs.microsoft.com/rest/api/storageservices/get-page-ranges\n     *\n     * @param offset - Starting byte position of the page ranges.\n     * @param count - Number of bytes to get.\n     * @param marker - A string value that identifies the portion of the list to be returned with the next list operation.\n     * @param options - Options to PageBlob Get Page Ranges Segment operation.\n     */\n  }, {\n    key: \"listPageRangesSegment\",\n    value: function () {\n      var _listPageRangesSegment = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee51() {\n        var offset,\n          count,\n          marker,\n          options,\n          _a,\n          _createSpan44,\n          span,\n          updatedOptions,\n          _args51 = arguments;\n        return _regeneratorRuntime().wrap(function _callee51$(_context51) {\n          while (1) {\n            switch (_context51.prev = _context51.next) {\n              case 0:\n                offset = _args51.length > 0 && _args51[0] !== undefined ? _args51[0] : 0;\n                count = _args51.length > 1 ? _args51[1] : undefined;\n                marker = _args51.length > 2 ? _args51[2] : undefined;\n                options = _args51.length > 3 && _args51[3] !== undefined ? _args51[3] : {};\n                _createSpan44 = createSpan(\"PageBlobClient-getPageRangesSegment\", options), span = _createSpan44.span, updatedOptions = _createSpan44.updatedOptions;\n                _context51.prev = 5;\n                _context51.next = 8;\n                return this.pageBlobContext.getPageRanges(Object.assign({\n                  abortSignal: options.abortSignal,\n                  leaseAccessConditions: options.conditions,\n                  modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n                    ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n                  }),\n                  range: rangeToString({\n                    offset: offset,\n                    count: count\n                  }),\n                  marker: marker,\n                  maxPageSize: options.maxPageSize\n                }, convertTracingToRequestOptionsBase(updatedOptions)));\n              case 8:\n                return _context51.abrupt(\"return\", _context51.sent);\n              case 11:\n                _context51.prev = 11;\n                _context51.t0 = _context51[\"catch\"](5);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context51.t0.message\n                });\n                throw _context51.t0;\n              case 15:\n                _context51.prev = 15;\n                span.end();\n                return _context51.finish(15);\n              case 18:\n              case \"end\":\n                return _context51.stop();\n            }\n          }\n        }, _callee51, this, [[5, 11, 15, 18]]);\n      }));\n      function listPageRangesSegment() {\n        return _listPageRangesSegment.apply(this, arguments);\n      }\n      return listPageRangesSegment;\n    }()\n    /**\n     * Returns an AsyncIterableIterator for {@link PageBlobGetPageRangesResponseModel}\n     *\n     * @param offset - Starting byte position of the page ranges.\n     * @param count - Number of bytes to get.\n     * @param marker - A string value that identifies the portion of\n     *                          the get of page ranges to be returned with the next getting operation. The\n     *                          operation returns the ContinuationToken value within the response body if the\n     *                          getting operation did not return all page ranges remaining within the current page.\n     *                          The ContinuationToken value can be used as the value for\n     *                          the marker parameter in a subsequent call to request the next page of get\n     *                          items. The marker value is opaque to the client.\n     * @param options - Options to List Page Ranges operation.\n     */\n  }, {\n    key: \"listPageRangeItemSegments\",\n    value: function listPageRangeItemSegments() {\n      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var count = arguments.length > 1 ? arguments[1] : undefined;\n      var marker = arguments.length > 2 ? arguments[2] : undefined;\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      return __asyncGenerator(this, arguments, /*#__PURE__*/_regeneratorRuntime().mark(function listPageRangeItemSegments_1() {\n        var getPageRangeItemSegmentsResponse;\n        return _regeneratorRuntime().wrap(function listPageRangeItemSegments_1$(_context52) {\n          while (1) {\n            switch (_context52.prev = _context52.next) {\n              case 0:\n                if (!(!!marker || marker === undefined)) {\n                  _context52.next = 14;\n                  break;\n                }\n              case 1:\n                _context52.next = 3;\n                return __await(this.listPageRangesSegment(offset, count, marker, options));\n              case 3:\n                getPageRangeItemSegmentsResponse = _context52.sent;\n                marker = getPageRangeItemSegmentsResponse.continuationToken;\n                _context52.t0 = __await;\n                _context52.next = 8;\n                return __await(getPageRangeItemSegmentsResponse);\n              case 8:\n                _context52.t1 = _context52.sent;\n                _context52.next = 11;\n                return (0, _context52.t0)(_context52.t1);\n              case 11:\n                _context52.next = 13;\n                return _context52.sent;\n              case 13:\n                if (marker) {\n                  _context52.next = 1;\n                  break;\n                }\n              case 14:\n              case \"end\":\n                return _context52.stop();\n            }\n          }\n        }, listPageRangeItemSegments_1, this);\n      }));\n    }\n    /**\n     * Returns an AsyncIterableIterator of {@link PageRangeInfo} objects\n     *\n     * @param offset - Starting byte position of the page ranges.\n     * @param count - Number of bytes to get.\n     * @param options - Options to List Page Ranges operation.\n     */\n  }, {\n    key: \"listPageRangeItems\",\n    value: function listPageRangeItems() {\n      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var count = arguments.length > 1 ? arguments[1] : undefined;\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return __asyncGenerator(this, arguments, /*#__PURE__*/_regeneratorRuntime().mark(function listPageRangeItems_1() {\n        var e_1, _a, marker, _b, _c, getPageRangesSegment;\n        return _regeneratorRuntime().wrap(function listPageRangeItems_1$(_context53) {\n          while (1) {\n            switch (_context53.prev = _context53.next) {\n              case 0:\n                _context53.prev = 0;\n                _b = __asyncValues(this.listPageRangeItemSegments(offset, count, marker, options));\n              case 2:\n                _context53.next = 4;\n                return __await(_b.next());\n              case 4:\n                _c = _context53.sent;\n                if (_c.done) {\n                  _context53.next = 14;\n                  break;\n                }\n                getPageRangesSegment = _c.value;\n                _context53.t0 = __await;\n                return _context53.delegateYield(__asyncDelegator(__asyncValues(ExtractPageRangeInfoItems(getPageRangesSegment))), \"t1\", 9);\n              case 9:\n                _context53.t2 = _context53.t1;\n                _context53.next = 12;\n                return (0, _context53.t0)(_context53.t2);\n              case 12:\n                _context53.next = 2;\n                break;\n              case 14:\n                _context53.next = 19;\n                break;\n              case 16:\n                _context53.prev = 16;\n                _context53.t3 = _context53[\"catch\"](0);\n                e_1 = {\n                  error: _context53.t3\n                };\n              case 19:\n                _context53.prev = 19;\n                _context53.prev = 20;\n                if (!(_c && !_c.done && (_a = _b.return))) {\n                  _context53.next = 24;\n                  break;\n                }\n                _context53.next = 24;\n                return __await(_a.call(_b));\n              case 24:\n                _context53.prev = 24;\n                if (!e_1) {\n                  _context53.next = 27;\n                  break;\n                }\n                throw e_1.error;\n              case 27:\n                return _context53.finish(24);\n              case 28:\n                return _context53.finish(19);\n              case 29:\n              case \"end\":\n                return _context53.stop();\n            }\n          }\n        }, listPageRangeItems_1, this, [[0, 16, 19, 29], [20,, 24, 28]]);\n      }));\n    }\n    /**\n     * Returns an async iterable iterator to list of page ranges for a page blob.\n     * @see https://docs.microsoft.com/rest/api/storageservices/get-page-ranges\n     *\n     *  .byPage() returns an async iterable iterator to list of page ranges for a page blob.\n     *\n     * Example using `for await` syntax:\n     *\n     * ```js\n     * // Get the pageBlobClient before you run these snippets,\n     * // Can be obtained from `blobServiceClient.getContainerClient(\"<your-container-name>\").getPageBlobClient(\"<your-blob-name>\");`\n     * let i = 1;\n     * for await (const pageRange of pageBlobClient.listPageRanges()) {\n     *   console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);\n     * }\n     * ```\n     *\n     * Example using `iter.next()`:\n     *\n     * ```js\n     * let i = 1;\n     * let iter = pageBlobClient.listPageRanges();\n     * let pageRangeItem = await iter.next();\n     * while (!pageRangeItem.done) {\n     *   console.log(`Page range ${i++}: ${pageRangeItem.value.start} - ${pageRangeItem.value.end}, IsClear: ${pageRangeItem.value.isClear}`);\n     *   pageRangeItem = await iter.next();\n     * }\n     * ```\n     *\n     * Example using `byPage()`:\n     *\n     * ```js\n     * // passing optional maxPageSize in the page settings\n     * let i = 1;\n     * for await (const response of pageBlobClient.listPageRanges().byPage({ maxPageSize: 20 })) {\n     *   for (const pageRange of response) {\n     *     console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);\n     *   }\n     * }\n     * ```\n     *\n     * Example using paging with a marker:\n     *\n     * ```js\n     * let i = 1;\n     * let iterator = pageBlobClient.listPageRanges().byPage({ maxPageSize: 2 });\n     * let response = (await iterator.next()).value;\n     *\n     * // Prints 2 page ranges\n     * for (const pageRange of response) {\n     *   console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);\n     * }\n     *\n     * // Gets next marker\n     * let marker = response.continuationToken;\n     *\n     * // Passing next marker as continuationToken\n     *\n     * iterator = pageBlobClient.listPageRanges().byPage({ continuationToken: marker, maxPageSize: 10 });\n     * response = (await iterator.next()).value;\n     *\n     * // Prints 10 page ranges\n     * for (const blob of response) {\n     *   console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);\n     * }\n     * ```\n     * @param offset - Starting byte position of the page ranges.\n     * @param count - Number of bytes to get.\n     * @param options - Options to the Page Blob Get Ranges operation.\n     * @returns An asyncIterableIterator that supports paging.\n     */\n  }, {\n    key: \"listPageRanges\",\n    value: function listPageRanges() {\n      var _this11 = this,\n        _ref5;\n      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var count = arguments.length > 1 ? arguments[1] : undefined;\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      options.conditions = options.conditions || {};\n      // AsyncIterableIterator to iterate over blobs\n      var iter = this.listPageRangeItems(offset, count, options);\n      return _ref5 = {\n        /**\n         * The next method, part of the iteration protocol\n         */\n        next: function next() {\n          return iter.next();\n        }\n      }, _defineProperty(_ref5, Symbol.asyncIterator, function () {\n        return this;\n      }), _defineProperty(_ref5, \"byPage\", function byPage() {\n        var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        return _this11.listPageRangeItemSegments(offset, count, settings.continuationToken, Object.assign({\n          maxPageSize: settings.maxPageSize\n        }, options));\n      }), _ref5;\n    }\n    /**\n     * Gets the collection of page ranges that differ between a specified snapshot and this page blob.\n     * @see https://docs.microsoft.com/rest/api/storageservices/get-page-ranges\n     *\n     * @param offset - Starting byte position of the page blob\n     * @param count - Number of bytes to get ranges diff.\n     * @param prevSnapshot - Timestamp of snapshot to retrieve the difference.\n     * @param options - Options to the Page Blob Get Page Ranges Diff operation.\n     * @returns Response data for the Page Blob Get Page Range Diff operation.\n     */\n  }, {\n    key: \"getPageRangesDiff\",\n    value: function () {\n      var _getPageRangesDiff = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee52(offset, count, prevSnapshot) {\n        var options,\n          _a,\n          _createSpan45,\n          span,\n          updatedOptions,\n          _args54 = arguments;\n        return _regeneratorRuntime().wrap(function _callee52$(_context54) {\n          while (1) {\n            switch (_context54.prev = _context54.next) {\n              case 0:\n                options = _args54.length > 3 && _args54[3] !== undefined ? _args54[3] : {};\n                options.conditions = options.conditions || {};\n                _createSpan45 = createSpan(\"PageBlobClient-getPageRangesDiff\", options), span = _createSpan45.span, updatedOptions = _createSpan45.updatedOptions;\n                _context54.prev = 3;\n                _context54.next = 6;\n                return this.pageBlobContext.getPageRangesDiff(Object.assign({\n                  abortSignal: options.abortSignal,\n                  leaseAccessConditions: options.conditions,\n                  modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n                    ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n                  }),\n                  prevsnapshot: prevSnapshot,\n                  range: rangeToString({\n                    offset: offset,\n                    count: count\n                  })\n                }, convertTracingToRequestOptionsBase(updatedOptions))).then(rangeResponseFromModel);\n              case 6:\n                return _context54.abrupt(\"return\", _context54.sent);\n              case 9:\n                _context54.prev = 9;\n                _context54.t0 = _context54[\"catch\"](3);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context54.t0.message\n                });\n                throw _context54.t0;\n              case 13:\n                _context54.prev = 13;\n                span.end();\n                return _context54.finish(13);\n              case 16:\n              case \"end\":\n                return _context54.stop();\n            }\n          }\n        }, _callee52, this, [[3, 9, 13, 16]]);\n      }));\n      function getPageRangesDiff(_x52, _x53, _x54) {\n        return _getPageRangesDiff.apply(this, arguments);\n      }\n      return getPageRangesDiff;\n    }()\n    /**\n     * getPageRangesDiffSegment returns a single segment of page ranges starting from the\n     * specified Marker for difference between previous snapshot and the target page blob.\n     * Use an empty Marker to start enumeration from the beginning.\n     * After getting a segment, process it, and then call getPageRangesDiffSegment again\n     * (passing the the previously-returned Marker) to get the next segment.\n     * @see https://docs.microsoft.com/rest/api/storageservices/get-page-ranges\n     *\n     * @param offset - Starting byte position of the page ranges.\n     * @param count - Number of bytes to get.\n     * @param prevSnapshotOrUrl - Timestamp of snapshot to retrieve the difference or URL of snapshot to retrieve the difference.\n     * @param marker - A string value that identifies the portion of the get to be returned with the next get operation.\n     * @param options - Options to the Page Blob Get Page Ranges Diff operation.\n     */\n  }, {\n    key: \"listPageRangesDiffSegment\",\n    value: function () {\n      var _listPageRangesDiffSegment = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee53(offset, count, prevSnapshotOrUrl, marker, options) {\n        var _a, _createSpan46, span, updatedOptions;\n        return _regeneratorRuntime().wrap(function _callee53$(_context55) {\n          while (1) {\n            switch (_context55.prev = _context55.next) {\n              case 0:\n                _createSpan46 = createSpan(\"PageBlobClient-getPageRangesDiffSegment\", options), span = _createSpan46.span, updatedOptions = _createSpan46.updatedOptions;\n                _context55.prev = 1;\n                _context55.next = 4;\n                return this.pageBlobContext.getPageRangesDiff(Object.assign({\n                  abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal,\n                  leaseAccessConditions: options === null || options === void 0 ? void 0 : options.conditions,\n                  modifiedAccessConditions: Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.conditions), {\n                    ifTags: (_a = options === null || options === void 0 ? void 0 : options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n                  }),\n                  prevsnapshot: prevSnapshotOrUrl,\n                  range: rangeToString({\n                    offset: offset,\n                    count: count\n                  }),\n                  marker: marker,\n                  maxPageSize: options === null || options === void 0 ? void 0 : options.maxPageSize\n                }, convertTracingToRequestOptionsBase(updatedOptions)));\n              case 4:\n                return _context55.abrupt(\"return\", _context55.sent);\n              case 7:\n                _context55.prev = 7;\n                _context55.t0 = _context55[\"catch\"](1);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context55.t0.message\n                });\n                throw _context55.t0;\n              case 11:\n                _context55.prev = 11;\n                span.end();\n                return _context55.finish(11);\n              case 14:\n              case \"end\":\n                return _context55.stop();\n            }\n          }\n        }, _callee53, this, [[1, 7, 11, 14]]);\n      }));\n      function listPageRangesDiffSegment(_x55, _x56, _x57, _x58, _x59) {\n        return _listPageRangesDiffSegment.apply(this, arguments);\n      }\n      return listPageRangesDiffSegment;\n    }()\n    /**\n     * Returns an AsyncIterableIterator for {@link PageBlobGetPageRangesDiffResponseModel}\n     *\n     *\n     * @param offset - Starting byte position of the page ranges.\n     * @param count - Number of bytes to get.\n     * @param prevSnapshotOrUrl - Timestamp of snapshot to retrieve the difference or URL of snapshot to retrieve the difference.\n     * @param marker - A string value that identifies the portion of\n     *                          the get of page ranges to be returned with the next getting operation. The\n     *                          operation returns the ContinuationToken value within the response body if the\n     *                          getting operation did not return all page ranges remaining within the current page.\n     *                          The ContinuationToken value can be used as the value for\n     *                          the marker parameter in a subsequent call to request the next page of get\n     *                          items. The marker value is opaque to the client.\n     * @param options - Options to the Page Blob Get Page Ranges Diff operation.\n     */\n  }, {\n    key: \"listPageRangeDiffItemSegments\",\n    value: function listPageRangeDiffItemSegments(offset, count, prevSnapshotOrUrl, marker, options) {\n      return __asyncGenerator(this, arguments, /*#__PURE__*/_regeneratorRuntime().mark(function listPageRangeDiffItemSegments_1() {\n        var getPageRangeItemSegmentsResponse;\n        return _regeneratorRuntime().wrap(function listPageRangeDiffItemSegments_1$(_context56) {\n          while (1) {\n            switch (_context56.prev = _context56.next) {\n              case 0:\n                if (!(!!marker || marker === undefined)) {\n                  _context56.next = 14;\n                  break;\n                }\n              case 1:\n                _context56.next = 3;\n                return __await(this.listPageRangesDiffSegment(offset, count, prevSnapshotOrUrl, marker, options));\n              case 3:\n                getPageRangeItemSegmentsResponse = _context56.sent;\n                marker = getPageRangeItemSegmentsResponse.continuationToken;\n                _context56.t0 = __await;\n                _context56.next = 8;\n                return __await(getPageRangeItemSegmentsResponse);\n              case 8:\n                _context56.t1 = _context56.sent;\n                _context56.next = 11;\n                return (0, _context56.t0)(_context56.t1);\n              case 11:\n                _context56.next = 13;\n                return _context56.sent;\n              case 13:\n                if (marker) {\n                  _context56.next = 1;\n                  break;\n                }\n              case 14:\n              case \"end\":\n                return _context56.stop();\n            }\n          }\n        }, listPageRangeDiffItemSegments_1, this);\n      }));\n    }\n    /**\n     * Returns an AsyncIterableIterator of {@link PageRangeInfo} objects\n     *\n     * @param offset - Starting byte position of the page ranges.\n     * @param count - Number of bytes to get.\n     * @param prevSnapshotOrUrl - Timestamp of snapshot to retrieve the difference or URL of snapshot to retrieve the difference.\n     * @param options - Options to the Page Blob Get Page Ranges Diff operation.\n     */\n  }, {\n    key: \"listPageRangeDiffItems\",\n    value: function listPageRangeDiffItems(offset, count, prevSnapshotOrUrl, options) {\n      return __asyncGenerator(this, arguments, /*#__PURE__*/_regeneratorRuntime().mark(function listPageRangeDiffItems_1() {\n        var e_2, _a, marker, _b, _c, getPageRangesSegment;\n        return _regeneratorRuntime().wrap(function listPageRangeDiffItems_1$(_context57) {\n          while (1) {\n            switch (_context57.prev = _context57.next) {\n              case 0:\n                _context57.prev = 0;\n                _b = __asyncValues(this.listPageRangeDiffItemSegments(offset, count, prevSnapshotOrUrl, marker, options));\n              case 2:\n                _context57.next = 4;\n                return __await(_b.next());\n              case 4:\n                _c = _context57.sent;\n                if (_c.done) {\n                  _context57.next = 14;\n                  break;\n                }\n                getPageRangesSegment = _c.value;\n                _context57.t0 = __await;\n                return _context57.delegateYield(__asyncDelegator(__asyncValues(ExtractPageRangeInfoItems(getPageRangesSegment))), \"t1\", 9);\n              case 9:\n                _context57.t2 = _context57.t1;\n                _context57.next = 12;\n                return (0, _context57.t0)(_context57.t2);\n              case 12:\n                _context57.next = 2;\n                break;\n              case 14:\n                _context57.next = 19;\n                break;\n              case 16:\n                _context57.prev = 16;\n                _context57.t3 = _context57[\"catch\"](0);\n                e_2 = {\n                  error: _context57.t3\n                };\n              case 19:\n                _context57.prev = 19;\n                _context57.prev = 20;\n                if (!(_c && !_c.done && (_a = _b.return))) {\n                  _context57.next = 24;\n                  break;\n                }\n                _context57.next = 24;\n                return __await(_a.call(_b));\n              case 24:\n                _context57.prev = 24;\n                if (!e_2) {\n                  _context57.next = 27;\n                  break;\n                }\n                throw e_2.error;\n              case 27:\n                return _context57.finish(24);\n              case 28:\n                return _context57.finish(19);\n              case 29:\n              case \"end\":\n                return _context57.stop();\n            }\n          }\n        }, listPageRangeDiffItems_1, this, [[0, 16, 19, 29], [20,, 24, 28]]);\n      }));\n    }\n    /**\n     * Returns an async iterable iterator to list of page ranges that differ between a specified snapshot and this page blob.\n     * @see https://docs.microsoft.com/rest/api/storageservices/get-page-ranges\n     *\n     *  .byPage() returns an async iterable iterator to list of page ranges that differ between a specified snapshot and this page blob.\n     *\n     * Example using `for await` syntax:\n     *\n     * ```js\n     * // Get the pageBlobClient before you run these snippets,\n     * // Can be obtained from `blobServiceClient.getContainerClient(\"<your-container-name>\").getPageBlobClient(\"<your-blob-name>\");`\n     * let i = 1;\n     * for await (const pageRange of pageBlobClient.listPageRangesDiff()) {\n     *   console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);\n     * }\n     * ```\n     *\n     * Example using `iter.next()`:\n     *\n     * ```js\n     * let i = 1;\n     * let iter = pageBlobClient.listPageRangesDiff();\n     * let pageRangeItem = await iter.next();\n     * while (!pageRangeItem.done) {\n     *   console.log(`Page range ${i++}: ${pageRangeItem.value.start} - ${pageRangeItem.value.end}, IsClear: ${pageRangeItem.value.isClear}`);\n     *   pageRangeItem = await iter.next();\n     * }\n     * ```\n     *\n     * Example using `byPage()`:\n     *\n     * ```js\n     * // passing optional maxPageSize in the page settings\n     * let i = 1;\n     * for await (const response of pageBlobClient.listPageRangesDiff().byPage({ maxPageSize: 20 })) {\n     *   for (const pageRange of response) {\n     *     console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);\n     *   }\n     * }\n     * ```\n     *\n     * Example using paging with a marker:\n     *\n     * ```js\n     * let i = 1;\n     * let iterator = pageBlobClient.listPageRangesDiff().byPage({ maxPageSize: 2 });\n     * let response = (await iterator.next()).value;\n     *\n     * // Prints 2 page ranges\n     * for (const pageRange of response) {\n     *   console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);\n     * }\n     *\n     * // Gets next marker\n     * let marker = response.continuationToken;\n     *\n     * // Passing next marker as continuationToken\n     *\n     * iterator = pageBlobClient.listPageRangesDiff().byPage({ continuationToken: marker, maxPageSize: 10 });\n     * response = (await iterator.next()).value;\n     *\n     * // Prints 10 page ranges\n     * for (const blob of response) {\n     *   console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);\n     * }\n     * ```\n     * @param offset - Starting byte position of the page ranges.\n     * @param count - Number of bytes to get.\n     * @param prevSnapshot - Timestamp of snapshot to retrieve the difference.\n     * @param options - Options to the Page Blob Get Ranges operation.\n     * @returns An asyncIterableIterator that supports paging.\n     */\n  }, {\n    key: \"listPageRangesDiff\",\n    value: function listPageRangesDiff(offset, count, prevSnapshot) {\n      var _this12 = this,\n        _ref6;\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      options.conditions = options.conditions || {};\n      // AsyncIterableIterator to iterate over blobs\n      var iter = this.listPageRangeDiffItems(offset, count, prevSnapshot, Object.assign({}, options));\n      return _ref6 = {\n        /**\n         * The next method, part of the iteration protocol\n         */\n        next: function next() {\n          return iter.next();\n        }\n      }, _defineProperty(_ref6, Symbol.asyncIterator, function () {\n        return this;\n      }), _defineProperty(_ref6, \"byPage\", function byPage() {\n        var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        return _this12.listPageRangeDiffItemSegments(offset, count, prevSnapshot, settings.continuationToken, Object.assign({\n          maxPageSize: settings.maxPageSize\n        }, options));\n      }), _ref6;\n    }\n    /**\n     * Gets the collection of page ranges that differ between a specified snapshot and this page blob for managed disks.\n     * @see https://docs.microsoft.com/rest/api/storageservices/get-page-ranges\n     *\n     * @param offset - Starting byte position of the page blob\n     * @param count - Number of bytes to get ranges diff.\n     * @param prevSnapshotUrl - URL of snapshot to retrieve the difference.\n     * @param options - Options to the Page Blob Get Page Ranges Diff operation.\n     * @returns Response data for the Page Blob Get Page Range Diff operation.\n     */\n  }, {\n    key: \"getPageRangesDiffForManagedDisks\",\n    value: function () {\n      var _getPageRangesDiffForManagedDisks = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee54(offset, count, prevSnapshotUrl) {\n        var options,\n          _a,\n          _createSpan47,\n          span,\n          updatedOptions,\n          _args58 = arguments;\n        return _regeneratorRuntime().wrap(function _callee54$(_context58) {\n          while (1) {\n            switch (_context58.prev = _context58.next) {\n              case 0:\n                options = _args58.length > 3 && _args58[3] !== undefined ? _args58[3] : {};\n                options.conditions = options.conditions || {};\n                _createSpan47 = createSpan(\"PageBlobClient-GetPageRangesDiffForManagedDisks\", options), span = _createSpan47.span, updatedOptions = _createSpan47.updatedOptions;\n                _context58.prev = 3;\n                _context58.next = 6;\n                return this.pageBlobContext.getPageRangesDiff(Object.assign({\n                  abortSignal: options.abortSignal,\n                  leaseAccessConditions: options.conditions,\n                  modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n                    ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n                  }),\n                  prevSnapshotUrl: prevSnapshotUrl,\n                  range: rangeToString({\n                    offset: offset,\n                    count: count\n                  })\n                }, convertTracingToRequestOptionsBase(updatedOptions))).then(rangeResponseFromModel);\n              case 6:\n                return _context58.abrupt(\"return\", _context58.sent);\n              case 9:\n                _context58.prev = 9;\n                _context58.t0 = _context58[\"catch\"](3);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context58.t0.message\n                });\n                throw _context58.t0;\n              case 13:\n                _context58.prev = 13;\n                span.end();\n                return _context58.finish(13);\n              case 16:\n              case \"end\":\n                return _context58.stop();\n            }\n          }\n        }, _callee54, this, [[3, 9, 13, 16]]);\n      }));\n      function getPageRangesDiffForManagedDisks(_x60, _x61, _x62) {\n        return _getPageRangesDiffForManagedDisks.apply(this, arguments);\n      }\n      return getPageRangesDiffForManagedDisks;\n    }()\n    /**\n     * Resizes the page blob to the specified size (which must be a multiple of 512).\n     * @see https://docs.microsoft.com/rest/api/storageservices/set-blob-properties\n     *\n     * @param size - Target size\n     * @param options - Options to the Page Blob Resize operation.\n     * @returns Response data for the Page Blob Resize operation.\n     */\n  }, {\n    key: \"resize\",\n    value: function () {\n      var _resize = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee55(size) {\n        var options,\n          _a,\n          _createSpan48,\n          span,\n          updatedOptions,\n          _args59 = arguments;\n        return _regeneratorRuntime().wrap(function _callee55$(_context59) {\n          while (1) {\n            switch (_context59.prev = _context59.next) {\n              case 0:\n                options = _args59.length > 1 && _args59[1] !== undefined ? _args59[1] : {};\n                options.conditions = options.conditions || {};\n                _createSpan48 = createSpan(\"PageBlobClient-resize\", options), span = _createSpan48.span, updatedOptions = _createSpan48.updatedOptions;\n                _context59.prev = 3;\n                _context59.next = 6;\n                return this.pageBlobContext.resize(size, Object.assign({\n                  abortSignal: options.abortSignal,\n                  leaseAccessConditions: options.conditions,\n                  modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n                    ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n                  }),\n                  encryptionScope: options.encryptionScope\n                }, convertTracingToRequestOptionsBase(updatedOptions)));\n              case 6:\n                return _context59.abrupt(\"return\", _context59.sent);\n              case 9:\n                _context59.prev = 9;\n                _context59.t0 = _context59[\"catch\"](3);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context59.t0.message\n                });\n                throw _context59.t0;\n              case 13:\n                _context59.prev = 13;\n                span.end();\n                return _context59.finish(13);\n              case 16:\n              case \"end\":\n                return _context59.stop();\n            }\n          }\n        }, _callee55, this, [[3, 9, 13, 16]]);\n      }));\n      function resize(_x63) {\n        return _resize.apply(this, arguments);\n      }\n      return resize;\n    }()\n    /**\n     * Sets a page blob's sequence number.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-properties\n     *\n     * @param sequenceNumberAction - Indicates how the service should modify the blob's sequence number.\n     * @param sequenceNumber - Required if sequenceNumberAction is max or update\n     * @param options - Options to the Page Blob Update Sequence Number operation.\n     * @returns Response data for the Page Blob Update Sequence Number operation.\n     */\n  }, {\n    key: \"updateSequenceNumber\",\n    value: function () {\n      var _updateSequenceNumber = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee56(sequenceNumberAction, sequenceNumber) {\n        var options,\n          _a,\n          _createSpan49,\n          span,\n          updatedOptions,\n          _args60 = arguments;\n        return _regeneratorRuntime().wrap(function _callee56$(_context60) {\n          while (1) {\n            switch (_context60.prev = _context60.next) {\n              case 0:\n                options = _args60.length > 2 && _args60[2] !== undefined ? _args60[2] : {};\n                options.conditions = options.conditions || {};\n                _createSpan49 = createSpan(\"PageBlobClient-updateSequenceNumber\", options), span = _createSpan49.span, updatedOptions = _createSpan49.updatedOptions;\n                _context60.prev = 3;\n                _context60.next = 6;\n                return this.pageBlobContext.updateSequenceNumber(sequenceNumberAction, Object.assign({\n                  abortSignal: options.abortSignal,\n                  blobSequenceNumber: sequenceNumber,\n                  leaseAccessConditions: options.conditions,\n                  modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n                    ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n                  })\n                }, convertTracingToRequestOptionsBase(updatedOptions)));\n              case 6:\n                return _context60.abrupt(\"return\", _context60.sent);\n              case 9:\n                _context60.prev = 9;\n                _context60.t0 = _context60[\"catch\"](3);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context60.t0.message\n                });\n                throw _context60.t0;\n              case 13:\n                _context60.prev = 13;\n                span.end();\n                return _context60.finish(13);\n              case 16:\n              case \"end\":\n                return _context60.stop();\n            }\n          }\n        }, _callee56, this, [[3, 9, 13, 16]]);\n      }));\n      function updateSequenceNumber(_x64, _x65) {\n        return _updateSequenceNumber.apply(this, arguments);\n      }\n      return updateSequenceNumber;\n    }()\n    /**\n     * Begins an operation to start an incremental copy from one page blob's snapshot to this page blob.\n     * The snapshot is copied such that only the differential changes between the previously\n     * copied snapshot are transferred to the destination.\n     * The copied snapshots are complete copies of the original snapshot and can be read or copied from as usual.\n     * @see https://docs.microsoft.com/rest/api/storageservices/incremental-copy-blob\n     * @see https://docs.microsoft.com/en-us/azure/virtual-machines/windows/incremental-snapshots\n     *\n     * @param copySource - Specifies the name of the source page blob snapshot. For example,\n     *                            https://myaccount.blob.core.windows.net/mycontainer/myblob?snapshot=<DateTime>\n     * @param options - Options to the Page Blob Copy Incremental operation.\n     * @returns Response data for the Page Blob Copy Incremental operation.\n     */\n  }, {\n    key: \"startCopyIncremental\",\n    value: function () {\n      var _startCopyIncremental = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee57(copySource) {\n        var options,\n          _a,\n          _createSpan50,\n          span,\n          updatedOptions,\n          _args61 = arguments;\n        return _regeneratorRuntime().wrap(function _callee57$(_context61) {\n          while (1) {\n            switch (_context61.prev = _context61.next) {\n              case 0:\n                options = _args61.length > 1 && _args61[1] !== undefined ? _args61[1] : {};\n                _createSpan50 = createSpan(\"PageBlobClient-startCopyIncremental\", options), span = _createSpan50.span, updatedOptions = _createSpan50.updatedOptions;\n                _context61.prev = 2;\n                _context61.next = 5;\n                return this.pageBlobContext.copyIncremental(copySource, Object.assign({\n                  abortSignal: options.abortSignal,\n                  modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n                    ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n                  })\n                }, convertTracingToRequestOptionsBase(updatedOptions)));\n              case 5:\n                return _context61.abrupt(\"return\", _context61.sent);\n              case 8:\n                _context61.prev = 8;\n                _context61.t0 = _context61[\"catch\"](2);\n                span.setStatus({\n                  code: SpanStatusCode.ERROR,\n                  message: _context61.t0.message\n                });\n                throw _context61.t0;\n              case 12:\n                _context61.prev = 12;\n                span.end();\n                return _context61.finish(12);\n              case 15:\n              case \"end\":\n                return _context61.stop();\n            }\n          }\n        }, _callee57, this, [[2, 8, 12, 15]]);\n      }));\n      function startCopyIncremental(_x66) {\n        return _startCopyIncremental.apply(this, arguments);\n      }\n      return startCopyIncremental;\n    }()\n  }]);\n  return PageBlobClient;\n}(BlobClient);","map":{"version":3,"mappings":"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","names":["generateUuid","getDefaultProxySettings","isNode","isTokenCredential","URLBuilder","SpanStatusCode","BlobDownloadResponse","BlobQueryResponse","AnonymousCredential","StorageSharedKeyCredential","AppendBlob","Blob","StorageBlob","BlockBlob","PageBlob","ensureCpkIfSpecified","toAccessTier","rangeResponseFromModel","newPipeline","isPipelineLike","BlobBeginCopyFromUrlPoller","rangeToString","StorageClient","Batch","BufferScheduler","BlobDoesNotUseCustomerSpecifiedEncryption","BlobUsesCustomerSpecifiedEncryptionMsg","BLOCK_BLOB_MAX_BLOCKS","BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES","BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES","DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES","DEFAULT_BLOCK_BUFFER_SIZE_BYTES","DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS","ETagAny","URLConstants","createSpan","convertTracingToRequestOptionsBase","appendToURLPath","appendToURLQuery","extractConnectionStringParts","ExtractPageRangeInfoItems","generateBlockID","getURLParameter","httpAuthorizationToString","isIpEndpointStyle","parseObjectReplicationRecord","setURLParameter","toBlobTags","toBlobTagsString","toQuerySerialization","toTags","fsCreateReadStream","fsStat","readStreamToLocalFile","streamToBuffer","generateBlobSASQueryParameters","BlobLeaseClient","BlobClient","urlOrConnectionString","credentialOrPipelineOrContainerName","blobNameOrOptions","options","pipeline","url","containerName","blobName","extractedCreds","kind","sharedKeyCredential","accountName","accountKey","encodeURIComponent","proxyOptions","proxyUri","Error","accountSas","getBlobAndContainerNamesFromUrl","_name","_containerName","blobContext","storageClientContext","_snapshot","Parameters","SNAPSHOT","_versionId","VERSIONID","snapshot","length","undefined","versionId","AppendBlobClient","BlockBlobClient","PageBlobClient","offset","count","conditions","customerProvidedKey","isHttps","span","updatedOptions","download","abortSignal","leaseAccessConditions","modifiedAccessConditions","ifTags","tagConditions","requestOptions","onDownloadProgress","onProgress","range","rangeGetContentMD5","rangeGetContentCRC64","rangeGetContentCrc64","cpkInfo","res","wrappedRes","_response","objectReplicationDestinationPolicyId","objectReplicationPolicyId","objectReplicationSourceProperties","objectReplicationRules","maxRetryRequests","contentLength","RangeError","etag","start","updatedDownloadOptions","ifMatch","ifModifiedSince","ifNoneMatch","ifUnmodifiedSince","readableStreamBody","setStatus","code","ERROR","message","end","getProperties","tracingOptions","statusCode","details","errorCode","Object","delete","deleteSnapshots","succeeded","response","parsedHeaders","undelete","blobHTTPHeaders","setHttpHeaders","blobHttpHeaders","metadata","setMetadata","encryptionScope","tags","setTags","getTags","wrappedResponse","blobTagSet","proposeLeaseId","createSnapshot","copySource","client","abortCopyFromURL","startCopyFromURL","poller","blobClient","intervalInMs","resumeFrom","startCopyFromURLOptions","poll","copyId","sourceConditions","copyFromURL","sourceModifiedAccessConditions","sourceIfMatch","sourceIfModifiedSince","sourceIfNoneMatch","sourceIfUnmodifiedSince","sourceContentMD5","copySourceAuthorization","sourceAuthorization","blobTagsString","immutabilityPolicyExpiry","immutabilityPolicy","expiriesOn","immutabilityPolicyMode","policyMode","legalHold","copySourceTags","tier","setTier","rehydratePriority","param1","param2","param3","param4","Buffer","buffer","blockSize","alloc","transferProgress","batch","concurrency","off","addOperation","chunkEnd","maxRetryRequestsPerBlock","stream","loadedBytes","do","filePath","blobDownloadStream","parsedUrl","parse","getHost","split","pathComponents","getPath","match","decodeURIComponent","replace","error","sourceIfTags","sealBlob","Promise","resolve","credential","sas","snapshotTime","toString","deleteImmutabilityPolicy","setImmutabilityPolicy","modifiedAccessCondition","legalHoldEnabled","setLegalHold","appendBlobContext","create","seal","appendPositionAccessConditions","body","appendBlock","onUploadProgress","transactionalContentMD5","transactionalContentCrc64","sourceURL","sourceOffset","appendBlockFromUrl","sourceRange","sourceContentCrc64","blockBlobContext","_blobContext","query","queryRequest","queryType","expression","inputSerialization","inputTextConfiguration","outputSerialization","outputTextConfiguration","onError","upload","putBlobFromUrl","blockId","stageBlock","stageBlockFromURL","blocks","commitBlockList","latest","listType","getBlockList","committedBlocks","uncommittedBlocks","data","ArrayBuffer","from","byteOffset","byteLength","uploadSeekableInternal","size","slice","browserBlob","browserData","bodyFactory","maxSingleShotSize","Math","ceil","numBlocks","floor","blockList","blockIDPrefix","i","blockID","push","autoClose","Infinity","bufferSize","maxConcurrency","blockNum","scheduler","pageBlobContext","blobSequenceNumber","uploadPages","sequenceNumberAccessConditions","destOffset","uploadPagesFromURL","clearPages","getPageRanges","then","marker","maxPageSize","listPageRangesSegment","getPageRangeItemSegmentsResponse","continuationToken","__await","_b","listPageRangeItemSegments","_c","getPageRangesSegment","__asyncDelegator","iter","listPageRangeItems","next","Symbol","asyncIterator","settings","prevSnapshot","getPageRangesDiff","prevsnapshot","prevSnapshotOrUrl","listPageRangesDiffSegment","listPageRangeDiffItemSegments","listPageRangeDiffItems","prevSnapshotUrl","resize","sequenceNumberAction","sequenceNumber","updateSequenceNumber","copyIncremental"],"sourceRoot":"","sources":["../../../src/Clients.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport {\n  generateUuid,\n  getDefaultProxySettings,\n  HttpRequestBody,\n  HttpResponse,\n  isNode,\n  isTokenCredential,\n  TokenCredential,\n  TransferProgressEvent,\n  URLBuilder,\n} from \"@azure/core-http\";\nimport { PollOperationState } from \"@azure/core-lro\";\nimport { SpanStatusCode } from \"@azure/core-tracing\";\nimport { Readable } from \"stream\";\n\nimport { BlobDownloadResponse } from \"./BlobDownloadResponse\";\nimport { BlobQueryResponse } from \"./BlobQueryResponse\";\nimport { AnonymousCredential } from \"./credentials/AnonymousCredential\";\nimport { StorageSharedKeyCredential } from \"./credentials/StorageSharedKeyCredential\";\nimport { AppendBlob, Blob as StorageBlob, BlockBlob, PageBlob } from \"./generated/src/operations\";\nimport {\n  AppendBlobAppendBlockFromUrlResponse,\n  AppendBlobAppendBlockResponse,\n  AppendBlobCreateResponse,\n  BlobAbortCopyFromURLResponse,\n  BlobCopyFromURLResponse,\n  BlobCreateSnapshotResponse,\n  BlobDeleteResponse,\n  BlobDownloadOptionalParams,\n  BlobDownloadResponseModel,\n  BlobGetPropertiesResponseModel,\n  BlobGetTagsHeaders,\n  BlobSetHTTPHeadersResponse,\n  BlobSetMetadataResponse,\n  BlobSetTagsResponse,\n  BlobSetTierResponse,\n  BlobStartCopyFromURLResponse,\n  BlobTags,\n  BlobUndeleteResponse,\n  BlockBlobCommitBlockListResponse,\n  BlockBlobGetBlockListResponse,\n  BlockBlobStageBlockFromURLResponse,\n  BlockBlobStageBlockResponse,\n  BlockBlobUploadHeaders,\n  BlockBlobUploadResponse,\n  BlockListType,\n  CpkInfo,\n  DeleteSnapshotsOptionType,\n  LeaseAccessConditions,\n  PageBlobClearPagesResponse,\n  PageBlobCopyIncrementalResponse,\n  PageBlobCreateResponse,\n  PageBlobResizeResponse,\n  PageBlobUpdateSequenceNumberResponse,\n  PageBlobUploadPagesFromURLResponse,\n  PageBlobUploadPagesResponse,\n  RehydratePriority,\n  SequenceNumberActionType,\n  BlockBlobPutBlobFromUrlResponse,\n  BlobHTTPHeaders,\n  PageBlobGetPageRangesResponseModel,\n  PageRangeInfo,\n  PageBlobGetPageRangesDiffResponseModel,\n  BlobCopySourceTags,\n} from \"./generatedModels\";\nimport {\n  AppendBlobRequestConditions,\n  BlobDownloadResponseParsed,\n  BlobRequestConditions,\n  BlockBlobTier,\n  ensureCpkIfSpecified,\n  Metadata,\n  ObjectReplicationPolicy,\n  PageBlobRequestConditions,\n  PremiumPageBlobTier,\n  Tags,\n  toAccessTier,\n  TagConditions,\n  MatchConditions,\n  ModificationConditions,\n  ModifiedAccessConditions,\n  BlobQueryArrowField,\n  BlobImmutabilityPolicy,\n  HttpAuthorization,\n  PollerLikeWithCancellation,\n} from \"./models\";\nimport {\n  PageBlobGetPageRangesDiffResponse,\n  PageBlobGetPageRangesResponse,\n  rangeResponseFromModel,\n} from \"./PageBlobRangeResponse\";\nimport { newPipeline, PipelineLike, isPipelineLike, StoragePipelineOptions } from \"./Pipeline\";\nimport {\n  BlobBeginCopyFromUrlPoller,\n  BlobBeginCopyFromUrlPollState,\n  CopyPollerBlobClient,\n} from \"./pollers/BlobStartCopyFromUrlPoller\";\nimport { Range, rangeToString } from \"./Range\";\nimport { CommonOptions, StorageClient } from \"./StorageClient\";\nimport { Batch } from \"./utils/Batch\";\nimport { BufferScheduler } from \"../../storage-common/src\";\nimport {\n  BlobDoesNotUseCustomerSpecifiedEncryption,\n  BlobUsesCustomerSpecifiedEncryptionMsg,\n  BLOCK_BLOB_MAX_BLOCKS,\n  BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES,\n  BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES,\n  DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES,\n  DEFAULT_BLOCK_BUFFER_SIZE_BYTES,\n  DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS,\n  ETagAny,\n  URLConstants,\n} from \"./utils/constants\";\nimport { createSpan, convertTracingToRequestOptionsBase } from \"./utils/tracing\";\nimport {\n  appendToURLPath,\n  appendToURLQuery,\n  extractConnectionStringParts,\n  ExtractPageRangeInfoItems,\n  generateBlockID,\n  getURLParameter,\n  httpAuthorizationToString,\n  isIpEndpointStyle,\n  parseObjectReplicationRecord,\n  setURLParameter,\n  toBlobTags,\n  toBlobTagsString,\n  toQuerySerialization,\n  toTags,\n} from \"./utils/utils.common\";\nimport {\n  fsCreateReadStream,\n  fsStat,\n  readStreamToLocalFile,\n  streamToBuffer,\n} from \"./utils/utils.node\";\nimport { SASProtocol } from \"./sas/SASQueryParameters\";\nimport { SasIPRange } from \"./sas/SasIPRange\";\nimport { generateBlobSASQueryParameters } from \"./sas/BlobSASSignatureValues\";\nimport { BlobSASPermissions } from \"./sas/BlobSASPermissions\";\nimport { BlobLeaseClient } from \"./BlobLeaseClient\";\nimport {\n  BlobDeleteImmutabilityPolicyResponse,\n  BlobSetImmutabilityPolicyResponse,\n  BlobSetLegalHoldResponse,\n} from \"./generatedModels\";\nimport { PagedAsyncIterableIterator, PageSettings } from \"@azure/core-paging\";\n\n/**\n * Options to configure the {@link BlobClient.beginCopyFromURL} operation.\n */\nexport interface BlobBeginCopyFromURLOptions extends BlobStartCopyFromURLOptions {\n  /**\n   * The amount of time in milliseconds the poller should wait between\n   * calls to the service to determine the status of the Blob copy.\n   * Defaults to 15 seconds.\n   */\n  intervalInMs?: number;\n  /**\n   * Callback to receive the state of the copy progress.\n   */\n  onProgress?: (state: BlobBeginCopyFromUrlPollState) => void;\n  /**\n   * Serialized poller state that can be used to resume polling from.\n   * This may be useful when starting a copy on one process or thread\n   * and you wish to continue polling on another process or thread.\n   *\n   * To get serialized poller state, call `poller.toString()` on an existing\n   * poller.\n   */\n  resumeFrom?: string;\n}\n\n/**\n * Contains response data for the {@link BlobClient.beginCopyFromURL} operation.\n */\nexport interface BlobBeginCopyFromURLResponse extends BlobStartCopyFromURLResponse {}\n\n/**\n * Options to configure the {@link BlobClient.download} operation.\n */\nexport interface BlobDownloadOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * An opaque DateTime string value that, when present, specifies the blob snapshot to retrieve.\n   */\n  snapshot?: string;\n  /**\n   * When this is set to true and download range of blob, the service returns the MD5 hash for the range,\n   * as long as the range is less than or equal to 4 MB in size.\n   *\n   * rangeGetContentCrc64 and rangeGetContentMD5 cannot be set at same time.\n   */\n  rangeGetContentMD5?: boolean;\n  /**\n   * When this is set to true and download range of blob, the service returns the CRC64 hash for the range,\n   * as long as the range is less than or equal to 4 MB in size.\n   *\n   * rangeGetContentCrc64 and rangeGetContentMD5 cannot be set at same time.\n   */\n  rangeGetContentCrc64?: boolean;\n  /**\n   * Conditions to meet when downloading blobs.\n   */\n  conditions?: BlobRequestConditions;\n  /**\n   * Call back to receive events on the progress of download operation.\n   */\n  onProgress?: (progress: TransferProgressEvent) => void;\n\n  /**\n   * Optional. ONLY AVAILABLE IN NODE.JS.\n   *\n   * How many retries will perform when original body download stream unexpected ends.\n   * Above kind of ends will not trigger retry policy defined in a pipeline,\n   * because they doesn't emit network errors.\n   *\n   * With this option, every additional retry means an additional `FileClient.download()` request will be made\n   * from the broken point, until the requested range has been successfully downloaded or maxRetryRequests is reached.\n   *\n   * Default value is 5, please set a larger value when loading large files in poor network.\n   */\n  maxRetryRequests?: number;\n  /**\n   * Customer Provided Key Info.\n   */\n  customerProvidedKey?: CpkInfo;\n}\n\n/**\n * Options to configure the {@link BlobClient.exists} operation.\n */\nexport interface BlobExistsOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Customer Provided Key Info.\n   */\n  customerProvidedKey?: CpkInfo;\n  /**\n   * Conditions to meet.\n   */\n  conditions?: BlobRequestConditions;\n}\n\n/**\n * Options to configure the {@link BlobClient.getProperties} operation.\n */\nexport interface BlobGetPropertiesOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Conditions to meet when getting blob properties.\n   */\n  conditions?: BlobRequestConditions;\n  /**\n   * Customer Provided Key Info.\n   */\n  customerProvidedKey?: CpkInfo;\n}\n\n/**\n * Options to configure the {@link BlobClient.delete} operation.\n */\nexport interface BlobDeleteOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Conditions to meet when deleting blobs.\n   */\n  conditions?: BlobRequestConditions;\n  /**\n   * Specifies options to delete blobs that have associated snapshots.\n   * - `include`: Delete the base blob and all of its snapshots.\n   * - `only`: Delete only the blob's snapshots and not the blob itself.\n   */\n  deleteSnapshots?: DeleteSnapshotsOptionType;\n  /**\n   * Customer Provided Key Info.\n   */\n  customerProvidedKey?: CpkInfo;\n}\n\n/**\n * Options to configure the {@link BlobClient.undelete} operation.\n */\nexport interface BlobUndeleteOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Customer Provided Key Info.\n   */\n  customerProvidedKey?: CpkInfo;\n}\n\n/**\n * Options to configure the {@link BlobClient.setHTTPHeaders} operation.\n */\nexport interface BlobSetHTTPHeadersOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Conditions to meet when setting blob HTTP headers.\n   */\n  conditions?: BlobRequestConditions;\n  /**\n   * Customer Provided Key Info.\n   */\n  customerProvidedKey?: CpkInfo;\n}\n\n/**\n * Options to configure the {@link BlobClient.setMetadata} operation.\n */\nexport interface BlobSetMetadataOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Conditions to meet when setting blob metadata.\n   */\n  conditions?: BlobRequestConditions;\n  /**\n   * Customer Provided Key Info.\n   */\n  customerProvidedKey?: CpkInfo;\n  /**\n   * Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to\n   * encrypt the data provided in the request. If not specified, encryption is performed with the\n   * default account encryption scope.  For more information, see Encryption at Rest for Azure\n   * Storage Services.\n   */\n  encryptionScope?: string;\n}\n\n/**\n * Options to configure the {@link BlobClient.setTags} operation.\n */\nexport interface BlobSetTagsOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Conditions to meet for the blob to perform this operation.\n   */\n  conditions?: TagConditions & LeaseAccessConditions;\n}\n\n/**\n * Options to configure the {@link BlobClient.getTags} operation.\n */\nexport interface BlobGetTagsOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Conditions to meet for the blob to perform this operation.\n   */\n  conditions?: TagConditions & LeaseAccessConditions;\n}\n\n/**\n * Contains response data for the {@link BlobClient.getTags} operation.\n */\nexport type BlobGetTagsResponse = { tags: Tags } & BlobGetTagsHeaders & {\n    /**\n     * The underlying HTTP response.\n     */\n    _response: HttpResponse & {\n      /**\n       * The parsed HTTP response headers.\n       */\n      parsedHeaders: BlobGetTagsHeaders;\n\n      /**\n       * The response body as text (string format)\n       */\n      bodyAsText: string;\n\n      /**\n       * The response body as parsed JSON or XML\n       */\n      parsedBody: BlobTags;\n    };\n  };\n\n/**\n * Options to configure Blob - Acquire Lease operation.\n */\nexport interface BlobAcquireLeaseOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Conditions to meet when acquiring the lease of a blob.\n   */\n  conditions?: ModifiedAccessConditions;\n}\n\n/**\n * Options to configure Blob - Release Lease operation.\n */\nexport interface BlobReleaseLeaseOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Conditions to meet when releasing the lease of a blob.\n   */\n  conditions?: ModifiedAccessConditions;\n}\n\n/**\n * Options to configure Blob - Renew Lease operation.\n */\nexport interface BlobRenewLeaseOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Conditions to meet when renewing the lease of a blob.\n   */\n  conditions?: ModifiedAccessConditions;\n}\n\n/**\n * Options to configure Blob - Change Lease operation.\n */\nexport interface BlobChangeLeaseOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Conditions to meet when changing the lease of a blob.\n   */\n  conditions?: ModifiedAccessConditions;\n}\n\n/**\n * Options to configure Blob - Break Lease operation.\n */\nexport interface BlobBreakLeaseOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Conditions to meet when breaking the lease of a blob.\n   */\n  conditions?: ModifiedAccessConditions;\n}\n\n/**\n * Options to configure the {@link BlobClient.createSnapshot} operation.\n */\nexport interface BlobCreateSnapshotOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * A collection of key-value string pair to associate with the snapshot.\n   */\n  metadata?: Metadata;\n  /**\n   * Conditions to meet when creating blob snapshots.\n   */\n  conditions?: BlobRequestConditions;\n  /**\n   * Customer Provided Key Info.\n   */\n  customerProvidedKey?: CpkInfo;\n  /**\n   * Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to\n   * encrypt the data provided in the request. If not specified, encryption is performed with the\n   * default account encryption scope.  For more information, see Encryption at Rest for Azure\n   * Storage Services.\n   */\n  encryptionScope?: string;\n}\n\n/**\n * Options to configure the {@link BlobClient.beginCopyFromURL} operation.\n */\nexport interface BlobStartCopyFromURLOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * A collection of key-value string pair to associate with the blob that are being copied.\n   */\n  metadata?: Metadata;\n  /**\n   * Conditions to meet for the destination blob when copying from a URL to the blob.\n   */\n  conditions?: BlobRequestConditions;\n  /**\n   * Conditions to meet for the source Azure Blob/File when copying from a URL to the blob.\n   */\n  sourceConditions?: ModifiedAccessConditions;\n  /**\n   * Access tier.\n   * More Details - https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blob-storage-tiers\n   */\n  tier?: BlockBlobTier | PremiumPageBlobTier | string;\n  /**\n   * Rehydrate Priority - possible values include 'High', 'Standard'.\n   * More Details - https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blob-rehydration#rehydrate-an-archived-blob-to-an-online-tier\n   */\n  rehydratePriority?: RehydratePriority;\n  /**\n   * Optional. Specifies immutability policy for a blob.\n   * Note that is parameter is only applicable to a blob within a container that\n   * has version level worm enabled.\n   */\n  immutabilityPolicy?: BlobImmutabilityPolicy;\n  /**\n   * Optional. Indicates if a legal hold should be placed on the blob.\n   * Note that is parameter is only applicable to a blob within a container that\n   * has version level worm enabled.\n   */\n  legalHold?: boolean;\n  /**\n   * Blob tags.\n   */\n  tags?: Tags;\n  /**\n   * Overrides the sealed state of the destination blob. Default true.\n   */\n  sealBlob?: boolean;\n}\n\n/**\n * Options to configure the {@link BlobClient.abortCopyFromURL} operation.\n */\nexport interface BlobAbortCopyFromURLOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * If specified, contains the lease id that must be matched and lease with this id\n   * must be active in order for the operation to succeed.\n   */\n  conditions?: LeaseAccessConditions;\n}\n\n/**\n * Options to configure the {@link BlobClient.syncCopyFromURL} operation.\n */\nexport interface BlobSyncCopyFromURLOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * A collection of key-value string pair to associate with the snapshot.\n   */\n  metadata?: Metadata;\n  /**\n   * Conditions to meet for the destination blob when copying from a URL to the blob.\n   */\n  conditions?: BlobRequestConditions;\n  /**\n   * Conditions to meet for the source Azure Blob/File when copying from a URL to the blob.\n   */\n  sourceConditions?: MatchConditions & ModificationConditions;\n  /**\n   * Specify the md5 calculated for the range of bytes that must be read from the copy source.\n   */\n  sourceContentMD5?: Uint8Array;\n  /**\n   * Optional. Specifies immutability policy for a blob.\n   * Note that is parameter is only applicable to a blob within a container that\n   * has version level worm enabled.\n   */\n  immutabilityPolicy?: BlobImmutabilityPolicy;\n  /**\n   * Optional. Indicates if a legal hold should be placed on the blob.\n   * Note that is parameter is only applicable to a blob within a container that\n   * has version level worm enabled.\n   */\n  legalHold?: boolean;\n  /**\n   * Blob tags.\n   */\n  tags?: Tags;\n  /**\n   * Only Bearer type is supported. Credentials should be a valid OAuth access token to copy source.\n   */\n  sourceAuthorization?: HttpAuthorization;\n  /**\n   * Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to encrypt the data provided in the request. If not specified, encryption is performed with the default account encryption scope.  For more information, see Encryption at Rest for Azure Storage Services.\n   */\n  encryptionScope?: string;\n  /**\n   * Optional. Default 'REPLACE'.  Indicates if source tags should be copied or replaced with the tags specified by {@link tags}.\n   */\n  copySourceTags?: BlobCopySourceTags;\n}\n\n/**\n * Options to configure the {@link BlobClient.setAccessTier} operation.\n */\nexport interface BlobSetTierOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * If specified, contains the lease id that must be matched and lease with this id\n   * must be active in order for the operation to succeed.\n   */\n  conditions?: LeaseAccessConditions & TagConditions;\n  /**\n   * Rehydrate Priority - possible values include 'High', 'Standard'.\n   * More Details - https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blob-rehydration#rehydrate-an-archived-blob-to-an-online-tier\n   */\n  rehydratePriority?: RehydratePriority;\n}\n\n/**\n * Option interface for the {@link BlobClient.downloadToBuffer} operation.\n */\nexport interface BlobDownloadToBufferOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n\n  /**\n   * blockSize is the data every request trying to download.\n   * Must be greater than or equal to 0.\n   * If set to 0 or undefined, blockSize will automatically calculated according to the blob size.\n   */\n  blockSize?: number;\n\n  /**\n   * Optional. ONLY AVAILABLE IN NODE.JS.\n   *\n   * How many retries will perform when original block download stream unexpected ends.\n   * Above kind of ends will not trigger retry policy defined in a pipeline,\n   * because they doesn't emit network errors.\n   *\n   * With this option, every additional retry means an additional FileClient.download() request will be made\n   * from the broken point, until the requested block has been successfully downloaded or\n   * maxRetryRequestsPerBlock is reached.\n   *\n   * Default value is 5, please set a larger value when in poor network.\n   */\n  maxRetryRequestsPerBlock?: number;\n\n  /**\n   * Progress updater.\n   */\n  onProgress?: (progress: TransferProgressEvent) => void;\n\n  /**\n   * Access conditions headers.\n   */\n  conditions?: BlobRequestConditions;\n\n  /**\n   * Concurrency of parallel download.\n   */\n  concurrency?: number;\n  /**\n   * Customer Provided Key Info.\n   */\n  customerProvidedKey?: CpkInfo;\n}\n\n/**\n * Contains response data for the {@link BlobClient.deleteIfExists} operation.\n */\nexport interface BlobDeleteIfExistsResponse extends BlobDeleteResponse {\n  /**\n   * Indicate whether the blob is successfully deleted. Is false if the blob does not exist in the first place.\n   */\n  succeeded: boolean;\n}\n\n/**\n * Contains response data for the {@link BlobClient.getProperties} operation.\n */\nexport interface BlobGetPropertiesResponse extends BlobGetPropertiesResponseModel {\n  /**\n   * Parsed Object Replication Policy Id, Rule Id(s) and status of the source blob.\n   */\n  objectReplicationSourceProperties?: ObjectReplicationPolicy[];\n\n  /**\n   * Object Replication Policy Id of the destination blob.\n   */\n  objectReplicationDestinationPolicyId?: string;\n}\n\n/**\n * Common options of {@link BlobGenerateSasUrlOptions} and {@link ContainerGenerateSasUrlOptions}.\n */\nexport interface CommonGenerateSasUrlOptions {\n  /**\n   * The version of the service this SAS will target. If not specified, it will default to the version targeted by the\n   * library.\n   */\n  version?: string;\n\n  /**\n   * Optional. SAS protocols, HTTPS only or HTTPSandHTTP\n   */\n  protocol?: SASProtocol;\n\n  /**\n   * Optional. When the SAS will take effect.\n   */\n  startsOn?: Date;\n\n  /**\n   * Optional only when identifier is provided. The time after which the SAS will no longer work.\n   */\n  expiresOn?: Date;\n\n  /**\n   * Optional. IP ranges allowed in this SAS.\n   */\n  ipRange?: SasIPRange;\n\n  /**\n   * Optional. The name of the access policy on the container this SAS references if any.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/establishing-a-stored-access-policy\n   */\n  identifier?: string;\n\n  /**\n   * Optional. Encryption scope to use when sending requests authorized with this SAS URI.\n   */\n  encryptionScope?: string;\n\n  /**\n   * Optional. The cache-control header for the SAS.\n   */\n  cacheControl?: string;\n\n  /**\n   * Optional. The content-disposition header for the SAS.\n   */\n  contentDisposition?: string;\n\n  /**\n   * Optional. The content-encoding header for the SAS.\n   */\n  contentEncoding?: string;\n\n  /**\n   * Optional. The content-language header for the SAS.\n   */\n  contentLanguage?: string;\n\n  /**\n   * Optional. The content-type header for the SAS.\n   */\n  contentType?: string;\n}\n\n/**\n * Options to configure {@link BlobClient.generateSasUrl} operation.\n */\nexport interface BlobGenerateSasUrlOptions extends CommonGenerateSasUrlOptions {\n  /**\n   * Optional only when identifier is provided. Specifies the list of permissions to be associated with the SAS.\n   */\n  permissions?: BlobSASPermissions;\n}\n\n/**\n * Options for deleting immutability policy {@link BlobClient.deleteImmutabilityPolicy} operation.\n */\nexport interface BlobDeleteImmutabilityPolicyOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * Options for setting immutability policy {@link BlobClient.setImmutabilityPolicy} operation.\n */\nexport interface BlobSetImmutabilityPolicyOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  modifiedAccessCondition?: ModificationConditions;\n}\n\n/**\n * Options for setting legal hold {@link BlobClient.setLegalHold} operation.\n */\nexport interface BlobSetLegalHoldOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * A BlobClient represents a URL to an Azure Storage blob; the blob may be a block blob,\n * append blob, or page blob.\n */\nexport class BlobClient extends StorageClient {\n  /**\n   * blobContext provided by protocol layer.\n   */\n  private blobContext: StorageBlob;\n\n  private _name: string;\n  private _containerName: string;\n\n  private _versionId?: string;\n  private _snapshot?: string;\n\n  /**\n   * The name of the blob.\n   */\n  public get name(): string {\n    return this._name;\n  }\n\n  /**\n   * The name of the storage container the blob is associated with.\n   */\n  public get containerName(): string {\n    return this._containerName;\n  }\n\n  /**\n   *\n   * Creates an instance of BlobClient from connection string.\n   *\n   * @param connectionString - Account connection string or a SAS connection string of an Azure storage account.\n   *                                  [ Note - Account connection string can only be used in NODE.JS runtime. ]\n   *                                  Account connection string example -\n   *                                  `DefaultEndpointsProtocol=https;AccountName=myaccount;AccountKey=accountKey;EndpointSuffix=core.windows.net`\n   *                                  SAS connection string example -\n   *                                  `BlobEndpoint=https://myaccount.blob.core.windows.net/;QueueEndpoint=https://myaccount.queue.core.windows.net/;FileEndpoint=https://myaccount.file.core.windows.net/;TableEndpoint=https://myaccount.table.core.windows.net/;SharedAccessSignature=sasString`\n   * @param containerName - Container name.\n   * @param blobName - Blob name.\n   * @param options - Optional. Options to configure the HTTP pipeline.\n   */\n  constructor(\n    connectionString: string,\n    containerName: string,\n    blobName: string,\n    // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n    options?: StoragePipelineOptions\n  );\n  /**\n   * Creates an instance of BlobClient.\n   * This method accepts an encoded URL or non-encoded URL pointing to a blob.\n   * Encoded URL string will NOT be escaped twice, only special characters in URL path will be escaped.\n   * If a blob name includes ? or %, blob name must be encoded in the URL.\n   *\n   * @param url - A Client string pointing to Azure Storage blob service, such as\n   *                     \"https://myaccount.blob.core.windows.net\". You can append a SAS\n   *                     if using AnonymousCredential, such as \"https://myaccount.blob.core.windows.net?sasString\".\n   * @param credential -  Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.\n   * @param options - Optional. Options to configure the HTTP pipeline.\n   */\n  constructor(\n    url: string,\n    credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential,\n    // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n    options?: StoragePipelineOptions\n  );\n  /**\n   * Creates an instance of BlobClient.\n   * This method accepts an encoded URL or non-encoded URL pointing to a blob.\n   * Encoded URL string will NOT be escaped twice, only special characters in URL path will be escaped.\n   * If a blob name includes ? or %, blob name must be encoded in the URL.\n   *\n   * @param url - A URL string pointing to Azure Storage blob, such as\n   *                     \"https://myaccount.blob.core.windows.net/mycontainer/blob\".\n   *                     You can append a SAS if using AnonymousCredential, such as\n   *                     \"https://myaccount.blob.core.windows.net/mycontainer/blob?sasString\".\n   *                     This method accepts an encoded URL or non-encoded URL pointing to a blob.\n   *                     Encoded URL string will NOT be escaped twice, only special characters in URL path will be escaped.\n   *                     However, if a blob name includes ? or %, blob name must be encoded in the URL.\n   *                     Such as a blob named \"my?blob%\", the URL should be \"https://myaccount.blob.core.windows.net/mycontainer/my%3Fblob%25\".\n   * @param pipeline - Call newPipeline() to create a default\n   *                            pipeline, or provide a customized pipeline.\n   */\n  constructor(url: string, pipeline: PipelineLike);\n  constructor(\n    urlOrConnectionString: string,\n    credentialOrPipelineOrContainerName?:\n      | string\n      | StorageSharedKeyCredential\n      | AnonymousCredential\n      | TokenCredential\n      | PipelineLike,\n    blobNameOrOptions?: string | StoragePipelineOptions,\n    // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n    options?: StoragePipelineOptions\n  ) {\n    options = options || {};\n    let pipeline: PipelineLike;\n    let url: string;\n    if (isPipelineLike(credentialOrPipelineOrContainerName)) {\n      // (url: string, pipeline: Pipeline)\n      url = urlOrConnectionString;\n      pipeline = credentialOrPipelineOrContainerName;\n    } else if (\n      (isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential) ||\n      credentialOrPipelineOrContainerName instanceof AnonymousCredential ||\n      isTokenCredential(credentialOrPipelineOrContainerName)\n    ) {\n      // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n      url = urlOrConnectionString;\n      options = blobNameOrOptions as StoragePipelineOptions;\n      pipeline = newPipeline(credentialOrPipelineOrContainerName, options);\n    } else if (\n      !credentialOrPipelineOrContainerName &&\n      typeof credentialOrPipelineOrContainerName !== \"string\"\n    ) {\n      // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n      // The second parameter is undefined. Use anonymous credential.\n      url = urlOrConnectionString;\n      pipeline = newPipeline(new AnonymousCredential(), options);\n    } else if (\n      credentialOrPipelineOrContainerName &&\n      typeof credentialOrPipelineOrContainerName === \"string\" &&\n      blobNameOrOptions &&\n      typeof blobNameOrOptions === \"string\"\n    ) {\n      // (connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions)\n      const containerName = credentialOrPipelineOrContainerName;\n      const blobName = blobNameOrOptions;\n\n      const extractedCreds = extractConnectionStringParts(urlOrConnectionString);\n      if (extractedCreds.kind === \"AccountConnString\") {\n        if (isNode) {\n          const sharedKeyCredential = new StorageSharedKeyCredential(\n            extractedCreds.accountName!,\n            extractedCreds.accountKey\n          );\n          url = appendToURLPath(\n            appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)),\n            encodeURIComponent(blobName)\n          );\n\n          if (!options.proxyOptions) {\n            options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);\n          }\n\n          pipeline = newPipeline(sharedKeyCredential, options);\n        } else {\n          throw new Error(\"Account connection string is only supported in Node.js environment\");\n        }\n      } else if (extractedCreds.kind === \"SASConnString\") {\n        url =\n          appendToURLPath(\n            appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)),\n            encodeURIComponent(blobName)\n          ) +\n          \"?\" +\n          extractedCreds.accountSas;\n        pipeline = newPipeline(new AnonymousCredential(), options);\n      } else {\n        throw new Error(\n          \"Connection string must be either an Account connection string or a SAS connection string\"\n        );\n      }\n    } else {\n      throw new Error(\"Expecting non-empty strings for containerName and blobName parameters\");\n    }\n\n    super(url, pipeline);\n    ({ blobName: this._name, containerName: this._containerName } =\n      this.getBlobAndContainerNamesFromUrl());\n    this.blobContext = new StorageBlob(this.storageClientContext);\n\n    this._snapshot = getURLParameter(this.url, URLConstants.Parameters.SNAPSHOT) as string;\n    this._versionId = getURLParameter(this.url, URLConstants.Parameters.VERSIONID) as string;\n  }\n\n  /**\n   * Creates a new BlobClient object identical to the source but with the specified snapshot timestamp.\n   * Provide \"\" will remove the snapshot and return a Client to the base blob.\n   *\n   * @param snapshot - The snapshot timestamp.\n   * @returns A new BlobClient object identical to the source but with the specified snapshot timestamp\n   */\n  public withSnapshot(snapshot: string): BlobClient {\n    return new BlobClient(\n      setURLParameter(\n        this.url,\n        URLConstants.Parameters.SNAPSHOT,\n        snapshot.length === 0 ? undefined : snapshot\n      ),\n      this.pipeline\n    );\n  }\n\n  /**\n   * Creates a new BlobClient object pointing to a version of this blob.\n   * Provide \"\" will remove the versionId and return a Client to the base blob.\n   *\n   * @param versionId - The versionId.\n   * @returns A new BlobClient object pointing to the version of this blob.\n   */\n  public withVersion(versionId: string): BlobClient {\n    return new BlobClient(\n      setURLParameter(\n        this.url,\n        URLConstants.Parameters.VERSIONID,\n        versionId.length === 0 ? undefined : versionId\n      ),\n      this.pipeline\n    );\n  }\n\n  /**\n   * Creates a AppendBlobClient object.\n   *\n   */\n  public getAppendBlobClient(): AppendBlobClient {\n    return new AppendBlobClient(this.url, this.pipeline);\n  }\n\n  /**\n   * Creates a BlockBlobClient object.\n   *\n   */\n  public getBlockBlobClient(): BlockBlobClient {\n    return new BlockBlobClient(this.url, this.pipeline);\n  }\n\n  /**\n   * Creates a PageBlobClient object.\n   *\n   */\n  public getPageBlobClient(): PageBlobClient {\n    return new PageBlobClient(this.url, this.pipeline);\n  }\n\n  /**\n   * Reads or downloads a blob from the system, including its metadata and properties.\n   * You can also call Get Blob to read a snapshot.\n   *\n   * * In Node.js, data returns in a Readable stream readableStreamBody\n   * * In browsers, data returns in a promise blobBody\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-blob\n   *\n   * @param offset - From which position of the blob to download, greater than or equal to 0\n   * @param count - How much data to be downloaded, greater than 0. Will download to the end when undefined\n   * @param options - Optional options to Blob Download operation.\n   *\n   *\n   * Example usage (Node.js):\n   *\n   * ```js\n   * // Download and convert a blob to a string\n   * const downloadBlockBlobResponse = await blobClient.download();\n   * const downloaded = await streamToBuffer(downloadBlockBlobResponse.readableStreamBody);\n   * console.log(\"Downloaded blob content:\", downloaded.toString());\n   *\n   * async function streamToBuffer(readableStream) {\n   * return new Promise((resolve, reject) => {\n   * const chunks = [];\n   * readableStream.on(\"data\", (data) => {\n   * chunks.push(data instanceof Buffer ? data : Buffer.from(data));\n   * });\n   * readableStream.on(\"end\", () => {\n   * resolve(Buffer.concat(chunks));\n   * });\n   * readableStream.on(\"error\", reject);\n   * });\n   * }\n   * ```\n   *\n   * Example usage (browser):\n   *\n   * ```js\n   * // Download and convert a blob to a string\n   * const downloadBlockBlobResponse = await blobClient.download();\n   * const downloaded = await blobToString(await downloadBlockBlobResponse.blobBody);\n   * console.log(\n   *   \"Downloaded blob content\",\n   *   downloaded\n   * );\n   *\n   * async function blobToString(blob: Blob): Promise<string> {\n   *   const fileReader = new FileReader();\n   *   return new Promise<string>((resolve, reject) => {\n   *     fileReader.onloadend = (ev: any) => {\n   *       resolve(ev.target!.result);\n   *     };\n   *     fileReader.onerror = reject;\n   *     fileReader.readAsText(blob);\n   *   });\n   * }\n   * ```\n   */\n  public async download(\n    offset: number = 0,\n    count?: number,\n    options: BlobDownloadOptions = {}\n  ): Promise<BlobDownloadResponseParsed> {\n    options.conditions = options.conditions || {};\n    options.conditions = options.conditions || {};\n    ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n\n    const { span, updatedOptions } = createSpan(\"BlobClient-download\", options);\n\n    try {\n      const res = await this.blobContext.download({\n        abortSignal: options.abortSignal,\n        leaseAccessConditions: options.conditions,\n        modifiedAccessConditions: {\n          ...options.conditions,\n          ifTags: options.conditions?.tagConditions,\n        },\n        requestOptions: {\n          onDownloadProgress: isNode ? undefined : options.onProgress, // for Node.js, progress is reported by RetriableReadableStream\n        },\n        range: offset === 0 && !count ? undefined : rangeToString({ offset, count }),\n        rangeGetContentMD5: options.rangeGetContentMD5,\n        rangeGetContentCRC64: options.rangeGetContentCrc64,\n        snapshot: options.snapshot,\n        cpkInfo: options.customerProvidedKey,\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n\n      const wrappedRes = {\n        ...res,\n        _response: res._response, // _response is made non-enumerable\n        objectReplicationDestinationPolicyId: res.objectReplicationPolicyId,\n        objectReplicationSourceProperties: parseObjectReplicationRecord(res.objectReplicationRules),\n      };\n      // Return browser response immediately\n      if (!isNode) {\n        return wrappedRes;\n      }\n\n      // We support retrying when download stream unexpected ends in Node.js runtime\n      // Following code shouldn't be bundled into browser build, however some\n      // bundlers may try to bundle following code and \"FileReadResponse.ts\".\n      // In this case, \"FileDownloadResponse.browser.ts\" will be used as a shim of \"FileDownloadResponse.ts\"\n      // The config is in package.json \"browser\" field\n      if (options.maxRetryRequests === undefined || options.maxRetryRequests < 0) {\n        // TODO: Default value or make it a required parameter?\n        options.maxRetryRequests = DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS;\n      }\n\n      if (res.contentLength === undefined) {\n        throw new RangeError(`File download response doesn't contain valid content length header`);\n      }\n\n      if (!res.etag) {\n        throw new RangeError(`File download response doesn't contain valid etag header`);\n      }\n\n      return new BlobDownloadResponse(\n        wrappedRes,\n        async (start: number): Promise<NodeJS.ReadableStream> => {\n          const updatedDownloadOptions: BlobDownloadOptionalParams = {\n            leaseAccessConditions: options.conditions,\n            modifiedAccessConditions: {\n              ifMatch: options.conditions!.ifMatch || res.etag,\n              ifModifiedSince: options.conditions!.ifModifiedSince,\n              ifNoneMatch: options.conditions!.ifNoneMatch,\n              ifUnmodifiedSince: options.conditions!.ifUnmodifiedSince,\n              ifTags: options.conditions?.tagConditions,\n            },\n            range: rangeToString({\n              count: offset + res.contentLength! - start,\n              offset: start,\n            }),\n            rangeGetContentMD5: options.rangeGetContentMD5,\n            rangeGetContentCRC64: options.rangeGetContentCrc64,\n            snapshot: options.snapshot,\n            cpkInfo: options.customerProvidedKey,\n          };\n\n          // Debug purpose only\n          // console.log(\n          //   `Read from internal stream, range: ${\n          //     updatedOptions.range\n          //   }, options: ${JSON.stringify(updatedOptions)}`\n          // );\n\n          return (\n            await this.blobContext.download({\n              abortSignal: options.abortSignal,\n              ...updatedDownloadOptions,\n            })\n          ).readableStreamBody!;\n        },\n        offset,\n        res.contentLength!,\n        {\n          maxRetryRequests: options.maxRetryRequests,\n          onProgress: options.onProgress,\n        }\n      );\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Returns true if the Azure blob resource represented by this client exists; false otherwise.\n   *\n   * NOTE: use this function with care since an existing blob might be deleted by other clients or\n   * applications. Vice versa new blobs might be added by other clients or applications after this\n   * function completes.\n   *\n   * @param options - options to Exists operation.\n   */\n  public async exists(options: BlobExistsOptions = {}): Promise<boolean> {\n    const { span, updatedOptions } = createSpan(\"BlobClient-exists\", options);\n    try {\n      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n      await this.getProperties({\n        abortSignal: options.abortSignal,\n        customerProvidedKey: options.customerProvidedKey,\n        conditions: options.conditions,\n        tracingOptions: updatedOptions.tracingOptions,\n      });\n      return true;\n    } catch (e: any) {\n      if (e.statusCode === 404) {\n        // Expected exception when checking blob existence\n        return false;\n      } else if (\n        e.statusCode === 409 &&\n        (e.details.errorCode === BlobUsesCustomerSpecifiedEncryptionMsg ||\n          e.details.errorCode === BlobDoesNotUseCustomerSpecifiedEncryption)\n      ) {\n        // Expected exception when checking blob existence\n        return true;\n      }\n\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Returns all user-defined metadata, standard HTTP properties, and system properties\n   * for the blob. It does not return the content of the blob.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-blob-properties\n   *\n   * WARNING: The `metadata` object returned in the response will have its keys in lowercase, even if\n   * they originally contained uppercase characters. This differs from the metadata keys returned by\n   * the methods of {@link ContainerClient} that list blobs using the `includeMetadata` option, which\n   * will retain their original casing.\n   *\n   * @param options - Optional options to Get Properties operation.\n   */\n  public async getProperties(\n    options: BlobGetPropertiesOptions = {}\n  ): Promise<BlobGetPropertiesResponse> {\n    const { span, updatedOptions } = createSpan(\"BlobClient-getProperties\", options);\n    try {\n      options.conditions = options.conditions || {};\n      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n      const res = await this.blobContext.getProperties({\n        abortSignal: options.abortSignal,\n        leaseAccessConditions: options.conditions,\n        modifiedAccessConditions: {\n          ...options.conditions,\n          ifTags: options.conditions?.tagConditions,\n        },\n        cpkInfo: options.customerProvidedKey,\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n\n      return {\n        ...res,\n        _response: res._response, // _response is made non-enumerable\n        objectReplicationDestinationPolicyId: res.objectReplicationPolicyId,\n        objectReplicationSourceProperties: parseObjectReplicationRecord(res.objectReplicationRules),\n      };\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Marks the specified blob or snapshot for deletion. The blob is later deleted\n   * during garbage collection. Note that in order to delete a blob, you must delete\n   * all of its snapshots. You can delete both at the same time with the Delete\n   * Blob operation.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-blob\n   *\n   * @param options - Optional options to Blob Delete operation.\n   */\n  public async delete(options: BlobDeleteOptions = {}): Promise<BlobDeleteResponse> {\n    const { span, updatedOptions } = createSpan(\"BlobClient-delete\", options);\n    options.conditions = options.conditions || {};\n    try {\n      return await this.blobContext.delete({\n        abortSignal: options.abortSignal,\n        deleteSnapshots: options.deleteSnapshots,\n        leaseAccessConditions: options.conditions,\n        modifiedAccessConditions: {\n          ...options.conditions,\n          ifTags: options.conditions?.tagConditions,\n        },\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Marks the specified blob or snapshot for deletion if it exists. The blob is later deleted\n   * during garbage collection. Note that in order to delete a blob, you must delete\n   * all of its snapshots. You can delete both at the same time with the Delete\n   * Blob operation.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-blob\n   *\n   * @param options - Optional options to Blob Delete operation.\n   */\n  public async deleteIfExists(\n    options: BlobDeleteOptions = {}\n  ): Promise<BlobDeleteIfExistsResponse> {\n    const { span, updatedOptions } = createSpan(\"BlobClient-deleteIfExists\", options);\n    try {\n      const res = await this.delete(updatedOptions);\n      return {\n        succeeded: true,\n        ...res,\n        _response: res._response, // _response is made non-enumerable\n      };\n    } catch (e: any) {\n      if (e.details?.errorCode === \"BlobNotFound\") {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: \"Expected exception when deleting a blob or snapshot only if it exists.\",\n        });\n        return {\n          succeeded: false,\n          ...e.response?.parsedHeaders,\n          _response: e.response,\n        };\n      }\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Restores the contents and metadata of soft deleted blob and any associated\n   * soft deleted snapshots. Undelete Blob is supported only on version 2017-07-29\n   * or later.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/undelete-blob\n   *\n   * @param options - Optional options to Blob Undelete operation.\n   */\n  public async undelete(options: BlobUndeleteOptions = {}): Promise<BlobUndeleteResponse> {\n    const { span, updatedOptions } = createSpan(\"BlobClient-undelete\", options);\n    try {\n      return await this.blobContext.undelete({\n        abortSignal: options.abortSignal,\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Sets system properties on the blob.\n   *\n   * If no value provided, or no value provided for the specified blob HTTP headers,\n   * these blob HTTP headers without a value will be cleared.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-properties\n   *\n   * @param blobHTTPHeaders - If no value provided, or no value provided for\n   *                                                   the specified blob HTTP headers, these blob HTTP\n   *                                                   headers without a value will be cleared.\n   *                                                   A common header to set is `blobContentType`\n   *                                                   enabling the browser to provide functionality\n   *                                                   based on file type.\n   * @param options - Optional options to Blob Set HTTP Headers operation.\n   */\n  public async setHTTPHeaders(\n    blobHTTPHeaders?: BlobHTTPHeaders,\n    options: BlobSetHTTPHeadersOptions = {}\n  ): Promise<BlobSetHTTPHeadersResponse> {\n    const { span, updatedOptions } = createSpan(\"BlobClient-setHTTPHeaders\", options);\n    options.conditions = options.conditions || {};\n    try {\n      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n      return await this.blobContext.setHttpHeaders({\n        abortSignal: options.abortSignal,\n        blobHttpHeaders: blobHTTPHeaders,\n        leaseAccessConditions: options.conditions,\n        modifiedAccessConditions: {\n          ...options.conditions,\n          ifTags: options.conditions?.tagConditions,\n        },\n        // cpkInfo: options.customerProvidedKey, // CPK is not included in Swagger, should change this back when this issue is fixed in Swagger.\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Sets user-defined metadata for the specified blob as one or more name-value pairs.\n   *\n   * If no option provided, or no metadata defined in the parameter, the blob\n   * metadata will be removed.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-metadata\n   *\n   * @param metadata - Replace existing metadata with this value.\n   *                               If no value provided the existing metadata will be removed.\n   * @param options - Optional options to Set Metadata operation.\n   */\n  public async setMetadata(\n    metadata?: Metadata,\n    options: BlobSetMetadataOptions = {}\n  ): Promise<BlobSetMetadataResponse> {\n    const { span, updatedOptions } = createSpan(\"BlobClient-setMetadata\", options);\n    options.conditions = options.conditions || {};\n    try {\n      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n      return await this.blobContext.setMetadata({\n        abortSignal: options.abortSignal,\n        leaseAccessConditions: options.conditions,\n        metadata,\n        modifiedAccessConditions: {\n          ...options.conditions,\n          ifTags: options.conditions?.tagConditions,\n        },\n        cpkInfo: options.customerProvidedKey,\n        encryptionScope: options.encryptionScope,\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Sets tags on the underlying blob.\n   * A blob can have up to 10 tags. Tag keys must be between 1 and 128 characters.  Tag values must be between 0 and 256 characters.\n   * Valid tag key and value characters include lower and upper case letters, digits (0-9),\n   * space (' '), plus ('+'), minus ('-'), period ('.'), foward slash ('/'), colon (':'), equals ('='), and underscore ('_').\n   *\n   * @param tags -\n   * @param options -\n   */\n  public async setTags(tags: Tags, options: BlobSetTagsOptions = {}): Promise<BlobSetTagsResponse> {\n    const { span, updatedOptions } = createSpan(\"BlobClient-setTags\", options);\n    try {\n      return await this.blobContext.setTags({\n        abortSignal: options.abortSignal,\n        leaseAccessConditions: options.conditions,\n        modifiedAccessConditions: {\n          ...options.conditions,\n          ifTags: options.conditions?.tagConditions,\n        },\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n        tags: toBlobTags(tags),\n      });\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Gets the tags associated with the underlying blob.\n   *\n   * @param options -\n   */\n  public async getTags(options: BlobGetTagsOptions = {}): Promise<BlobGetTagsResponse> {\n    const { span, updatedOptions } = createSpan(\"BlobClient-getTags\", options);\n    try {\n      const response = await this.blobContext.getTags({\n        abortSignal: options.abortSignal,\n        leaseAccessConditions: options.conditions,\n        modifiedAccessConditions: {\n          ...options.conditions,\n          ifTags: options.conditions?.tagConditions,\n        },\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n      const wrappedResponse: BlobGetTagsResponse = {\n        ...response,\n        _response: response._response, // _response is made non-enumerable\n        tags: toTags({ blobTagSet: response.blobTagSet }) || {},\n      };\n      return wrappedResponse;\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Get a {@link BlobLeaseClient} that manages leases on the blob.\n   *\n   * @param proposeLeaseId - Initial proposed lease Id.\n   * @returns A new BlobLeaseClient object for managing leases on the blob.\n   */\n  public getBlobLeaseClient(proposeLeaseId?: string): BlobLeaseClient {\n    return new BlobLeaseClient(this, proposeLeaseId);\n  }\n\n  /**\n   * Creates a read-only snapshot of a blob.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/snapshot-blob\n   *\n   * @param options - Optional options to the Blob Create Snapshot operation.\n   */\n  public async createSnapshot(\n    options: BlobCreateSnapshotOptions = {}\n  ): Promise<BlobCreateSnapshotResponse> {\n    const { span, updatedOptions } = createSpan(\"BlobClient-createSnapshot\", options);\n    options.conditions = options.conditions || {};\n    try {\n      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n      return await this.blobContext.createSnapshot({\n        abortSignal: options.abortSignal,\n        leaseAccessConditions: options.conditions,\n        metadata: options.metadata,\n        modifiedAccessConditions: {\n          ...options.conditions,\n          ifTags: options.conditions?.tagConditions,\n        },\n        cpkInfo: options.customerProvidedKey,\n        encryptionScope: options.encryptionScope,\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Asynchronously copies a blob to a destination within the storage account.\n   * This method returns a long running operation poller that allows you to wait\n   * indefinitely until the copy is completed.\n   * You can also cancel a copy before it is completed by calling `cancelOperation` on the poller.\n   * Note that the onProgress callback will not be invoked if the operation completes in the first\n   * request, and attempting to cancel a completed copy will result in an error being thrown.\n   *\n   * In version 2012-02-12 and later, the source for a Copy Blob operation can be\n   * a committed blob in any Azure storage account.\n   * Beginning with version 2015-02-21, the source for a Copy Blob operation can be\n   * an Azure file in any Azure storage account.\n   * Only storage accounts created on or after June 7th, 2012 allow the Copy Blob\n   * operation to copy from another storage account.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/copy-blob\n   *\n   * Example using automatic polling:\n   *\n   * ```js\n   * const copyPoller = await blobClient.beginCopyFromURL('url');\n   * const result = await copyPoller.pollUntilDone();\n   * ```\n   *\n   * Example using manual polling:\n   *\n   * ```js\n   * const copyPoller = await blobClient.beginCopyFromURL('url');\n   * while (!poller.isDone()) {\n   *    await poller.poll();\n   * }\n   * const result = copyPoller.getResult();\n   * ```\n   *\n   * Example using progress updates:\n   *\n   * ```js\n   * const copyPoller = await blobClient.beginCopyFromURL('url', {\n   *   onProgress(state) {\n   *     console.log(`Progress: ${state.copyProgress}`);\n   *   }\n   * });\n   * const result = await copyPoller.pollUntilDone();\n   * ```\n   *\n   * Example using a changing polling interval (default 15 seconds):\n   *\n   * ```js\n   * const copyPoller = await blobClient.beginCopyFromURL('url', {\n   *   intervalInMs: 1000 // poll blob every 1 second for copy progress\n   * });\n   * const result = await copyPoller.pollUntilDone();\n   * ```\n   *\n   * Example using copy cancellation:\n   *\n   * ```js\n   * const copyPoller = await blobClient.beginCopyFromURL('url');\n   * // cancel operation after starting it.\n   * try {\n   *   await copyPoller.cancelOperation();\n   *   // calls to get the result now throw PollerCancelledError\n   *   await copyPoller.getResult();\n   * } catch (err) {\n   *   if (err.name === 'PollerCancelledError') {\n   *     console.log('The copy was cancelled.');\n   *   }\n   * }\n   * ```\n   *\n   * @param copySource - url to the source Azure Blob/File.\n   * @param options - Optional options to the Blob Start Copy From URL operation.\n   */\n  public async beginCopyFromURL(\n    copySource: string,\n    options: BlobBeginCopyFromURLOptions = {}\n  ): Promise<\n    PollerLikeWithCancellation<\n      PollOperationState<BlobBeginCopyFromURLResponse>,\n      BlobBeginCopyFromURLResponse\n    >\n  > {\n    const client: CopyPollerBlobClient = {\n      abortCopyFromURL: (...args) => this.abortCopyFromURL(...args),\n      getProperties: (...args) => this.getProperties(...args),\n      startCopyFromURL: (...args) => this.startCopyFromURL(...args),\n    };\n    const poller = new BlobBeginCopyFromUrlPoller({\n      blobClient: client,\n      copySource,\n      intervalInMs: options.intervalInMs,\n      onProgress: options.onProgress,\n      resumeFrom: options.resumeFrom,\n      startCopyFromURLOptions: options,\n    });\n\n    // Trigger the startCopyFromURL call by calling poll.\n    // Any errors from this method should be surfaced to the user.\n    await poller.poll();\n\n    return poller;\n  }\n\n  /**\n   * Aborts a pending asynchronous Copy Blob operation, and leaves a destination blob with zero\n   * length and full metadata. Version 2012-02-12 and newer.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/abort-copy-blob\n   *\n   * @param copyId - Id of the Copy From URL operation.\n   * @param options - Optional options to the Blob Abort Copy From URL operation.\n   */\n  public async abortCopyFromURL(\n    copyId: string,\n    options: BlobAbortCopyFromURLOptions = {}\n  ): Promise<BlobAbortCopyFromURLResponse> {\n    const { span, updatedOptions } = createSpan(\"BlobClient-abortCopyFromURL\", options);\n    try {\n      return await this.blobContext.abortCopyFromURL(copyId, {\n        abortSignal: options.abortSignal,\n        leaseAccessConditions: options.conditions,\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * The synchronous Copy From URL operation copies a blob or an internet resource to a new blob. It will not\n   * return a response until the copy is complete.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/copy-blob-from-url\n   *\n   * @param copySource - The source URL to copy from, Shared Access Signature(SAS) maybe needed for authentication\n   * @param options -\n   */\n  public async syncCopyFromURL(\n    copySource: string,\n    options: BlobSyncCopyFromURLOptions = {}\n  ): Promise<BlobCopyFromURLResponse> {\n    const { span, updatedOptions } = createSpan(\"BlobClient-syncCopyFromURL\", options);\n    options.conditions = options.conditions || {};\n    options.sourceConditions = options.sourceConditions || {};\n\n    try {\n      return await this.blobContext.copyFromURL(copySource, {\n        abortSignal: options.abortSignal,\n        metadata: options.metadata,\n        leaseAccessConditions: options.conditions,\n        modifiedAccessConditions: {\n          ...options.conditions,\n          ifTags: options.conditions?.tagConditions,\n        },\n        sourceModifiedAccessConditions: {\n          sourceIfMatch: options.sourceConditions.ifMatch,\n          sourceIfModifiedSince: options.sourceConditions.ifModifiedSince,\n          sourceIfNoneMatch: options.sourceConditions.ifNoneMatch,\n          sourceIfUnmodifiedSince: options.sourceConditions.ifUnmodifiedSince,\n        },\n        sourceContentMD5: options.sourceContentMD5,\n        copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization),\n        blobTagsString: toBlobTagsString(options.tags),\n        immutabilityPolicyExpiry: options.immutabilityPolicy?.expiriesOn,\n        immutabilityPolicyMode: options.immutabilityPolicy?.policyMode,\n        legalHold: options.legalHold,\n        encryptionScope: options.encryptionScope,\n        copySourceTags: options.copySourceTags,\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Sets the tier on a blob. The operation is allowed on a page blob in a premium\n   * storage account and on a block blob in a blob storage account (locally redundant\n   * storage only). A premium page blob's tier determines the allowed size, IOPS,\n   * and bandwidth of the blob. A block blob's tier determines Hot/Cool/Archive\n   * storage type. This operation does not update the blob's ETag.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-tier\n   *\n   * @param tier - The tier to be set on the blob. Valid values are Hot, Cool, or Archive.\n   * @param options - Optional options to the Blob Set Tier operation.\n   */\n  public async setAccessTier(\n    tier: BlockBlobTier | PremiumPageBlobTier | string,\n    options: BlobSetTierOptions = {}\n  ): Promise<BlobSetTierResponse> {\n    const { span, updatedOptions } = createSpan(\"BlobClient-setAccessTier\", options);\n    try {\n      return await this.blobContext.setTier(toAccessTier(tier)!, {\n        abortSignal: options.abortSignal,\n        leaseAccessConditions: options.conditions,\n        modifiedAccessConditions: {\n          ...options.conditions,\n          ifTags: options.conditions?.tagConditions,\n        },\n        rehydratePriority: options.rehydratePriority,\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  // High level function\n\n  /**\n   * ONLY AVAILABLE IN NODE.JS RUNTIME.\n   *\n   * Downloads an Azure Blob in parallel to a buffer.\n   * Offset and count are optional, downloads the entire blob if they are not provided.\n   *\n   * Warning: Buffers can only support files up to about one gigabyte on 32-bit systems or about two\n   * gigabytes on 64-bit systems due to limitations of Node.js/V8. For blobs larger than this size,\n   * consider {@link downloadToFile}.\n   *\n   * @param offset - From which position of the block blob to download(in bytes)\n   * @param count - How much data(in bytes) to be downloaded. Will download to the end when passing undefined\n   * @param options - BlobDownloadToBufferOptions\n   */\n  public async downloadToBuffer(\n    offset?: number,\n    count?: number,\n    options?: BlobDownloadToBufferOptions\n  ): Promise<Buffer>;\n\n  /**\n   * ONLY AVAILABLE IN NODE.JS RUNTIME.\n   *\n   * Downloads an Azure Blob in parallel to a buffer.\n   * Offset and count are optional, downloads the entire blob if they are not provided.\n   *\n   * Warning: Buffers can only support files up to about one gigabyte on 32-bit systems or about two\n   * gigabytes on 64-bit systems due to limitations of Node.js/V8. For blobs larger than this size,\n   * consider {@link downloadToFile}.\n   *\n   * @param buffer - Buffer to be fill, must have length larger than count\n   * @param offset - From which position of the block blob to download(in bytes)\n   * @param count - How much data(in bytes) to be downloaded. Will download to the end when passing undefined\n   * @param options - BlobDownloadToBufferOptions\n   */\n  public async downloadToBuffer(\n    buffer: Buffer,\n    offset?: number,\n    count?: number,\n    options?: BlobDownloadToBufferOptions\n  ): Promise<Buffer>;\n\n  public async downloadToBuffer(\n    param1?: Buffer | number,\n    param2?: number,\n    param3?: BlobDownloadToBufferOptions | number,\n    param4: BlobDownloadToBufferOptions = {}\n  ): Promise<Buffer | undefined> {\n    let buffer: Buffer | undefined;\n    let offset = 0;\n    let count = 0;\n    let options = param4;\n    if (param1 instanceof Buffer) {\n      buffer = param1;\n      offset = param2 || 0;\n      count = typeof param3 === \"number\" ? param3 : 0;\n    } else {\n      offset = typeof param1 === \"number\" ? param1 : 0;\n      count = typeof param2 === \"number\" ? param2 : 0;\n      options = (param3 as BlobDownloadToBufferOptions) || {};\n    }\n    const { span, updatedOptions } = createSpan(\"BlobClient-downloadToBuffer\", options);\n\n    try {\n      if (!options.blockSize) {\n        options.blockSize = 0;\n      }\n      if (options.blockSize < 0) {\n        throw new RangeError(\"blockSize option must be >= 0\");\n      }\n      if (options.blockSize === 0) {\n        options.blockSize = DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES;\n      }\n\n      if (offset < 0) {\n        throw new RangeError(\"offset option must be >= 0\");\n      }\n\n      if (count && count <= 0) {\n        throw new RangeError(\"count option must be greater than 0\");\n      }\n\n      if (!options.conditions) {\n        options.conditions = {};\n      }\n\n      // Customer doesn't specify length, get it\n      if (!count) {\n        const response = await this.getProperties({\n          ...options,\n          tracingOptions: {\n            ...options.tracingOptions,\n            ...convertTracingToRequestOptionsBase(updatedOptions),\n          },\n        });\n        count = response.contentLength! - offset;\n        if (count < 0) {\n          throw new RangeError(\n            `offset ${offset} shouldn't be larger than blob size ${response.contentLength!}`\n          );\n        }\n      }\n\n      // Allocate the buffer of size = count if the buffer is not provided\n      if (!buffer) {\n        try {\n          buffer = Buffer.alloc(count);\n        } catch (error: any) {\n          throw new Error(\n            `Unable to allocate the buffer of size: ${count}(in bytes). Please try passing your own buffer to the \"downloadToBuffer\" method or try using other methods like \"download\" or \"downloadToFile\".\\t ${error.message}`\n          );\n        }\n      }\n\n      if (buffer.length < count) {\n        throw new RangeError(\n          `The buffer's size should be equal to or larger than the request count of bytes: ${count}`\n        );\n      }\n\n      let transferProgress: number = 0;\n      const batch = new Batch(options.concurrency);\n      for (let off = offset; off < offset + count; off = off + options.blockSize) {\n        batch.addOperation(async () => {\n          // Exclusive chunk end position\n          let chunkEnd = offset + count!;\n          if (off + options.blockSize! < chunkEnd) {\n            chunkEnd = off + options.blockSize!;\n          }\n          const response = await this.download(off, chunkEnd - off, {\n            abortSignal: options.abortSignal,\n            conditions: options.conditions,\n            maxRetryRequests: options.maxRetryRequestsPerBlock,\n            customerProvidedKey: options.customerProvidedKey,\n            tracingOptions: {\n              ...options.tracingOptions,\n              ...convertTracingToRequestOptionsBase(updatedOptions),\n            },\n          });\n          const stream = response.readableStreamBody!;\n          await streamToBuffer(stream, buffer!, off - offset, chunkEnd - offset);\n          // Update progress after block is downloaded, in case of block trying\n          // Could provide finer grained progress updating inside HTTP requests,\n          // only if convenience layer download try is enabled\n          transferProgress += chunkEnd - off;\n          if (options.onProgress) {\n            options.onProgress({ loadedBytes: transferProgress });\n          }\n        });\n      }\n      await batch.do();\n      return buffer;\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * ONLY AVAILABLE IN NODE.JS RUNTIME.\n   *\n   * Downloads an Azure Blob to a local file.\n   * Fails if the the given file path already exits.\n   * Offset and count are optional, pass 0 and undefined respectively to download the entire blob.\n   *\n   * @param filePath -\n   * @param offset - From which position of the block blob to download.\n   * @param count - How much data to be downloaded. Will download to the end when passing undefined.\n   * @param options - Options to Blob download options.\n   * @returns The response data for blob download operation,\n   *                                                 but with readableStreamBody set to undefined since its\n   *                                                 content is already read and written into a local file\n   *                                                 at the specified path.\n   */\n  public async downloadToFile(\n    filePath: string,\n    offset: number = 0,\n    count?: number,\n    options: BlobDownloadOptions = {}\n  ): Promise<BlobDownloadResponseParsed> {\n    const { span, updatedOptions } = createSpan(\"BlobClient-downloadToFile\", options);\n    try {\n      const response = await this.download(offset, count, {\n        ...options,\n        tracingOptions: {\n          ...options.tracingOptions,\n          ...convertTracingToRequestOptionsBase(updatedOptions),\n        },\n      });\n      if (response.readableStreamBody) {\n        await readStreamToLocalFile(response.readableStreamBody, filePath);\n      }\n\n      // The stream is no longer accessible so setting it to undefined.\n      (response as any).blobDownloadStream = undefined;\n      return response;\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  private getBlobAndContainerNamesFromUrl(): { blobName: string; containerName: string } {\n    let containerName;\n    let blobName;\n    try {\n      //  URL may look like the following\n      // \"https://myaccount.blob.core.windows.net/mycontainer/blob?sasString\";\n      // \"https://myaccount.blob.core.windows.net/mycontainer/blob\";\n      // \"https://myaccount.blob.core.windows.net/mycontainer/blob/a.txt?sasString\";\n      // \"https://myaccount.blob.core.windows.net/mycontainer/blob/a.txt\";\n      // IPv4/IPv6 address hosts, Endpoints - `http://127.0.0.1:10000/devstoreaccount1/containername/blob`\n      // http://localhost:10001/devstoreaccount1/containername/blob\n\n      const parsedUrl = URLBuilder.parse(this.url);\n\n      if (parsedUrl.getHost()!.split(\".\")[1] === \"blob\") {\n        // \"https://myaccount.blob.core.windows.net/containername/blob\".\n        // .getPath() -> /containername/blob\n        const pathComponents = parsedUrl.getPath()!.match(\"/([^/]*)(/(.*))?\");\n        containerName = pathComponents![1];\n        blobName = pathComponents![3];\n      } else if (isIpEndpointStyle(parsedUrl)) {\n        // IPv4/IPv6 address hosts... Example - http://192.0.0.10:10001/devstoreaccount1/containername/blob\n        // Single word domain without a [dot] in the endpoint... Example - http://localhost:10001/devstoreaccount1/containername/blob\n        // .getPath() -> /devstoreaccount1/containername/blob\n        const pathComponents = parsedUrl.getPath()!.match(\"/([^/]*)/([^/]*)(/(.*))?\");\n        containerName = pathComponents![2];\n        blobName = pathComponents![4];\n      } else {\n        // \"https://customdomain.com/containername/blob\".\n        // .getPath() -> /containername/blob\n        const pathComponents = parsedUrl.getPath()!.match(\"/([^/]*)(/(.*))?\");\n        containerName = pathComponents![1];\n        blobName = pathComponents![3];\n      }\n\n      // decode the encoded blobName, containerName - to get all the special characters that might be present in them\n      containerName = decodeURIComponent(containerName);\n      blobName = decodeURIComponent(blobName);\n\n      // Azure Storage Server will replace \"\\\" with \"/\" in the blob names\n      //   doing the same in the SDK side so that the user doesn't have to replace \"\\\" instances in the blobName\n      blobName = blobName.replace(/\\\\/g, \"/\");\n\n      if (!containerName) {\n        throw new Error(\"Provided containerName is invalid.\");\n      }\n\n      return { blobName, containerName };\n    } catch (error: any) {\n      throw new Error(\"Unable to extract blobName and containerName with provided information.\");\n    }\n  }\n\n  /**\n   * Asynchronously copies a blob to a destination within the storage account.\n   * In version 2012-02-12 and later, the source for a Copy Blob operation can be\n   * a committed blob in any Azure storage account.\n   * Beginning with version 2015-02-21, the source for a Copy Blob operation can be\n   * an Azure file in any Azure storage account.\n   * Only storage accounts created on or after June 7th, 2012 allow the Copy Blob\n   * operation to copy from another storage account.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/copy-blob\n   *\n   * @param copySource - url to the source Azure Blob/File.\n   * @param options - Optional options to the Blob Start Copy From URL operation.\n   */\n  private async startCopyFromURL(\n    copySource: string,\n    options: BlobStartCopyFromURLOptions = {}\n  ): Promise<BlobStartCopyFromURLResponse> {\n    const { span, updatedOptions } = createSpan(\"BlobClient-startCopyFromURL\", options);\n    options.conditions = options.conditions || {};\n    options.sourceConditions = options.sourceConditions || {};\n\n    try {\n      return await this.blobContext.startCopyFromURL(copySource, {\n        abortSignal: options.abortSignal,\n        leaseAccessConditions: options.conditions,\n        metadata: options.metadata,\n        modifiedAccessConditions: {\n          ...options.conditions,\n          ifTags: options.conditions?.tagConditions,\n        },\n        sourceModifiedAccessConditions: {\n          sourceIfMatch: options.sourceConditions.ifMatch,\n          sourceIfModifiedSince: options.sourceConditions.ifModifiedSince,\n          sourceIfNoneMatch: options.sourceConditions.ifNoneMatch,\n          sourceIfUnmodifiedSince: options.sourceConditions.ifUnmodifiedSince,\n          sourceIfTags: options.sourceConditions.tagConditions,\n        },\n        immutabilityPolicyExpiry: options.immutabilityPolicy?.expiriesOn,\n        immutabilityPolicyMode: options.immutabilityPolicy?.policyMode,\n        legalHold: options.legalHold,\n        rehydratePriority: options.rehydratePriority,\n        tier: toAccessTier(options.tier),\n        blobTagsString: toBlobTagsString(options.tags),\n        sealBlob: options.sealBlob,\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Only available for BlobClient constructed with a shared key credential.\n   *\n   * Generates a Blob Service Shared Access Signature (SAS) URI based on the client properties\n   * and parameters passed in. The SAS is signed by the shared key credential of the client.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas\n   *\n   * @param options - Optional parameters.\n   * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.\n   */\n  public generateSasUrl(options: BlobGenerateSasUrlOptions): Promise<string> {\n    return new Promise((resolve) => {\n      if (!(this.credential instanceof StorageSharedKeyCredential)) {\n        throw new RangeError(\n          \"Can only generate the SAS when the client is initialized with a shared key credential\"\n        );\n      }\n\n      const sas = generateBlobSASQueryParameters(\n        {\n          containerName: this._containerName,\n          blobName: this._name,\n          snapshotTime: this._snapshot,\n          versionId: this._versionId,\n          ...options,\n        },\n        this.credential\n      ).toString();\n\n      resolve(appendToURLQuery(this.url, sas));\n    });\n  }\n\n  /**\n   * Delete the immutablility policy on the blob.\n   *\n   * @param options - Optional options to delete immutability policy on the blob.\n   */\n  public async deleteImmutabilityPolicy(\n    options?: BlobDeleteImmutabilityPolicyOptions\n  ): Promise<BlobDeleteImmutabilityPolicyResponse> {\n    const { span, updatedOptions } = createSpan(\"BlobClient-deleteImmutabilityPolicy\", options);\n    try {\n      return await this.blobContext.deleteImmutabilityPolicy({\n        abortSignal: options?.abortSignal,\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Set immutablility policy on the blob.\n   *\n   * @param options - Optional options to set immutability policy on the blob.\n   */\n  public async setImmutabilityPolicy(\n    immutabilityPolicy: BlobImmutabilityPolicy,\n    options?: BlobSetImmutabilityPolicyOptions\n  ): Promise<BlobSetImmutabilityPolicyResponse> {\n    const { span, updatedOptions } = createSpan(\"BlobClient-setImmutabilityPolicy\", options);\n    try {\n      return await this.blobContext.setImmutabilityPolicy({\n        abortSignal: options?.abortSignal,\n        immutabilityPolicyExpiry: immutabilityPolicy.expiriesOn,\n        immutabilityPolicyMode: immutabilityPolicy.policyMode,\n        modifiedAccessConditions: options?.modifiedAccessCondition,\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Set legal hold on the blob.\n   *\n   * @param options - Optional options to set legal hold on the blob.\n   */\n  public async setLegalHold(\n    legalHoldEnabled: boolean,\n    options?: BlobSetLegalHoldOptions\n  ): Promise<BlobSetLegalHoldResponse> {\n    const { span, updatedOptions } = createSpan(\"BlobClient-setLegalHold\", options);\n    try {\n      return await this.blobContext.setLegalHold(legalHoldEnabled, {\n        abortSignal: options?.abortSignal,\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n}\n\n/**\n * Options to configure {@link AppendBlobClient.create} operation.\n */\nexport interface AppendBlobCreateOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n\n  /**\n   * Conditions to meet when creating append blobs.\n   */\n  conditions?: BlobRequestConditions;\n  /**\n   * HTTP headers to set when creating append blobs. A common header\n   * to set is `blobContentType`, enabling the browser to provide functionality\n   * based on file type.\n   *\n   */\n  blobHTTPHeaders?: BlobHTTPHeaders;\n  /**\n   * A collection of key-value string pair to associate with the blob when creating append blobs.\n   */\n  metadata?: Metadata;\n  /**\n   * Customer Provided Key Info.\n   */\n  customerProvidedKey?: CpkInfo;\n  /**\n   * Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to\n   * encrypt the data provided in the request. If not specified, encryption is performed with the\n   * default account encryption scope.  For more information, see Encryption at Rest for Azure\n   * Storage Services.\n   */\n  encryptionScope?: string;\n  /**\n   * Optional. Specifies immutability policy for a blob.\n   * Note that is parameter is only applicable to a blob within a container that\n   * has version level worm enabled.\n   */\n  immutabilityPolicy?: BlobImmutabilityPolicy;\n  /**\n   * Optional. Indicates if a legal hold should be placed on the blob.\n   * Note that is parameter is only applicable to a blob within a container that\n   * has version level worm enabled.\n   */\n  legalHold?: boolean;\n  /**\n   * Blob tags.\n   */\n  tags?: Tags;\n}\n\n/**\n * Options to configure {@link AppendBlobClient.createIfNotExists} operation.\n */\nexport interface AppendBlobCreateIfNotExistsOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * HTTP headers to set when creating append blobs. A common header to set is\n   * `blobContentType`, enabling the browser to provide functionality\n   * based on file type.\n   *\n   */\n  blobHTTPHeaders?: BlobHTTPHeaders;\n  /**\n   * A collection of key-value string pair to associate with the blob when creating append blobs.\n   */\n  metadata?: Metadata;\n  /**\n   * Customer Provided Key Info.\n   */\n  customerProvidedKey?: CpkInfo;\n  /**\n   * Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to\n   * encrypt the data provided in the request. If not specified, encryption is performed with the\n   * default account encryption scope.  For more information, see Encryption at Rest for Azure\n   * Storage Services.\n   */\n  encryptionScope?: string;\n  /**\n   * Optional. Specifies immutability policy for a blob.\n   * Note that is parameter is only applicable to a blob within a container that\n   * has version level worm enabled.\n   */\n  immutabilityPolicy?: BlobImmutabilityPolicy;\n  /**\n   * Optional. Indicates if a legal hold should be placed on the blob.\n   * Note that is parameter is only applicable to a blob within a container that\n   * has version level worm enabled.\n   */\n  legalHold?: boolean;\n}\n\n/**\n * Options to configure {@link AppendBlobClient.seal} operation.\n */\nexport interface AppendBlobSealOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Conditions to meet.\n   */\n  conditions?: AppendBlobRequestConditions;\n}\n\n/**\n * Options to configure the {@link AppendBlobClient.appendBlock} operation.\n */\nexport interface AppendBlobAppendBlockOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Conditions to meet when appending append blob blocks.\n   */\n  conditions?: AppendBlobRequestConditions;\n  /**\n   * Callback to receive events on the progress of append block operation.\n   */\n  onProgress?: (progress: TransferProgressEvent) => void;\n  /**\n   * An MD5 hash of the block content. This hash is used to verify the integrity of the block during transport.\n   * When this is specified, the storage service compares the hash of the content that has arrived with this value.\n   *\n   * transactionalContentMD5 and transactionalContentCrc64 cannot be set at same time.\n   */\n  transactionalContentMD5?: Uint8Array;\n  /**\n   * A CRC64 hash of the append block content. This hash is used to verify the integrity of the append block during transport.\n   * When this is specified, the storage service compares the hash of the content that has arrived with this value.\n   *\n   * transactionalContentMD5 and transactionalContentCrc64 cannot be set at same time.\n   */\n  transactionalContentCrc64?: Uint8Array;\n  /**\n   * Customer Provided Key Info.\n   */\n  customerProvidedKey?: CpkInfo;\n  /**\n   * Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to\n   * encrypt the data provided in the request. If not specified, encryption is performed with the\n   * default account encryption scope.  For more information, see Encryption at Rest for Azure\n   * Storage Services.\n   */\n  encryptionScope?: string;\n}\n\n/**\n * Options to configure the {@link AppendBlobClient.appendBlockFromURL} operation.\n */\nexport interface AppendBlobAppendBlockFromURLOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Conditions to meet when appending append blob blocks.\n   */\n  conditions?: AppendBlobRequestConditions;\n  /**\n   * Conditions to meet for the source Azure Blob/File when copying from a URL to the blob.\n   */\n  sourceConditions?: MatchConditions & ModificationConditions;\n  /**\n   * An MD5 hash of the append block content from the URI.\n   * This hash is used to verify the integrity of the append block during transport of the data from the URI.\n   * When this is specified, the storage service compares the hash of the content that has arrived from the copy-source with this value.\n   *\n   * sourceContentMD5 and sourceContentCrc64 cannot be set at same time.\n   */\n  sourceContentMD5?: Uint8Array;\n  /**\n   * A CRC64 hash of the append block content from the URI.\n   * This hash is used to verify the integrity of the append block during transport of the data from the URI.\n   * When this is specified, the storage service compares the hash of the content that has arrived from the copy-source with this value.\n   *\n   * sourceContentMD5 and sourceContentCrc64 cannot be set at same time.\n   */\n  sourceContentCrc64?: Uint8Array;\n  /**\n   * Customer Provided Key Info.\n   */\n  customerProvidedKey?: CpkInfo;\n  /**\n   * Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to\n   * encrypt the data provided in the request. If not specified, encryption is performed with the\n   * default account encryption scope.  For more information, see Encryption at Rest for Azure\n   * Storage Services.\n   */\n  encryptionScope?: string;\n  /**\n   * Only Bearer type is supported. Credentials should be a valid OAuth access token to copy source.\n   */\n  sourceAuthorization?: HttpAuthorization;\n}\n\n/**\n * Contains response data for the {@link appendBlobClient.createIfNotExists} operation.\n */\nexport interface AppendBlobCreateIfNotExistsResponse extends AppendBlobCreateResponse {\n  /**\n   * Indicate whether the blob is successfully created. Is false when the blob is not changed as it already exists.\n   */\n  succeeded: boolean;\n}\n\n/**\n * AppendBlobClient defines a set of operations applicable to append blobs.\n */\nexport class AppendBlobClient extends BlobClient {\n  /**\n   * appendBlobsContext provided by protocol layer.\n   */\n  private appendBlobContext: AppendBlob;\n\n  /**\n   *\n   * Creates an instance of AppendBlobClient.\n   *\n   * @param connectionString - Account connection string or a SAS connection string of an Azure storage account.\n   *                                  [ Note - Account connection string can only be used in NODE.JS runtime. ]\n   *                                  Account connection string example -\n   *                                  `DefaultEndpointsProtocol=https;AccountName=myaccount;AccountKey=accountKey;EndpointSuffix=core.windows.net`\n   *                                  SAS connection string example -\n   *                                  `BlobEndpoint=https://myaccount.blob.core.windows.net/;QueueEndpoint=https://myaccount.queue.core.windows.net/;FileEndpoint=https://myaccount.file.core.windows.net/;TableEndpoint=https://myaccount.table.core.windows.net/;SharedAccessSignature=sasString`\n   * @param containerName - Container name.\n   * @param blobName - Blob name.\n   * @param options - Optional. Options to configure the HTTP pipeline.\n   */\n  constructor(\n    connectionString: string,\n    containerName: string,\n    blobName: string,\n    // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n    options?: StoragePipelineOptions\n  );\n  /**\n   * Creates an instance of AppendBlobClient.\n   * This method accepts an encoded URL or non-encoded URL pointing to an append blob.\n   * Encoded URL string will NOT be escaped twice, only special characters in URL path will be escaped.\n   * If a blob name includes ? or %, blob name must be encoded in the URL.\n   *\n   * @param url - A URL string pointing to Azure Storage append blob, such as\n   *                     \"https://myaccount.blob.core.windows.net/mycontainer/appendblob\". You can\n   *                     append a SAS if using AnonymousCredential, such as\n   *                     \"https://myaccount.blob.core.windows.net/mycontainer/appendblob?sasString\".\n   *                     This method accepts an encoded URL or non-encoded URL pointing to a blob.\n   *                     Encoded URL string will NOT be escaped twice, only special characters in URL path will be escaped.\n   *                     However, if a blob name includes ? or %, blob name must be encoded in the URL.\n   *                     Such as a blob named \"my?blob%\", the URL should be \"https://myaccount.blob.core.windows.net/mycontainer/my%3Fblob%25\".\n   * @param credential -  Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.\n   * @param options - Optional. Options to configure the HTTP pipeline.\n   */\n  constructor(\n    url: string,\n    credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential,\n    // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n    options?: StoragePipelineOptions\n  );\n  /**\n   * Creates an instance of AppendBlobClient.\n   * This method accepts an encoded URL or non-encoded URL pointing to an append blob.\n   * Encoded URL string will NOT be escaped twice, only special characters in URL path will be escaped.\n   * If a blob name includes ? or %, blob name must be encoded in the URL.\n   *\n   * @param url - A URL string pointing to Azure Storage append blob, such as\n   *                     \"https://myaccount.blob.core.windows.net/mycontainer/appendblob\". You can\n   *                     append a SAS if using AnonymousCredential, such as\n   *                     \"https://myaccount.blob.core.windows.net/mycontainer/appendblob?sasString\".\n   *                     This method accepts an encoded URL or non-encoded URL pointing to a blob.\n   *                     Encoded URL string will NOT be escaped twice, only special characters in URL path will be escaped.\n   *                     However, if a blob name includes ? or %, blob name must be encoded in the URL.\n   *                     Such as a blob named \"my?blob%\", the URL should be \"https://myaccount.blob.core.windows.net/mycontainer/my%3Fblob%25\".\n   * @param pipeline - Call newPipeline() to create a default\n   *                            pipeline, or provide a customized pipeline.\n   */\n  constructor(url: string, pipeline: PipelineLike);\n  constructor(\n    urlOrConnectionString: string,\n    credentialOrPipelineOrContainerName:\n      | string\n      | StorageSharedKeyCredential\n      | AnonymousCredential\n      | TokenCredential\n      | PipelineLike,\n    blobNameOrOptions?: string | StoragePipelineOptions,\n    // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n    options?: StoragePipelineOptions\n  ) {\n    // In TypeScript we cannot simply pass all parameters to super() like below so have to duplicate the code instead.\n    //   super(s, credentialOrPipelineOrContainerNameOrOptions, blobNameOrOptions, options);\n    let pipeline: PipelineLike;\n    let url: string;\n    options = options || {};\n    if (isPipelineLike(credentialOrPipelineOrContainerName)) {\n      // (url: string, pipeline: Pipeline)\n      url = urlOrConnectionString;\n      pipeline = credentialOrPipelineOrContainerName;\n    } else if (\n      (isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential) ||\n      credentialOrPipelineOrContainerName instanceof AnonymousCredential ||\n      isTokenCredential(credentialOrPipelineOrContainerName)\n    ) {\n      // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)      url = urlOrConnectionString;\n      url = urlOrConnectionString;\n      options = blobNameOrOptions as StoragePipelineOptions;\n      pipeline = newPipeline(credentialOrPipelineOrContainerName, options);\n    } else if (\n      !credentialOrPipelineOrContainerName &&\n      typeof credentialOrPipelineOrContainerName !== \"string\"\n    ) {\n      // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n      url = urlOrConnectionString;\n      // The second parameter is undefined. Use anonymous credential.\n      pipeline = newPipeline(new AnonymousCredential(), options);\n    } else if (\n      credentialOrPipelineOrContainerName &&\n      typeof credentialOrPipelineOrContainerName === \"string\" &&\n      blobNameOrOptions &&\n      typeof blobNameOrOptions === \"string\"\n    ) {\n      // (connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions)\n      const containerName = credentialOrPipelineOrContainerName;\n      const blobName = blobNameOrOptions;\n\n      const extractedCreds = extractConnectionStringParts(urlOrConnectionString);\n      if (extractedCreds.kind === \"AccountConnString\") {\n        if (isNode) {\n          const sharedKeyCredential = new StorageSharedKeyCredential(\n            extractedCreds.accountName!,\n            extractedCreds.accountKey\n          );\n          url = appendToURLPath(\n            appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)),\n            encodeURIComponent(blobName)\n          );\n\n          if (!options.proxyOptions) {\n            options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);\n          }\n\n          pipeline = newPipeline(sharedKeyCredential, options);\n        } else {\n          throw new Error(\"Account connection string is only supported in Node.js environment\");\n        }\n      } else if (extractedCreds.kind === \"SASConnString\") {\n        url =\n          appendToURLPath(\n            appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)),\n            encodeURIComponent(blobName)\n          ) +\n          \"?\" +\n          extractedCreds.accountSas;\n        pipeline = newPipeline(new AnonymousCredential(), options);\n      } else {\n        throw new Error(\n          \"Connection string must be either an Account connection string or a SAS connection string\"\n        );\n      }\n    } else {\n      throw new Error(\"Expecting non-empty strings for containerName and blobName parameters\");\n    }\n    super(url, pipeline);\n    this.appendBlobContext = new AppendBlob(this.storageClientContext);\n  }\n\n  /**\n   * Creates a new AppendBlobClient object identical to the source but with the\n   * specified snapshot timestamp.\n   * Provide \"\" will remove the snapshot and return a Client to the base blob.\n   *\n   * @param snapshot - The snapshot timestamp.\n   * @returns A new AppendBlobClient object identical to the source but with the specified snapshot timestamp.\n   */\n  public withSnapshot(snapshot: string): AppendBlobClient {\n    return new AppendBlobClient(\n      setURLParameter(\n        this.url,\n        URLConstants.Parameters.SNAPSHOT,\n        snapshot.length === 0 ? undefined : snapshot\n      ),\n      this.pipeline\n    );\n  }\n\n  /**\n   * Creates a 0-length append blob. Call AppendBlock to append data to an append blob.\n   * @see https://docs.microsoft.com/rest/api/storageservices/put-blob\n   *\n   * @param options - Options to the Append Block Create operation.\n   *\n   *\n   * Example usage:\n   *\n   * ```js\n   * const appendBlobClient = containerClient.getAppendBlobClient(\"<blob name>\");\n   * await appendBlobClient.create();\n   * ```\n   */\n  public async create(options: AppendBlobCreateOptions = {}): Promise<AppendBlobCreateResponse> {\n    const { span, updatedOptions } = createSpan(\"AppendBlobClient-create\", options);\n    options.conditions = options.conditions || {};\n    try {\n      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n\n      return await this.appendBlobContext.create(0, {\n        abortSignal: options.abortSignal,\n        blobHttpHeaders: options.blobHTTPHeaders,\n        leaseAccessConditions: options.conditions,\n        metadata: options.metadata,\n        modifiedAccessConditions: {\n          ...options.conditions,\n          ifTags: options.conditions?.tagConditions,\n        },\n        cpkInfo: options.customerProvidedKey,\n        encryptionScope: options.encryptionScope,\n        immutabilityPolicyExpiry: options.immutabilityPolicy?.expiriesOn,\n        immutabilityPolicyMode: options.immutabilityPolicy?.policyMode,\n        legalHold: options.legalHold,\n        blobTagsString: toBlobTagsString(options.tags),\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates a 0-length append blob. Call AppendBlock to append data to an append blob.\n   * If the blob with the same name already exists, the content of the existing blob will remain unchanged.\n   * @see https://docs.microsoft.com/rest/api/storageservices/put-blob\n   *\n   * @param options -\n   */\n  public async createIfNotExists(\n    options: AppendBlobCreateIfNotExistsOptions = {}\n  ): Promise<AppendBlobCreateIfNotExistsResponse> {\n    const { span, updatedOptions } = createSpan(\"AppendBlobClient-createIfNotExists\", options);\n    const conditions = { ifNoneMatch: ETagAny };\n    try {\n      const res = await this.create({\n        ...updatedOptions,\n        conditions,\n      });\n      return {\n        succeeded: true,\n        ...res,\n        _response: res._response, // _response is made non-enumerable\n      };\n    } catch (e: any) {\n      if (e.details?.errorCode === \"BlobAlreadyExists\") {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: \"Expected exception when creating a blob only if it does not already exist.\",\n        });\n        return {\n          succeeded: false,\n          ...e.response?.parsedHeaders,\n          _response: e.response,\n        };\n      }\n\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Seals the append blob, making it read only.\n   *\n   * @param options -\n   */\n  public async seal(options: AppendBlobSealOptions = {}): Promise<AppendBlobAppendBlockResponse> {\n    const { span, updatedOptions } = createSpan(\"AppendBlobClient-seal\", options);\n    options.conditions = options.conditions || {};\n    try {\n      return await this.appendBlobContext.seal({\n        abortSignal: options.abortSignal,\n        appendPositionAccessConditions: options.conditions,\n        leaseAccessConditions: options.conditions,\n        modifiedAccessConditions: {\n          ...options.conditions,\n          ifTags: options.conditions?.tagConditions,\n        },\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Commits a new block of data to the end of the existing append blob.\n   * @see https://docs.microsoft.com/rest/api/storageservices/append-block\n   *\n   * @param body - Data to be appended.\n   * @param contentLength - Length of the body in bytes.\n   * @param options - Options to the Append Block operation.\n   *\n   *\n   * Example usage:\n   *\n   * ```js\n   * const content = \"Hello World!\";\n   *\n   * // Create a new append blob and append data to the blob.\n   * const newAppendBlobClient = containerClient.getAppendBlobClient(\"<blob name>\");\n   * await newAppendBlobClient.create();\n   * await newAppendBlobClient.appendBlock(content, content.length);\n   *\n   * // Append data to an existing append blob.\n   * const existingAppendBlobClient = containerClient.getAppendBlobClient(\"<blob name>\");\n   * await existingAppendBlobClient.appendBlock(content, content.length);\n   * ```\n   */\n  public async appendBlock(\n    body: HttpRequestBody,\n    contentLength: number,\n    options: AppendBlobAppendBlockOptions = {}\n  ): Promise<AppendBlobAppendBlockResponse> {\n    const { span, updatedOptions } = createSpan(\"AppendBlobClient-appendBlock\", options);\n    options.conditions = options.conditions || {};\n    try {\n      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n\n      return await this.appendBlobContext.appendBlock(contentLength, body, {\n        abortSignal: options.abortSignal,\n        appendPositionAccessConditions: options.conditions,\n        leaseAccessConditions: options.conditions,\n        modifiedAccessConditions: {\n          ...options.conditions,\n          ifTags: options.conditions?.tagConditions,\n        },\n        requestOptions: {\n          onUploadProgress: options.onProgress,\n        },\n        transactionalContentMD5: options.transactionalContentMD5,\n        transactionalContentCrc64: options.transactionalContentCrc64,\n        cpkInfo: options.customerProvidedKey,\n        encryptionScope: options.encryptionScope,\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * The Append Block operation commits a new block of data to the end of an existing append blob\n   * where the contents are read from a source url.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/append-block-from-url\n   *\n   * @param sourceURL -\n   *                 The url to the blob that will be the source of the copy. A source blob in the same storage account can\n   *                 be authenticated via Shared Key. However, if the source is a blob in another account, the source blob\n   *                 must either be public or must be authenticated via a shared access signature. If the source blob is\n   *                 public, no authentication is required to perform the operation.\n   * @param sourceOffset - Offset in source to be appended\n   * @param count - Number of bytes to be appended as a block\n   * @param options -\n   */\n  public async appendBlockFromURL(\n    sourceURL: string,\n    sourceOffset: number,\n    count: number,\n    options: AppendBlobAppendBlockFromURLOptions = {}\n  ): Promise<AppendBlobAppendBlockFromUrlResponse> {\n    const { span, updatedOptions } = createSpan(\"AppendBlobClient-appendBlockFromURL\", options);\n    options.conditions = options.conditions || {};\n    options.sourceConditions = options.sourceConditions || {};\n    try {\n      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n\n      return await this.appendBlobContext.appendBlockFromUrl(sourceURL, 0, {\n        abortSignal: options.abortSignal,\n        sourceRange: rangeToString({ offset: sourceOffset, count }),\n        sourceContentMD5: options.sourceContentMD5,\n        sourceContentCrc64: options.sourceContentCrc64,\n        leaseAccessConditions: options.conditions,\n        appendPositionAccessConditions: options.conditions,\n        modifiedAccessConditions: {\n          ...options.conditions,\n          ifTags: options.conditions?.tagConditions,\n        },\n        sourceModifiedAccessConditions: {\n          sourceIfMatch: options.sourceConditions.ifMatch,\n          sourceIfModifiedSince: options.sourceConditions.ifModifiedSince,\n          sourceIfNoneMatch: options.sourceConditions.ifNoneMatch,\n          sourceIfUnmodifiedSince: options.sourceConditions.ifUnmodifiedSince,\n        },\n        copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization),\n        cpkInfo: options.customerProvidedKey,\n        encryptionScope: options.encryptionScope,\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n}\n\n/**\n * Options to configure {@link BlockBlobClient.upload} operation.\n */\nexport interface BlockBlobUploadOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Conditions to meet when uploading to the block blob.\n   */\n  conditions?: BlobRequestConditions;\n  /**\n   * HTTP headers to set when uploading to a block blob. A common header to set is\n   * `blobContentType`, enabling the browser to provide functionality\n   * based on file type.\n   *\n   */\n  blobHTTPHeaders?: BlobHTTPHeaders;\n  /**\n   * A collection of key-value string pair to associate with the blob when uploading to a block blob.\n   */\n  metadata?: Metadata;\n  /**\n   * Callback to receive events on the progress of upload operation.\n   */\n  onProgress?: (progress: TransferProgressEvent) => void;\n  /**\n   * Customer Provided Key Info.\n   */\n  customerProvidedKey?: CpkInfo;\n  /**\n   * Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to\n   * encrypt the data provided in the request. If not specified, encryption is performed with the\n   * default account encryption scope.  For more information, see Encryption at Rest for Azure\n   * Storage Services.\n   */\n  encryptionScope?: string;\n  /**\n   * Access tier.\n   * More Details - https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blob-storage-tiers\n   */\n  tier?: BlockBlobTier | string;\n  /**\n   * Optional. Specifies immutability policy for a blob.\n   * Note that is parameter is only applicable to a blob within a container that\n   * has version level worm enabled.\n   */\n  immutabilityPolicy?: BlobImmutabilityPolicy;\n  /**\n   * Optional. Indicates if a legal hold should be placed on the blob.\n   * Note that is parameter is only applicable to a blob within a container that\n   * has version level worm enabled.\n   */\n  legalHold?: boolean;\n  /**\n   * Blob tags.\n   */\n  tags?: Tags;\n}\n\n/**\n * Options to configure {@link BlockBlobClient.syncUploadFromURL} operation.\n */\nexport interface BlockBlobSyncUploadFromURLOptions extends CommonOptions {\n  /**\n   * Server timeout in seconds.\n   * For more information, @see https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations\n   */\n  timeoutInSeconds?: number;\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Optional. Specifies a user-defined name-value pair associated with the blob. If no name-value\n   * pairs are specified, the operation will copy the metadata from the source blob or file to the\n   * destination blob. If one or more name-value pairs are specified, the destination blob is\n   * created with the specified metadata, and metadata is not copied from the source blob or file.\n   * Note that beginning with version 2009-09-19, metadata names must adhere to the naming rules\n   * for C# identifiers. See Naming and Referencing Containers, Blobs, and Metadata for more\n   * information.\n   */\n  metadata?: Metadata;\n  /**\n   * Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to\n   * encrypt the data provided in the request. If not specified, encryption is performed with the\n   * default account encryption scope.  For more information, see Encryption at Rest for Azure\n   * Storage Services.\n   */\n  encryptionScope?: string;\n  /**\n   * Access tier.\n   * More Details - https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blob-storage-tiers\n   */\n  tier?: BlockBlobTier | string;\n  /**\n   * Specify the md5 calculated for the range of bytes that must be read from the copy source.\n   */\n  sourceContentMD5?: Uint8Array;\n  /**\n   * Blob tags.\n   */\n  tags?: Tags;\n  /**\n   * Optional, default is true.  Indicates if properties from the source blob should be copied.\n   */\n  copySourceBlobProperties?: boolean;\n  /**\n   * HTTP headers to set when uploading to a block blob.\n   *\n   * A common header to set is `blobContentType`, enabling the browser to provide functionality\n   * based on file type.\n   *\n   */\n  blobHTTPHeaders?: BlobHTTPHeaders;\n  /**\n   * Conditions to meet for the destination Azure Blob.\n   */\n  conditions?: BlobRequestConditions;\n  /**\n   * Customer Provided Key Info.\n   */\n  customerProvidedKey?: CpkInfo;\n  /**\n   * Optional. Conditions to meet for the source Azure Blob.\n   */\n  sourceConditions?: ModifiedAccessConditions;\n  /**\n   * Only Bearer type is supported. Credentials should be a valid OAuth access token to copy source.\n   */\n  sourceAuthorization?: HttpAuthorization;\n  /**\n   * Optional, default 'replace'.  Indicates if source tags should be copied or replaced with the tags specified by {@link tags}.\n   */\n  copySourceTags?: BlobCopySourceTags;\n}\n\n/**\n * Blob query error type.\n */\nexport interface BlobQueryError {\n  /**\n   * Whether error is fatal. Fatal error will stop query.\n   */\n  isFatal: boolean;\n  /**\n   * Error name.\n   */\n  name: string;\n  /**\n   * Position in bytes of the query.\n   */\n  position: number;\n  /**\n   * Error description.\n   */\n  description: string;\n}\n\n/**\n * Options to query blob with JSON format.\n */\nexport interface BlobQueryJsonTextConfiguration {\n  /**\n   * Record separator.\n   */\n  recordSeparator: string;\n  /**\n   * Query for a JSON format blob.\n   */\n  kind: \"json\";\n}\n\n/**\n * Options to query blob with CSV format.\n */\nexport interface BlobQueryCsvTextConfiguration {\n  /**\n   * Record separator.\n   */\n  recordSeparator: string;\n  /**\n   * Query for a CSV format blob.\n   */\n  kind: \"csv\";\n  /**\n   * Column separator. Default is \",\".\n   */\n  columnSeparator?: string;\n  /**\n   * Field quote.\n   */\n  fieldQuote?: string;\n  /**\n   * Escape character.\n   */\n  escapeCharacter?: string;\n  /**\n   * Has headers. Default is false.\n   */\n  hasHeaders?: boolean;\n}\n\n/**\n * Options to query blob with Apache Arrow format. Only valid for {@link BlockBlobQueryOptions.outputTextConfiguration}.\n */\nexport interface BlobQueryArrowConfiguration {\n  /**\n   * Kind.\n   */\n  kind: \"arrow\";\n\n  /**\n   * List of {@link BlobQueryArrowField} describing the schema of the data.\n   */\n  schema: BlobQueryArrowField[];\n}\n\n/**\n * Options to query blob with Parquet format. Only valid for {@link BlockBlobQueryOptions.inputTextConfiguration}.\n */\nexport interface BlobQueryParquetConfiguration {\n  /**\n   * Kind.\n   */\n  kind: \"parquet\";\n}\n\n/**\n * Options to configure {@link BlockBlobClient.query} operation.\n */\nexport interface BlockBlobQueryOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Configurations for the query input.\n   */\n  inputTextConfiguration?:\n    | BlobQueryJsonTextConfiguration\n    | BlobQueryCsvTextConfiguration\n    | BlobQueryParquetConfiguration;\n  /**\n   * Configurations for the query output.\n   */\n  outputTextConfiguration?:\n    | BlobQueryJsonTextConfiguration\n    | BlobQueryCsvTextConfiguration\n    | BlobQueryArrowConfiguration;\n  /**\n   * Callback to receive events on the progress of query operation.\n   */\n  onProgress?: (progress: TransferProgressEvent) => void;\n  /**\n   * Callback to receive error events during the query operaiton.\n   */\n  onError?: (error: BlobQueryError) => void;\n  /**\n   * Conditions to meet when uploading to the block blob.\n   */\n  conditions?: BlobRequestConditions;\n  /**\n   * Customer Provided Key Info.\n   */\n  customerProvidedKey?: CpkInfo;\n}\n\n/**\n * Options to configure {@link BlockBlobClient.stageBlock} operation.\n */\nexport interface BlockBlobStageBlockOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * If specified, contains the lease id that must be matched and lease with this id\n   * must be active in order for the operation to succeed.\n   */\n  conditions?: LeaseAccessConditions;\n  /**\n   * Callback to receive events on the progress of stage block operation.\n   */\n  onProgress?: (progress: TransferProgressEvent) => void;\n  /**\n   * An MD5 hash of the block content. This hash is used to verify the integrity of the block during transport.\n   * When this is specified, the storage service compares the hash of the content that has arrived with this value.\n   *\n   * transactionalContentMD5 and transactionalContentCrc64 cannot be set at same time.\n   */\n  transactionalContentMD5?: Uint8Array;\n\n  /**\n   * A CRC64 hash of the block content. This hash is used to verify the integrity of the block during transport.\n   * When this is specified, the storage service compares the hash of the content that has arrived with this value.\n   *\n   * transactionalContentMD5 and transactionalContentCrc64 cannot be set at same time.\n   */\n  transactionalContentCrc64?: Uint8Array;\n  /**\n   * Customer Provided Key Info.\n   */\n  customerProvidedKey?: CpkInfo;\n  /**\n   * Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to\n   * encrypt the data provided in the request. If not specified, encryption is performed with the\n   * default account encryption scope.  For more information, see Encryption at Rest for Azure\n   * Storage Services.\n   */\n  encryptionScope?: string;\n}\n\n/**\n * Options to configure {@link BlockBlobClient.stageBlockFromURL} operation.\n */\nexport interface BlockBlobStageBlockFromURLOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Specifies the bytes of the source Blob/File to upload.\n   * If not specified, the entire content is uploaded as a single block.\n   */\n  range?: Range;\n  /**\n   * If specified, contains the lease id that must be matched and lease with this id\n   * must be active in order for the operation to succeed.\n   */\n  conditions?: LeaseAccessConditions;\n  /**\n   * An MD5 hash of the content from the URI.\n   * This hash is used to verify the integrity of the content during transport of the data from the URI.\n   * When this is specified, the storage service compares the hash of the content that has arrived from the copy-source with this value.\n   *\n   * sourceContentMD5 and sourceContentCrc64 cannot be set at same time.\n   */\n  sourceContentMD5?: Uint8Array;\n  /**\n   * A CRC64 hash of the content from the URI.\n   * This hash is used to verify the integrity of the content during transport of the data from the URI.\n   * When this is specified, the storage service compares the hash of the content that has arrived from the copy-source with this value.\n   *\n   * sourceContentMD5 and sourceContentCrc64 cannot be set at same time.\n   */\n  sourceContentCrc64?: Uint8Array;\n  /**\n   * Customer Provided Key Info.\n   */\n  customerProvidedKey?: CpkInfo;\n  /**\n   * Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to\n   * encrypt the data provided in the request. If not specified, encryption is performed with the\n   * default account encryption scope.  For more information, see Encryption at Rest for Azure\n   * Storage Services.\n   */\n  encryptionScope?: string;\n  /**\n   * Only Bearer type is supported. Credentials should be a valid OAuth access token to copy source.\n   */\n  sourceAuthorization?: HttpAuthorization;\n}\n\n/**\n * Options to configure {@link BlockBlobClient.commitBlockList} operation.\n */\nexport interface BlockBlobCommitBlockListOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Conditions to meet when committing the block list.\n   */\n  conditions?: BlobRequestConditions;\n  /**\n   * HTTP headers to set when committing block list.\n   */\n  blobHTTPHeaders?: BlobHTTPHeaders;\n  /**\n   * A collection of key-value string pair to associate with the blob when committing block list.\n   */\n  metadata?: Metadata;\n  /**\n   * Customer Provided Key Info.\n   */\n  customerProvidedKey?: CpkInfo;\n  /**\n   * Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to\n   * encrypt the data provided in the request. If not specified, encryption is performed with the\n   * default account encryption scope.  For more information, see Encryption at Rest for Azure\n   * Storage Services.\n   */\n  encryptionScope?: string;\n  /**\n   * Optional. Specifies immutability policy for a blob.\n   * Note that is parameter is only applicable to a blob within a container that\n   * has version level worm enabled.\n   */\n  immutabilityPolicy?: BlobImmutabilityPolicy;\n  /**\n   * Optional. Indicates if a legal hold should be placed on the blob.\n   * Note that is parameter is only applicable to a blob within a container that\n   * has version level worm enabled.\n   */\n  legalHold?: boolean;\n  /**\n   * Access tier.\n   * More Details - https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blob-storage-tiers\n   */\n  tier?: BlockBlobTier | string;\n\n  /**\n   * Blob tags.\n   */\n  tags?: Tags;\n}\n\n/**\n * Options to configure {@link BlockBlobClient.getBlockList} operation.\n */\nexport interface BlockBlobGetBlockListOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * If specified, contains the lease id that must be matched and lease with this id\n   * must be active in order for the operation to succeed.\n   */\n  conditions?: LeaseAccessConditions & TagConditions;\n}\n\n/**\n * Option interface for the {@link BlockBlobClient.uploadStream} operation.\n */\nexport interface BlockBlobUploadStreamOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n\n  /**\n   * Blob HTTP Headers.\n   *\n   * A common header to set is `blobContentType`, enabling the\n   * browser to provide functionality based on file type.\n   *\n   */\n  blobHTTPHeaders?: BlobHTTPHeaders;\n\n  /**\n   * Metadata of block blob.\n   */\n  metadata?: { [propertyName: string]: string };\n\n  /**\n   * Access conditions headers.\n   */\n  conditions?: BlobRequestConditions;\n\n  /**\n   * Progress updater.\n   */\n  onProgress?: (progress: TransferProgressEvent) => void;\n\n  /**\n   * Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to\n   * encrypt the data provided in the request. If not specified, encryption is performed with the\n   * default account encryption scope.  For more information, see Encryption at Rest for Azure\n   * Storage Services.\n   */\n  encryptionScope?: string;\n\n  /**\n   * Blob tags.\n   */\n  tags?: Tags;\n\n  /**\n   * Access tier.\n   * More Details - https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blob-storage-tiers\n   */\n  tier?: BlockBlobTier | string;\n}\n/**\n * Option interface for {@link BlockBlobClient.uploadFile} and {@link BlockBlobClient.uploadSeekableStream}.\n */\nexport interface BlockBlobParallelUploadOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n\n  /**\n   * Destination block blob size in bytes.\n   */\n  blockSize?: number;\n\n  /**\n   * Blob size threshold in bytes to start concurrency uploading.\n   * Default value is 256MB, blob size less than this option will\n   * be uploaded via one I/O operation without concurrency.\n   * You can customize a value less equal than the default value.\n   */\n  maxSingleShotSize?: number;\n\n  /**\n   * Progress updater.\n   */\n  onProgress?: (progress: TransferProgressEvent) => void;\n\n  /**\n   * Blob HTTP Headers. A common header to set is\n   * `blobContentType`, enabling the browser to provide\n   * functionality based on file type.\n   *\n   */\n  blobHTTPHeaders?: BlobHTTPHeaders;\n\n  /**\n   * Metadata of block blob.\n   */\n  metadata?: { [propertyName: string]: string };\n\n  /**\n   * Access conditions headers.\n   */\n  conditions?: BlobRequestConditions;\n\n  /**\n   * Concurrency of parallel uploading. Must be greater than or equal to 0.\n   */\n  concurrency?: number;\n\n  /**\n   * Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to\n   * encrypt the data provided in the request. If not specified, encryption is performed with the\n   * default account encryption scope.  For more information, see Encryption at Rest for Azure\n   * Storage Services.\n   */\n  encryptionScope?: string;\n\n  /**\n   * Blob tags.\n   */\n  tags?: Tags;\n\n  /**\n   * Access tier.\n   * More Details - https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blob-storage-tiers\n   */\n  tier?: BlockBlobTier | string;\n}\n\n/**\n * Response type for {@link BlockBlobClient.uploadFile}, {@link BlockBlobClient.uploadStream}, and\n * {@link BlockBlobClient.uploadBrowserDate}.\n */\nexport type BlobUploadCommonResponse = BlockBlobUploadHeaders & {\n  /**\n   * The underlying HTTP response.\n   */\n  _response: HttpResponse;\n};\n\n/**\n * BlockBlobClient defines a set of operations applicable to block blobs.\n */\nexport class BlockBlobClient extends BlobClient {\n  /**\n   * blobContext provided by protocol layer.\n   *\n   * Note. Ideally BlobClient should set BlobClient.blobContext to protected. However, API\n   * extractor has issue blocking that. Here we redecelare _blobContext in BlockBlobClient.\n   */\n  private _blobContext: StorageBlob;\n\n  /**\n   * blockBlobContext provided by protocol layer.\n   */\n  private blockBlobContext: BlockBlob;\n\n  /**\n   *\n   * Creates an instance of BlockBlobClient.\n   *\n   * @param connectionString - Account connection string or a SAS connection string of an Azure storage account.\n   *                                  [ Note - Account connection string can only be used in NODE.JS runtime. ]\n   *                                  Account connection string example -\n   *                                  `DefaultEndpointsProtocol=https;AccountName=myaccount;AccountKey=accountKey;EndpointSuffix=core.windows.net`\n   *                                  SAS connection string example -\n   *                                  `BlobEndpoint=https://myaccount.blob.core.windows.net/;QueueEndpoint=https://myaccount.queue.core.windows.net/;FileEndpoint=https://myaccount.file.core.windows.net/;TableEndpoint=https://myaccount.table.core.windows.net/;SharedAccessSignature=sasString`\n   * @param containerName - Container name.\n   * @param blobName - Blob name.\n   * @param options - Optional. Options to configure the HTTP pipeline.\n   */\n  constructor(\n    connectionString: string,\n    containerName: string,\n    blobName: string,\n    // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n    options?: StoragePipelineOptions\n  );\n  /**\n   * Creates an instance of BlockBlobClient.\n   * This method accepts an encoded URL or non-encoded URL pointing to a block blob.\n   * Encoded URL string will NOT be escaped twice, only special characters in URL path will be escaped.\n   * If a blob name includes ? or %, blob name must be encoded in the URL.\n   *\n   * @param url - A URL string pointing to Azure Storage block blob, such as\n   *                     \"https://myaccount.blob.core.windows.net/mycontainer/blockblob\". You can\n   *                     append a SAS if using AnonymousCredential, such as\n   *                     \"https://myaccount.blob.core.windows.net/mycontainer/blockblob?sasString\".\n   *                     This method accepts an encoded URL or non-encoded URL pointing to a blob.\n   *                     Encoded URL string will NOT be escaped twice, only special characters in URL path will be escaped.\n   *                     However, if a blob name includes ? or %, blob name must be encoded in the URL.\n   *                     Such as a blob named \"my?blob%\", the URL should be \"https://myaccount.blob.core.windows.net/mycontainer/my%3Fblob%25\".\n   * @param credential -  Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.\n   * @param options - Optional. Options to configure the HTTP pipeline.\n   */\n  constructor(\n    url: string,\n    credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential,\n    // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n    options?: StoragePipelineOptions\n  );\n  /**\n   * Creates an instance of BlockBlobClient.\n   * This method accepts an encoded URL or non-encoded URL pointing to a block blob.\n   * Encoded URL string will NOT be escaped twice, only special characters in URL path will be escaped.\n   * If a blob name includes ? or %, blob name must be encoded in the URL.\n   *\n   * @param url - A URL string pointing to Azure Storage block blob, such as\n   *                     \"https://myaccount.blob.core.windows.net/mycontainer/blockblob\". You can\n   *                     append a SAS if using AnonymousCredential, such as\n   *                     \"https://myaccount.blob.core.windows.net/mycontainer/blockblob?sasString\".\n   *                     This method accepts an encoded URL or non-encoded URL pointing to a blob.\n   *                     Encoded URL string will NOT be escaped twice, only special characters in URL path will be escaped.\n   *                     However, if a blob name includes ? or %, blob name must be encoded in the URL.\n   *                     Such as a blob named \"my?blob%\", the URL should be \"https://myaccount.blob.core.windows.net/mycontainer/my%3Fblob%25\".\n   * @param pipeline - Call newPipeline() to create a default\n   *                            pipeline, or provide a customized pipeline.\n   */\n  constructor(url: string, pipeline: PipelineLike);\n  constructor(\n    urlOrConnectionString: string,\n    credentialOrPipelineOrContainerName?:\n      | string\n      | StorageSharedKeyCredential\n      | AnonymousCredential\n      | TokenCredential\n      | PipelineLike,\n    blobNameOrOptions?: string | StoragePipelineOptions,\n    // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n    options?: StoragePipelineOptions\n  ) {\n    // In TypeScript we cannot simply pass all parameters to super() like below so have to duplicate the code instead.\n    //   super(s, credentialOrPipelineOrContainerNameOrOptions, blobNameOrOptions, options);\n    let pipeline: PipelineLike;\n    let url: string;\n    options = options || {};\n    if (isPipelineLike(credentialOrPipelineOrContainerName)) {\n      // (url: string, pipeline: Pipeline)\n      url = urlOrConnectionString;\n      pipeline = credentialOrPipelineOrContainerName;\n    } else if (\n      (isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential) ||\n      credentialOrPipelineOrContainerName instanceof AnonymousCredential ||\n      isTokenCredential(credentialOrPipelineOrContainerName)\n    ) {\n      // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n      url = urlOrConnectionString;\n      options = blobNameOrOptions as StoragePipelineOptions;\n      pipeline = newPipeline(credentialOrPipelineOrContainerName, options);\n    } else if (\n      !credentialOrPipelineOrContainerName &&\n      typeof credentialOrPipelineOrContainerName !== \"string\"\n    ) {\n      // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n      // The second parameter is undefined. Use anonymous credential.\n      url = urlOrConnectionString;\n      pipeline = newPipeline(new AnonymousCredential(), options);\n    } else if (\n      credentialOrPipelineOrContainerName &&\n      typeof credentialOrPipelineOrContainerName === \"string\" &&\n      blobNameOrOptions &&\n      typeof blobNameOrOptions === \"string\"\n    ) {\n      // (connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions)\n      const containerName = credentialOrPipelineOrContainerName;\n      const blobName = blobNameOrOptions;\n\n      const extractedCreds = extractConnectionStringParts(urlOrConnectionString);\n      if (extractedCreds.kind === \"AccountConnString\") {\n        if (isNode) {\n          const sharedKeyCredential = new StorageSharedKeyCredential(\n            extractedCreds.accountName!,\n            extractedCreds.accountKey\n          );\n          url = appendToURLPath(\n            appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)),\n            encodeURIComponent(blobName)\n          );\n\n          if (!options.proxyOptions) {\n            options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);\n          }\n\n          pipeline = newPipeline(sharedKeyCredential, options);\n        } else {\n          throw new Error(\"Account connection string is only supported in Node.js environment\");\n        }\n      } else if (extractedCreds.kind === \"SASConnString\") {\n        url =\n          appendToURLPath(\n            appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)),\n            encodeURIComponent(blobName)\n          ) +\n          \"?\" +\n          extractedCreds.accountSas;\n        pipeline = newPipeline(new AnonymousCredential(), options);\n      } else {\n        throw new Error(\n          \"Connection string must be either an Account connection string or a SAS connection string\"\n        );\n      }\n    } else {\n      throw new Error(\"Expecting non-empty strings for containerName and blobName parameters\");\n    }\n    super(url, pipeline);\n    this.blockBlobContext = new BlockBlob(this.storageClientContext);\n    this._blobContext = new StorageBlob(this.storageClientContext);\n  }\n\n  /**\n   * Creates a new BlockBlobClient object identical to the source but with the\n   * specified snapshot timestamp.\n   * Provide \"\" will remove the snapshot and return a URL to the base blob.\n   *\n   * @param snapshot - The snapshot timestamp.\n   * @returns A new BlockBlobClient object identical to the source but with the specified snapshot timestamp.\n   */\n  public withSnapshot(snapshot: string): BlockBlobClient {\n    return new BlockBlobClient(\n      setURLParameter(\n        this.url,\n        URLConstants.Parameters.SNAPSHOT,\n        snapshot.length === 0 ? undefined : snapshot\n      ),\n      this.pipeline\n    );\n  }\n\n  /**\n   * ONLY AVAILABLE IN NODE.JS RUNTIME.\n   *\n   * Quick query for a JSON or CSV formatted blob.\n   *\n   * Example usage (Node.js):\n   *\n   * ```js\n   * // Query and convert a blob to a string\n   * const queryBlockBlobResponse = await blockBlobClient.query(\"select * from BlobStorage\");\n   * const downloaded = (await streamToBuffer(queryBlockBlobResponse.readableStreamBody)).toString();\n   * console.log(\"Query blob content:\", downloaded);\n   *\n   * async function streamToBuffer(readableStream) {\n   *   return new Promise((resolve, reject) => {\n   *     const chunks = [];\n   *     readableStream.on(\"data\", (data) => {\n   *       chunks.push(data instanceof Buffer ? data : Buffer.from(data));\n   *     });\n   *     readableStream.on(\"end\", () => {\n   *       resolve(Buffer.concat(chunks));\n   *     });\n   *     readableStream.on(\"error\", reject);\n   *   });\n   * }\n   * ```\n   *\n   * @param query -\n   * @param options -\n   */\n  public async query(\n    query: string,\n    options: BlockBlobQueryOptions = {}\n  ): Promise<BlobDownloadResponseModel> {\n    ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n\n    const { span, updatedOptions } = createSpan(\"BlockBlobClient-query\", options);\n\n    try {\n      if (!isNode) {\n        throw new Error(\"This operation currently is only supported in Node.js.\");\n      }\n      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n      const response = await this._blobContext.query({\n        abortSignal: options.abortSignal,\n        queryRequest: {\n          queryType: \"SQL\",\n          expression: query,\n          inputSerialization: toQuerySerialization(options.inputTextConfiguration),\n          outputSerialization: toQuerySerialization(options.outputTextConfiguration),\n        },\n        leaseAccessConditions: options.conditions,\n        modifiedAccessConditions: {\n          ...options.conditions,\n          ifTags: options.conditions?.tagConditions,\n        },\n        cpkInfo: options.customerProvidedKey,\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n      return new BlobQueryResponse(response, {\n        abortSignal: options.abortSignal,\n        onProgress: options.onProgress,\n        onError: options.onError,\n      });\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates a new block blob, or updates the content of an existing block blob.\n   * Updating an existing block blob overwrites any existing metadata on the blob.\n   * Partial updates are not supported; the content of the existing blob is\n   * overwritten with the new content. To perform a partial update of a block blob's,\n   * use {@link stageBlock} and {@link commitBlockList}.\n   *\n   * This is a non-parallel uploading method, please use {@link uploadFile},\n   * {@link uploadStream} or {@link uploadBrowserData} for better performance\n   * with concurrency uploading.\n   *\n   * @see https://docs.microsoft.com/rest/api/storageservices/put-blob\n   *\n   * @param body - Blob, string, ArrayBuffer, ArrayBufferView or a function\n   *                               which returns a new Readable stream whose offset is from data source beginning.\n   * @param contentLength - Length of body in bytes. Use Buffer.byteLength() to calculate body length for a\n   *                               string including non non-Base64/Hex-encoded characters.\n   * @param options - Options to the Block Blob Upload operation.\n   * @returns Response data for the Block Blob Upload operation.\n   *\n   * Example usage:\n   *\n   * ```js\n   * const content = \"Hello world!\";\n   * const uploadBlobResponse = await blockBlobClient.upload(content, content.length);\n   * ```\n   */\n  public async upload(\n    body: HttpRequestBody,\n    contentLength: number,\n    options: BlockBlobUploadOptions = {}\n  ): Promise<BlockBlobUploadResponse> {\n    options.conditions = options.conditions || {};\n    const { span, updatedOptions } = createSpan(\"BlockBlobClient-upload\", options);\n    try {\n      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n      return await this.blockBlobContext.upload(contentLength, body, {\n        abortSignal: options.abortSignal,\n        blobHttpHeaders: options.blobHTTPHeaders,\n        leaseAccessConditions: options.conditions,\n        metadata: options.metadata,\n        modifiedAccessConditions: {\n          ...options.conditions,\n          ifTags: options.conditions?.tagConditions,\n        },\n        requestOptions: {\n          onUploadProgress: options.onProgress,\n        },\n        cpkInfo: options.customerProvidedKey,\n        encryptionScope: options.encryptionScope,\n        immutabilityPolicyExpiry: options.immutabilityPolicy?.expiriesOn,\n        immutabilityPolicyMode: options.immutabilityPolicy?.policyMode,\n        legalHold: options.legalHold,\n        tier: toAccessTier(options.tier),\n        blobTagsString: toBlobTagsString(options.tags),\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates a new Block Blob where the contents of the blob are read from a given URL.\n   * This API is supported beginning with the 2020-04-08 version. Partial updates\n   * are not supported with Put Blob from URL; the content of an existing blob is overwritten with\n   * the content of the new blob.  To perform partial updates to a block blob’s contents using a\n   * source URL, use {@link stageBlockFromURL} and {@link commitBlockList}.\n   *\n   * @param sourceURL - Specifies the URL of the blob. The value\n   *                           may be a URL of up to 2 KB in length that specifies a blob.\n   *                           The value should be URL-encoded as it would appear\n   *                           in a request URI. The source blob must either be public\n   *                           or must be authenticated via a shared access signature.\n   *                           If the source blob is public, no authentication is required\n   *                           to perform the operation. Here are some examples of source object URLs:\n   *                           - https://myaccount.blob.core.windows.net/mycontainer/myblob\n   *                           - https://myaccount.blob.core.windows.net/mycontainer/myblob?snapshot=<DateTime>\n   * @param options - Optional parameters.\n   */\n\n  public async syncUploadFromURL(\n    sourceURL: string,\n    options: BlockBlobSyncUploadFromURLOptions = {}\n  ): Promise<BlockBlobPutBlobFromUrlResponse> {\n    options.conditions = options.conditions || {};\n    const { span, updatedOptions } = createSpan(\"BlockBlobClient-syncUploadFromURL\", options);\n    try {\n      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n      return await this.blockBlobContext.putBlobFromUrl(0, sourceURL, {\n        ...options,\n        blobHttpHeaders: options.blobHTTPHeaders,\n        leaseAccessConditions: options.conditions,\n        modifiedAccessConditions: {\n          ...options.conditions,\n          ifTags: options.conditions.tagConditions,\n        },\n        sourceModifiedAccessConditions: {\n          sourceIfMatch: options.sourceConditions?.ifMatch,\n          sourceIfModifiedSince: options.sourceConditions?.ifModifiedSince,\n          sourceIfNoneMatch: options.sourceConditions?.ifNoneMatch,\n          sourceIfUnmodifiedSince: options.sourceConditions?.ifUnmodifiedSince,\n          sourceIfTags: options.sourceConditions?.tagConditions,\n        },\n        cpkInfo: options.customerProvidedKey,\n        copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization),\n        tier: toAccessTier(options.tier),\n        blobTagsString: toBlobTagsString(options.tags),\n        copySourceTags: options.copySourceTags,\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Uploads the specified block to the block blob's \"staging area\" to be later\n   * committed by a call to commitBlockList.\n   * @see https://docs.microsoft.com/rest/api/storageservices/put-block\n   *\n   * @param blockId - A 64-byte value that is base64-encoded\n   * @param body - Data to upload to the staging area.\n   * @param contentLength - Number of bytes to upload.\n   * @param options - Options to the Block Blob Stage Block operation.\n   * @returns Response data for the Block Blob Stage Block operation.\n   */\n  public async stageBlock(\n    blockId: string,\n    body: HttpRequestBody,\n    contentLength: number,\n    options: BlockBlobStageBlockOptions = {}\n  ): Promise<BlockBlobStageBlockResponse> {\n    const { span, updatedOptions } = createSpan(\"BlockBlobClient-stageBlock\", options);\n    try {\n      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n      return await this.blockBlobContext.stageBlock(blockId, contentLength, body, {\n        abortSignal: options.abortSignal,\n        leaseAccessConditions: options.conditions,\n        requestOptions: {\n          onUploadProgress: options.onProgress,\n        },\n        transactionalContentMD5: options.transactionalContentMD5,\n        transactionalContentCrc64: options.transactionalContentCrc64,\n        cpkInfo: options.customerProvidedKey,\n        encryptionScope: options.encryptionScope,\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * The Stage Block From URL operation creates a new block to be committed as part\n   * of a blob where the contents are read from a URL.\n   * This API is available starting in version 2018-03-28.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/put-block-from-url\n   *\n   * @param blockId - A 64-byte value that is base64-encoded\n   * @param sourceURL - Specifies the URL of the blob. The value\n   *                           may be a URL of up to 2 KB in length that specifies a blob.\n   *                           The value should be URL-encoded as it would appear\n   *                           in a request URI. The source blob must either be public\n   *                           or must be authenticated via a shared access signature.\n   *                           If the source blob is public, no authentication is required\n   *                           to perform the operation. Here are some examples of source object URLs:\n   *                           - https://myaccount.blob.core.windows.net/mycontainer/myblob\n   *                           - https://myaccount.blob.core.windows.net/mycontainer/myblob?snapshot=<DateTime>\n   * @param offset - From which position of the blob to download, greater than or equal to 0\n   * @param count - How much data to be downloaded, greater than 0. Will download to the end when undefined\n   * @param options - Options to the Block Blob Stage Block From URL operation.\n   * @returns Response data for the Block Blob Stage Block From URL operation.\n   */\n  public async stageBlockFromURL(\n    blockId: string,\n    sourceURL: string,\n    offset: number = 0,\n    count?: number,\n    options: BlockBlobStageBlockFromURLOptions = {}\n  ): Promise<BlockBlobStageBlockFromURLResponse> {\n    const { span, updatedOptions } = createSpan(\"BlockBlobClient-stageBlockFromURL\", options);\n    try {\n      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n      return await this.blockBlobContext.stageBlockFromURL(blockId, 0, sourceURL, {\n        abortSignal: options.abortSignal,\n        leaseAccessConditions: options.conditions,\n        sourceContentMD5: options.sourceContentMD5,\n        sourceContentCrc64: options.sourceContentCrc64,\n        sourceRange: offset === 0 && !count ? undefined : rangeToString({ offset, count }),\n        cpkInfo: options.customerProvidedKey,\n        encryptionScope: options.encryptionScope,\n        copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization),\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Writes a blob by specifying the list of block IDs that make up the blob.\n   * In order to be written as part of a blob, a block must have been successfully written\n   * to the server in a prior {@link stageBlock} operation. You can call {@link commitBlockList} to\n   * update a blob by uploading only those blocks that have changed, then committing the new and existing\n   * blocks together. Any blocks not specified in the block list and permanently deleted.\n   * @see https://docs.microsoft.com/rest/api/storageservices/put-block-list\n   *\n   * @param blocks -  Array of 64-byte value that is base64-encoded\n   * @param options - Options to the Block Blob Commit Block List operation.\n   * @returns Response data for the Block Blob Commit Block List operation.\n   */\n  public async commitBlockList(\n    blocks: string[],\n    options: BlockBlobCommitBlockListOptions = {}\n  ): Promise<BlockBlobCommitBlockListResponse> {\n    options.conditions = options.conditions || {};\n    const { span, updatedOptions } = createSpan(\"BlockBlobClient-commitBlockList\", options);\n    try {\n      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n      return await this.blockBlobContext.commitBlockList(\n        { latest: blocks },\n        {\n          abortSignal: options.abortSignal,\n          blobHttpHeaders: options.blobHTTPHeaders,\n          leaseAccessConditions: options.conditions,\n          metadata: options.metadata,\n          modifiedAccessConditions: {\n            ...options.conditions,\n            ifTags: options.conditions?.tagConditions,\n          },\n          cpkInfo: options.customerProvidedKey,\n          encryptionScope: options.encryptionScope,\n          immutabilityPolicyExpiry: options.immutabilityPolicy?.expiriesOn,\n          immutabilityPolicyMode: options.immutabilityPolicy?.policyMode,\n          legalHold: options.legalHold,\n          tier: toAccessTier(options.tier),\n          blobTagsString: toBlobTagsString(options.tags),\n          ...convertTracingToRequestOptionsBase(updatedOptions),\n        }\n      );\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Returns the list of blocks that have been uploaded as part of a block blob\n   * using the specified block list filter.\n   * @see https://docs.microsoft.com/rest/api/storageservices/get-block-list\n   *\n   * @param listType - Specifies whether to return the list of committed blocks,\n   *                                        the list of uncommitted blocks, or both lists together.\n   * @param options - Options to the Block Blob Get Block List operation.\n   * @returns Response data for the Block Blob Get Block List operation.\n   */\n  public async getBlockList(\n    listType: BlockListType,\n    options: BlockBlobGetBlockListOptions = {}\n  ): Promise<BlockBlobGetBlockListResponse> {\n    const { span, updatedOptions } = createSpan(\"BlockBlobClient-getBlockList\", options);\n    try {\n      const res = await this.blockBlobContext.getBlockList(listType, {\n        abortSignal: options.abortSignal,\n        leaseAccessConditions: options.conditions,\n        modifiedAccessConditions: {\n          ...options.conditions,\n          ifTags: options.conditions?.tagConditions,\n        },\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n\n      if (!res.committedBlocks) {\n        res.committedBlocks = [];\n      }\n\n      if (!res.uncommittedBlocks) {\n        res.uncommittedBlocks = [];\n      }\n\n      return res;\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  // High level functions\n\n  /**\n   * Uploads a Buffer(Node.js)/Blob(browsers)/ArrayBuffer/ArrayBufferView object to a BlockBlob.\n   *\n   * When data length is no more than the specifiled {@link BlockBlobParallelUploadOptions.maxSingleShotSize} (default is\n   * {@link BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES}), this method will use 1 {@link upload} call to finish the upload.\n   * Otherwise, this method will call {@link stageBlock} to upload blocks, and finally call {@link commitBlockList}\n   * to commit the block list.\n   *\n   * A common {@link BlockBlobParallelUploadOptions.blobHTTPHeaders} option to set is\n   * `blobContentType`, enabling the browser to provide\n   * functionality based on file type.\n   *\n   * @param data - Buffer(Node.js), Blob, ArrayBuffer or ArrayBufferView\n   * @param options -\n   */\n  public async uploadData(\n    data: Buffer | Blob | ArrayBuffer | ArrayBufferView,\n    options: BlockBlobParallelUploadOptions = {}\n  ): Promise<BlobUploadCommonResponse> {\n    const { span, updatedOptions } = createSpan(\"BlockBlobClient-uploadData\", options);\n    try {\n      if (isNode) {\n        let buffer: Buffer;\n        if (data instanceof Buffer) {\n          buffer = data;\n        } else if (data instanceof ArrayBuffer) {\n          buffer = Buffer.from(data);\n        } else {\n          data = data as ArrayBufferView;\n          buffer = Buffer.from(data.buffer, data.byteOffset, data.byteLength);\n        }\n\n        return this.uploadSeekableInternal(\n          (offset: number, size: number): Buffer => buffer.slice(offset, offset + size),\n          buffer.byteLength,\n          updatedOptions\n        );\n      } else {\n        const browserBlob = new Blob([data]);\n        return this.uploadSeekableInternal(\n          (offset: number, size: number): Blob => browserBlob.slice(offset, offset + size),\n          browserBlob.size,\n          updatedOptions\n        );\n      }\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * ONLY AVAILABLE IN BROWSERS.\n   *\n   * Uploads a browser Blob/File/ArrayBuffer/ArrayBufferView object to block blob.\n   *\n   * When buffer length lesser than or equal to 256MB, this method will use 1 upload call to finish the upload.\n   * Otherwise, this method will call {@link stageBlock} to upload blocks, and finally call\n   * {@link commitBlockList} to commit the block list.\n   *\n   * A common {@link BlockBlobParallelUploadOptions.blobHTTPHeaders} option to set is\n   * `blobContentType`, enabling the browser to provide\n   * functionality based on file type.\n   *\n   * @deprecated Use {@link uploadData} instead.\n   *\n   * @param browserData - Blob, File, ArrayBuffer or ArrayBufferView\n   * @param options - Options to upload browser data.\n   * @returns Response data for the Blob Upload operation.\n   */\n  public async uploadBrowserData(\n    browserData: Blob | ArrayBuffer | ArrayBufferView,\n    options: BlockBlobParallelUploadOptions = {}\n  ): Promise<BlobUploadCommonResponse> {\n    const { span, updatedOptions } = createSpan(\"BlockBlobClient-uploadBrowserData\", options);\n    try {\n      const browserBlob = new Blob([browserData]);\n      return await this.uploadSeekableInternal(\n        (offset: number, size: number): Blob => browserBlob.slice(offset, offset + size),\n        browserBlob.size,\n        updatedOptions\n      );\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   *\n   * Uploads data to block blob. Requires a bodyFactory as the data source,\n   * which need to return a {@link HttpRequestBody} object with the offset and size provided.\n   *\n   * When data length is no more than the specified {@link BlockBlobParallelUploadOptions.maxSingleShotSize} (default is\n   * {@link BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES}), this method will use 1 {@link upload} call to finish the upload.\n   * Otherwise, this method will call {@link stageBlock} to upload blocks, and finally call {@link commitBlockList}\n   * to commit the block list.\n   *\n   * @param bodyFactory -\n   * @param size - size of the data to upload.\n   * @param options - Options to Upload to Block Blob operation.\n   * @returns Response data for the Blob Upload operation.\n   */\n  private async uploadSeekableInternal(\n    bodyFactory: (offset: number, size: number) => HttpRequestBody,\n    size: number,\n    options: BlockBlobParallelUploadOptions = {}\n  ): Promise<BlobUploadCommonResponse> {\n    if (!options.blockSize) {\n      options.blockSize = 0;\n    }\n    if (options.blockSize < 0 || options.blockSize > BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES) {\n      throw new RangeError(\n        `blockSize option must be >= 0 and <= ${BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES}`\n      );\n    }\n\n    if (options.maxSingleShotSize !== 0 && !options.maxSingleShotSize) {\n      options.maxSingleShotSize = BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES;\n    }\n    if (\n      options.maxSingleShotSize < 0 ||\n      options.maxSingleShotSize > BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES\n    ) {\n      throw new RangeError(\n        `maxSingleShotSize option must be >= 0 and <= ${BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES}`\n      );\n    }\n\n    if (options.blockSize === 0) {\n      if (size > BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES * BLOCK_BLOB_MAX_BLOCKS) {\n        throw new RangeError(`${size} is too larger to upload to a block blob.`);\n      }\n      if (size > options.maxSingleShotSize) {\n        options.blockSize = Math.ceil(size / BLOCK_BLOB_MAX_BLOCKS);\n        if (options.blockSize < DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES) {\n          options.blockSize = DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES;\n        }\n      }\n    }\n    if (!options.blobHTTPHeaders) {\n      options.blobHTTPHeaders = {};\n    }\n    if (!options.conditions) {\n      options.conditions = {};\n    }\n\n    const { span, updatedOptions } = createSpan(\"BlockBlobClient-uploadSeekableInternal\", options);\n\n    try {\n      if (size <= options.maxSingleShotSize) {\n        return await this.upload(bodyFactory(0, size), size, updatedOptions);\n      }\n\n      const numBlocks: number = Math.floor((size - 1) / options.blockSize) + 1;\n      if (numBlocks > BLOCK_BLOB_MAX_BLOCKS) {\n        throw new RangeError(\n          `The buffer's size is too big or the BlockSize is too small;` +\n            `the number of blocks must be <= ${BLOCK_BLOB_MAX_BLOCKS}`\n        );\n      }\n\n      const blockList: string[] = [];\n      const blockIDPrefix = generateUuid();\n      let transferProgress: number = 0;\n\n      const batch = new Batch(options.concurrency);\n      for (let i = 0; i < numBlocks; i++) {\n        batch.addOperation(async (): Promise<any> => {\n          const blockID = generateBlockID(blockIDPrefix, i);\n          const start = options.blockSize! * i;\n          const end = i === numBlocks - 1 ? size : start + options.blockSize!;\n          const contentLength = end - start;\n          blockList.push(blockID);\n          await this.stageBlock(blockID, bodyFactory(start, contentLength), contentLength, {\n            abortSignal: options.abortSignal,\n            conditions: options.conditions,\n            encryptionScope: options.encryptionScope,\n            tracingOptions: updatedOptions.tracingOptions,\n          });\n          // Update progress after block is successfully uploaded to server, in case of block trying\n          // TODO: Hook with convenience layer progress event in finer level\n          transferProgress += contentLength;\n          if (options.onProgress) {\n            options.onProgress!({\n              loadedBytes: transferProgress,\n            });\n          }\n        });\n      }\n      await batch.do();\n\n      return this.commitBlockList(blockList, updatedOptions);\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * ONLY AVAILABLE IN NODE.JS RUNTIME.\n   *\n   * Uploads a local file in blocks to a block blob.\n   *\n   * When file size lesser than or equal to 256MB, this method will use 1 upload call to finish the upload.\n   * Otherwise, this method will call stageBlock to upload blocks, and finally call commitBlockList\n   * to commit the block list.\n   *\n   * @param filePath - Full path of local file\n   * @param options - Options to Upload to Block Blob operation.\n   * @returns Response data for the Blob Upload operation.\n   */\n  public async uploadFile(\n    filePath: string,\n    options: BlockBlobParallelUploadOptions = {}\n  ): Promise<BlobUploadCommonResponse> {\n    const { span, updatedOptions } = createSpan(\"BlockBlobClient-uploadFile\", options);\n    try {\n      const size = (await fsStat(filePath)).size;\n      return await this.uploadSeekableInternal(\n        (offset, count) => {\n          return () =>\n            fsCreateReadStream(filePath, {\n              autoClose: true,\n              end: count ? offset + count - 1 : Infinity,\n              start: offset,\n            });\n        },\n        size,\n        {\n          ...options,\n          tracingOptions: {\n            ...options!.tracingOptions,\n            ...convertTracingToRequestOptionsBase(updatedOptions),\n          },\n        }\n      );\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * ONLY AVAILABLE IN NODE.JS RUNTIME.\n   *\n   * Uploads a Node.js Readable stream into block blob.\n   *\n   * PERFORMANCE IMPROVEMENT TIPS:\n   * * Input stream highWaterMark is better to set a same value with bufferSize\n   *    parameter, which will avoid Buffer.concat() operations.\n   *\n   * @param stream - Node.js Readable stream\n   * @param bufferSize - Size of every buffer allocated, also the block size in the uploaded block blob. Default value is 8MB\n   * @param maxConcurrency -  Max concurrency indicates the max number of buffers that can be allocated,\n   *                                 positive correlation with max uploading concurrency. Default value is 5\n   * @param options - Options to Upload Stream to Block Blob operation.\n   * @returns Response data for the Blob Upload operation.\n   */\n  public async uploadStream(\n    stream: Readable,\n    bufferSize: number = DEFAULT_BLOCK_BUFFER_SIZE_BYTES,\n    maxConcurrency: number = 5,\n    options: BlockBlobUploadStreamOptions = {}\n  ): Promise<BlobUploadCommonResponse> {\n    if (!options.blobHTTPHeaders) {\n      options.blobHTTPHeaders = {};\n    }\n    if (!options.conditions) {\n      options.conditions = {};\n    }\n\n    const { span, updatedOptions } = createSpan(\"BlockBlobClient-uploadStream\", options);\n\n    try {\n      let blockNum = 0;\n      const blockIDPrefix = generateUuid();\n      let transferProgress: number = 0;\n      const blockList: string[] = [];\n\n      const scheduler = new BufferScheduler(\n        stream,\n        bufferSize,\n        maxConcurrency,\n        async (body, length) => {\n          const blockID = generateBlockID(blockIDPrefix, blockNum);\n          blockList.push(blockID);\n          blockNum++;\n\n          await this.stageBlock(blockID, body, length, {\n            conditions: options.conditions,\n            encryptionScope: options.encryptionScope,\n            tracingOptions: updatedOptions.tracingOptions,\n          });\n\n          // Update progress after block is successfully uploaded to server, in case of block trying\n          transferProgress += length;\n          if (options.onProgress) {\n            options.onProgress({ loadedBytes: transferProgress });\n          }\n        },\n        // concurrency should set a smaller value than maxConcurrency, which is helpful to\n        // reduce the possibility when a outgoing handler waits for stream data, in\n        // this situation, outgoing handlers are blocked.\n        // Outgoing queue shouldn't be empty.\n        Math.ceil((maxConcurrency / 4) * 3)\n      );\n      await scheduler.do();\n\n      return await this.commitBlockList(blockList, {\n        ...options,\n        tracingOptions: {\n          ...options!.tracingOptions,\n          ...convertTracingToRequestOptionsBase(updatedOptions),\n        },\n      });\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n}\n\n/**\n * Options to configure the {@link PageBlobClient.create} operation.\n */\nexport interface PageBlobCreateOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Conditions to meet when creating a page blob.\n   */\n  conditions?: BlobRequestConditions;\n  /**\n   * A user-controlled value that can be used to track requests.\n   * The value must be between 0 and 2^63 - 1. The default value is 0.\n   */\n  blobSequenceNumber?: number;\n  /**\n   * HTTP headers to set when creating a page blob.\n   */\n  blobHTTPHeaders?: BlobHTTPHeaders;\n  /**\n   * A collection of key-value string pair to associate with the blob when creating append blobs.\n   */\n  metadata?: Metadata;\n  /**\n   * Customer Provided Key Info.\n   */\n  customerProvidedKey?: CpkInfo;\n  /**\n   * Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to\n   * encrypt the data provided in the request. If not specified, encryption is performed with the\n   * default account encryption scope.  For more information, see Encryption at Rest for Azure\n   * Storage Services.\n   */\n  encryptionScope?: string;\n  /**\n   * Optional. Specifies immutability policy for a blob.\n   * Note that is parameter is only applicable to a blob within a container that\n   * has version level worm enabled.\n   */\n  immutabilityPolicy?: BlobImmutabilityPolicy;\n  /**\n   * Optional. Indicates if a legal hold should be placed on the blob.\n   * Note that is parameter is only applicable to a blob within a container that\n   * has version level worm enabled.\n   */\n  legalHold?: boolean;\n  /**\n   * Access tier.\n   * More Details - https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blob-storage-tiers\n   */\n  tier?: PremiumPageBlobTier | string;\n  /**\n   * Blob tags.\n   */\n  tags?: Tags;\n}\n\n/**\n * Options to configure the {@link PageBlobClient.createIfNotExists} operation.\n */\nexport interface PageBlobCreateIfNotExistsOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * A user-controlled value that can be used to track requests.\n   * The value must be between 0 and 2^63 - 1. The default value is 0.\n   */\n  blobSequenceNumber?: number;\n  /**\n   * HTTP headers to set when creating a page blob.\n   */\n  blobHTTPHeaders?: BlobHTTPHeaders;\n  /**\n   * A collection of key-value string pair to associate with the blob when creating append blobs.\n   */\n  metadata?: Metadata;\n  /**\n   * Customer Provided Key Info.\n   */\n  customerProvidedKey?: CpkInfo;\n  /**\n   * Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to\n   * encrypt the data provided in the request. If not specified, encryption is performed with the\n   * default account encryption scope.  For more information, see Encryption at Rest for Azure\n   * Storage Services.\n   */\n  encryptionScope?: string;\n  /**\n   * Optional. Specifies immutability policy for a blob.\n   * Note that is parameter is only applicable to a blob within a container that\n   * has version level worm enabled.\n   */\n  immutabilityPolicy?: BlobImmutabilityPolicy;\n  /**\n   * Optional. Indicates if a legal hold should be placed on the blob.\n   * Note that is parameter is only applicable to a blob within a container that\n   * has version level worm enabled.\n   */\n  legalHold?: boolean;\n  /**\n   * Access tier.\n   * More Details - https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blob-storage-tiers\n   */\n  tier?: PremiumPageBlobTier | string;\n}\n\n/**\n * Options to configure the {@link PageBlobClient.uploadPages} operation.\n */\nexport interface PageBlobUploadPagesOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Conditions to meet when uploading pages.\n   */\n  conditions?: PageBlobRequestConditions;\n  /**\n   * Callback to receive events on the progress of upload pages operation.\n   */\n  onProgress?: (progress: TransferProgressEvent) => void;\n  /**\n   * An MD5 hash of the content. This hash is used to verify the integrity of the content during transport.\n   * When this is specified, the storage service compares the hash of the content that has arrived with this value.\n   *\n   * transactionalContentMD5 and transactionalContentCrc64 cannot be set at same time.\n   */\n  transactionalContentMD5?: Uint8Array;\n  /**\n   * A CRC64 hash of the content. This hash is used to verify the integrity of the content during transport.\n   * When this is specified, the storage service compares the hash of the content that has arrived with this value.\n   *\n   * transactionalContentMD5 and transactionalContentCrc64 cannot be set at same time.\n   */\n  transactionalContentCrc64?: Uint8Array;\n  /**\n   * Customer Provided Key Info.\n   */\n  customerProvidedKey?: CpkInfo;\n  /**\n   * Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to\n   * encrypt the data provided in the request. If not specified, encryption is performed with the\n   * default account encryption scope.  For more information, see Encryption at Rest for Azure\n   * Storage Services.\n   */\n  encryptionScope?: string;\n}\n\n/**\n * Options to configure the {@link PageBlobClient.clearPages} operation.\n */\nexport interface PageBlobClearPagesOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Conditions to meet when clearing pages.\n   */\n  conditions?: PageBlobRequestConditions;\n  /**\n   * Customer Provided Key Info.\n   */\n  customerProvidedKey?: CpkInfo;\n  /**\n   * Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to\n   * encrypt the data provided in the request. If not specified, encryption is performed with the\n   * default account encryption scope.  For more information, see Encryption at Rest for Azure\n   * Storage Services.\n   */\n  encryptionScope?: string;\n}\n\n/**\n * Options to configure the {@link PageBlobClient.getPageRanges} operation.\n */\nexport interface PageBlobGetPageRangesOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Conditions to meet when getting page ranges.\n   */\n  conditions?: BlobRequestConditions;\n}\n\n/**\n * Options to configure page blob - get page ranges segment operations.\n *\n * See:\n * - {@link PageBlobClient.listPageRangesSegment}\n * - {@link PageBlobClient.listPageRangeItemSegments}\n * - {@link PageBlobClient.listPageRangeItems}\n */\ninterface PageBlobListPageRangesSegmentOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Conditions to meet when getting page ranges.\n   */\n  conditions?: BlobRequestConditions;\n  /**\n   * Specifies the maximum number of containers\n   * to return. If the request does not specify maxPageSize, or specifies a\n   * value greater than 5000, the server will return up to 5000 items. Note\n   * that if the listing operation crosses a partition boundary, then the\n   * service will return a continuation token for retrieving the remainder of\n   * the results. For this reason, it is possible that the service will return\n   * fewer results than specified by maxPageSize, or than the default of 5000.\n   */\n  maxPageSize?: number;\n}\n\n/**\n * Options to configure the {@link PageBlobClient.listPageRanges} operation.\n */\nexport interface PageBlobListPageRangesOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Conditions to meet when getting page ranges.\n   */\n  conditions?: BlobRequestConditions;\n}\n\n/**\n * Options to configure the {@link PageBlobClient.getRangesDiff} operation.\n */\nexport interface PageBlobGetPageRangesDiffOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Conditions to meet when getting page ranges diff.\n   */\n  conditions?: BlobRequestConditions;\n  /**\n   * (unused)\n   */\n  range?: string;\n}\n\n/**\n * Options to configure page blob - get page ranges diff segment operations.\n *\n * See:\n * - {@link PageBlobClient.listPageRangesDiffSegment}\n * - {@link PageBlobClient.listPageRangeDiffItemSegments}\n * - {@link PageBlobClient.listPageRangeDiffItems}\n */\ninterface PageBlobListPageRangesDiffSegmentOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Conditions to meet when getting page ranges.\n   */\n  conditions?: BlobRequestConditions;\n  /**\n   * Specifies the maximum number of containers\n   * to return. If the request does not specify maxPageSize, or specifies a\n   * value greater than 5000, the server will return up to 5000 items. Note\n   * that if the listing operation crosses a partition boundary, then the\n   * service will return a continuation token for retrieving the remainder of\n   * the results. For this reason, it is possible that the service will return\n   * fewer results than specified by maxPageSize, or than the default of 5000.\n   */\n  maxPageSize?: number;\n}\n\n/**\n * Options to configure the {@link PageBlobClient.listPageRangesDiff} operation.\n */\nexport interface PageBlobListPageRangesDiffOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Conditions to meet when getting page ranges diff.\n   */\n  conditions?: BlobRequestConditions;\n}\n\n/**\n * Options to configure {@link PageBlobClient.resize} operation.\n */\nexport interface PageBlobResizeOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Conditions to meet when resizing a page blob.\n   */\n  conditions?: BlobRequestConditions;\n  /**\n   * Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to\n   * encrypt the data provided in the request. If not specified, encryption is performed with the\n   * default account encryption scope.  For more information, see Encryption at Rest for Azure\n   * Storage Services.\n   */\n  encryptionScope?: string;\n}\n\n/**\n * Options to configure {@link PageBlobClient.updateSequenceNumber} operation.\n */\nexport interface PageBlobUpdateSequenceNumberOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Conditions to meet when updating sequence number.\n   */\n  conditions?: BlobRequestConditions;\n}\n\n/**\n * Options to configure {@link PageBlobClient.startCopyIncremental} operation.\n */\nexport interface PageBlobStartCopyIncrementalOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Conditions to meet when starting a copy incremental operation.\n   */\n  conditions?: ModifiedAccessConditions;\n}\n\n/**\n * Options to configure {@link PageBlobClient.uploadPagesFromURL} operation.\n */\nexport interface PageBlobUploadPagesFromURLOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Conditions to meet when updating sequence number.\n   */\n  conditions?: PageBlobRequestConditions;\n  /**\n   * Conditions to meet for the source Azure Blob/File when copying from a URL to the blob.\n   */\n  sourceConditions?: MatchConditions & ModificationConditions;\n  /**\n   * An MD5 hash of the content from the URI.\n   * This hash is used to verify the integrity of the content during transport of the data from the URI.\n   * When this is specified, the storage service compares the hash of the content that has arrived from the copy-source with this value.\n   *\n   * sourceContentMD5 and sourceContentCrc64 cannot be set at same time.\n   */\n  sourceContentMD5?: Uint8Array;\n  /**\n   * A CRC64 hash of the content from the URI.\n   * This hash is used to verify the integrity of the content during transport of the data from the URI.\n   * When this is specified, the storage service compares the hash of the content that has arrived from the copy-source with this value.\n   *\n   * sourceContentMD5 and sourceContentCrc64 cannot be set at same time.\n   */\n  sourceContentCrc64?: Uint8Array;\n  /**\n   * Customer Provided Key Info.\n   */\n  customerProvidedKey?: CpkInfo;\n  /**\n   * Optional. Version 2019-07-07 and later.  Specifies the name of the encryption scope to use to\n   * encrypt the data provided in the request. If not specified, encryption is performed with the\n   * default account encryption scope.  For more information, see Encryption at Rest for Azure\n   * Storage Services.\n   */\n  encryptionScope?: string;\n  /**\n   * Only Bearer type is supported. Credentials should be a valid OAuth access token to copy source.\n   */\n  sourceAuthorization?: HttpAuthorization;\n}\n\n/**\n * Contains response data for the {@link PageBlobClient.createIfNotExists} operation.\n */\nexport interface PageBlobCreateIfNotExistsResponse extends PageBlobCreateResponse {\n  /**\n   * Indicate whether the blob is successfully created. Is false when the blob is not changed as it already exists.\n   */\n  succeeded: boolean;\n}\n\n/**\n * PageBlobClient defines a set of operations applicable to page blobs.\n */\nexport class PageBlobClient extends BlobClient {\n  /**\n   * pageBlobsContext provided by protocol layer.\n   */\n  private pageBlobContext: PageBlob;\n\n  /**\n   *\n   * Creates an instance of PageBlobClient.\n   *\n   * @param connectionString - Account connection string or a SAS connection string of an Azure storage account.\n   *                                  [ Note - Account connection string can only be used in NODE.JS runtime. ]\n   *                                  Account connection string example -\n   *                                  `DefaultEndpointsProtocol=https;AccountName=myaccount;AccountKey=accountKey;EndpointSuffix=core.windows.net`\n   *                                  SAS connection string example -\n   *                                  `BlobEndpoint=https://myaccount.blob.core.windows.net/;QueueEndpoint=https://myaccount.queue.core.windows.net/;FileEndpoint=https://myaccount.file.core.windows.net/;TableEndpoint=https://myaccount.table.core.windows.net/;SharedAccessSignature=sasString`\n   * @param containerName - Container name.\n   * @param blobName - Blob name.\n   * @param options - Optional. Options to configure the HTTP pipeline.\n   */\n  constructor(\n    connectionString: string,\n    containerName: string,\n    blobName: string,\n    // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n    options?: StoragePipelineOptions\n  );\n  /**\n   * Creates an instance of PageBlobClient.\n   * This method accepts an encoded URL or non-encoded URL pointing to a blob.\n   * Encoded URL string will NOT be escaped twice, only special characters in URL path will be escaped.\n   * If a blob name includes ? or %, blob name must be encoded in the URL.\n   *\n   * @param url - A Client string pointing to Azure Storage page blob, such as\n   *                     \"https://myaccount.blob.core.windows.net/mycontainer/pageblob\". You can append a SAS\n   *                     if using AnonymousCredential, such as \"https://myaccount.blob.core.windows.net/mycontainer/pageblob?sasString\".\n   * @param credential -  Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.\n   * @param options - Optional. Options to configure the HTTP pipeline.\n   */\n  constructor(\n    url: string,\n    credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential,\n    // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n    options?: StoragePipelineOptions\n  );\n  /**\n   * Creates an instance of PageBlobClient.\n   *\n   * @param url - A URL string pointing to Azure Storage page blob, such as\n   *                     \"https://myaccount.blob.core.windows.net/mycontainer/pageblob\".\n   *                     You can append a SAS if using AnonymousCredential, such as\n   *                     \"https://myaccount.blob.core.windows.net/mycontainer/pageblob?sasString\".\n   *                     This method accepts an encoded URL or non-encoded URL pointing to a blob.\n   *                     Encoded URL string will NOT be escaped twice, only special characters in URL path will be escaped.\n   *                     However, if a blob name includes ? or %, blob name must be encoded in the URL.\n   *                     Such as a blob named \"my?blob%\", the URL should be \"https://myaccount.blob.core.windows.net/mycontainer/my%3Fblob%25\".\n   * @param pipeline - Call newPipeline() to create a default\n   *                            pipeline, or provide a customized pipeline.\n   */\n  constructor(url: string, pipeline: PipelineLike);\n  constructor(\n    urlOrConnectionString: string,\n    credentialOrPipelineOrContainerName:\n      | string\n      | StorageSharedKeyCredential\n      | AnonymousCredential\n      | TokenCredential\n      | PipelineLike,\n    blobNameOrOptions?: string | StoragePipelineOptions,\n    // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n    options?: StoragePipelineOptions\n  ) {\n    // In TypeScript we cannot simply pass all parameters to super() like below so have to duplicate the code instead.\n    //   super(s, credentialOrPipelineOrContainerNameOrOptions, blobNameOrOptions, options);\n    let pipeline: PipelineLike;\n    let url: string;\n    options = options || {};\n    if (isPipelineLike(credentialOrPipelineOrContainerName)) {\n      // (url: string, pipeline: Pipeline)\n      url = urlOrConnectionString;\n      pipeline = credentialOrPipelineOrContainerName;\n    } else if (\n      (isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential) ||\n      credentialOrPipelineOrContainerName instanceof AnonymousCredential ||\n      isTokenCredential(credentialOrPipelineOrContainerName)\n    ) {\n      // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n      url = urlOrConnectionString;\n      options = blobNameOrOptions as StoragePipelineOptions;\n      pipeline = newPipeline(credentialOrPipelineOrContainerName, options);\n    } else if (\n      !credentialOrPipelineOrContainerName &&\n      typeof credentialOrPipelineOrContainerName !== \"string\"\n    ) {\n      // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n      // The second parameter is undefined. Use anonymous credential.\n      url = urlOrConnectionString;\n      pipeline = newPipeline(new AnonymousCredential(), options);\n    } else if (\n      credentialOrPipelineOrContainerName &&\n      typeof credentialOrPipelineOrContainerName === \"string\" &&\n      blobNameOrOptions &&\n      typeof blobNameOrOptions === \"string\"\n    ) {\n      // (connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions)\n      const containerName = credentialOrPipelineOrContainerName;\n      const blobName = blobNameOrOptions;\n\n      const extractedCreds = extractConnectionStringParts(urlOrConnectionString);\n      if (extractedCreds.kind === \"AccountConnString\") {\n        if (isNode) {\n          const sharedKeyCredential = new StorageSharedKeyCredential(\n            extractedCreds.accountName!,\n            extractedCreds.accountKey\n          );\n          url = appendToURLPath(\n            appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)),\n            encodeURIComponent(blobName)\n          );\n\n          if (!options.proxyOptions) {\n            options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);\n          }\n\n          pipeline = newPipeline(sharedKeyCredential, options);\n        } else {\n          throw new Error(\"Account connection string is only supported in Node.js environment\");\n        }\n      } else if (extractedCreds.kind === \"SASConnString\") {\n        url =\n          appendToURLPath(\n            appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)),\n            encodeURIComponent(blobName)\n          ) +\n          \"?\" +\n          extractedCreds.accountSas;\n        pipeline = newPipeline(new AnonymousCredential(), options);\n      } else {\n        throw new Error(\n          \"Connection string must be either an Account connection string or a SAS connection string\"\n        );\n      }\n    } else {\n      throw new Error(\"Expecting non-empty strings for containerName and blobName parameters\");\n    }\n    super(url, pipeline);\n    this.pageBlobContext = new PageBlob(this.storageClientContext);\n  }\n\n  /**\n   * Creates a new PageBlobClient object identical to the source but with the\n   * specified snapshot timestamp.\n   * Provide \"\" will remove the snapshot and return a Client to the base blob.\n   *\n   * @param snapshot - The snapshot timestamp.\n   * @returns A new PageBlobClient object identical to the source but with the specified snapshot timestamp.\n   */\n  public withSnapshot(snapshot: string): PageBlobClient {\n    return new PageBlobClient(\n      setURLParameter(\n        this.url,\n        URLConstants.Parameters.SNAPSHOT,\n        snapshot.length === 0 ? undefined : snapshot\n      ),\n      this.pipeline\n    );\n  }\n\n  /**\n   * Creates a page blob of the specified length. Call uploadPages to upload data\n   * data to a page blob.\n   * @see https://docs.microsoft.com/rest/api/storageservices/put-blob\n   *\n   * @param size - size of the page blob.\n   * @param options - Options to the Page Blob Create operation.\n   * @returns Response data for the Page Blob Create operation.\n   */\n  public async create(\n    size: number,\n    options: PageBlobCreateOptions = {}\n  ): Promise<PageBlobCreateResponse> {\n    options.conditions = options.conditions || {};\n    const { span, updatedOptions } = createSpan(\"PageBlobClient-create\", options);\n    try {\n      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n      return await this.pageBlobContext.create(0, size, {\n        abortSignal: options.abortSignal,\n        blobHttpHeaders: options.blobHTTPHeaders,\n        blobSequenceNumber: options.blobSequenceNumber,\n        leaseAccessConditions: options.conditions,\n        metadata: options.metadata,\n        modifiedAccessConditions: {\n          ...options.conditions,\n          ifTags: options.conditions?.tagConditions,\n        },\n        cpkInfo: options.customerProvidedKey,\n        encryptionScope: options.encryptionScope,\n        immutabilityPolicyExpiry: options.immutabilityPolicy?.expiriesOn,\n        immutabilityPolicyMode: options.immutabilityPolicy?.policyMode,\n        legalHold: options.legalHold,\n        tier: toAccessTier(options.tier),\n        blobTagsString: toBlobTagsString(options.tags),\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates a page blob of the specified length. Call uploadPages to upload data\n   * data to a page blob. If the blob with the same name already exists, the content\n   * of the existing blob will remain unchanged.\n   * @see https://docs.microsoft.com/rest/api/storageservices/put-blob\n   *\n   * @param size - size of the page blob.\n   * @param options -\n   */\n  public async createIfNotExists(\n    size: number,\n    options: PageBlobCreateIfNotExistsOptions = {}\n  ): Promise<PageBlobCreateIfNotExistsResponse> {\n    const { span, updatedOptions } = createSpan(\"PageBlobClient-createIfNotExists\", options);\n    try {\n      const conditions = { ifNoneMatch: ETagAny };\n      const res = await this.create(size, {\n        ...options,\n        conditions,\n        tracingOptions: updatedOptions.tracingOptions,\n      });\n      return {\n        succeeded: true,\n        ...res,\n        _response: res._response, // _response is made non-enumerable\n      };\n    } catch (e: any) {\n      if (e.details?.errorCode === \"BlobAlreadyExists\") {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: \"Expected exception when creating a blob only if it does not already exist.\",\n        });\n        return {\n          succeeded: false,\n          ...e.response?.parsedHeaders,\n          _response: e.response,\n        };\n      }\n\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Writes 1 or more pages to the page blob. The start and end offsets must be a multiple of 512.\n   * @see https://docs.microsoft.com/rest/api/storageservices/put-page\n   *\n   * @param body - Data to upload\n   * @param offset - Offset of destination page blob\n   * @param count - Content length of the body, also number of bytes to be uploaded\n   * @param options - Options to the Page Blob Upload Pages operation.\n   * @returns Response data for the Page Blob Upload Pages operation.\n   */\n  public async uploadPages(\n    body: HttpRequestBody,\n    offset: number,\n    count: number,\n    options: PageBlobUploadPagesOptions = {}\n  ): Promise<PageBlobUploadPagesResponse> {\n    options.conditions = options.conditions || {};\n    const { span, updatedOptions } = createSpan(\"PageBlobClient-uploadPages\", options);\n    try {\n      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n      return await this.pageBlobContext.uploadPages(count, body, {\n        abortSignal: options.abortSignal,\n        leaseAccessConditions: options.conditions,\n        modifiedAccessConditions: {\n          ...options.conditions,\n          ifTags: options.conditions?.tagConditions,\n        },\n        requestOptions: {\n          onUploadProgress: options.onProgress,\n        },\n        range: rangeToString({ offset, count }),\n        sequenceNumberAccessConditions: options.conditions,\n        transactionalContentMD5: options.transactionalContentMD5,\n        transactionalContentCrc64: options.transactionalContentCrc64,\n        cpkInfo: options.customerProvidedKey,\n        encryptionScope: options.encryptionScope,\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * The Upload Pages operation writes a range of pages to a page blob where the\n   * contents are read from a URL.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/put-page-from-url\n   *\n   * @param sourceURL - Specify a URL to the copy source, Shared Access Signature(SAS) maybe needed for authentication\n   * @param sourceOffset - The source offset to copy from. Pass 0 to copy from the beginning of source page blob\n   * @param destOffset - Offset of destination page blob\n   * @param count - Number of bytes to be uploaded from source page blob\n   * @param options -\n   */\n  public async uploadPagesFromURL(\n    sourceURL: string,\n    sourceOffset: number,\n    destOffset: number,\n    count: number,\n    options: PageBlobUploadPagesFromURLOptions = {}\n  ): Promise<PageBlobUploadPagesFromURLResponse> {\n    options.conditions = options.conditions || {};\n    options.sourceConditions = options.sourceConditions || {};\n    const { span, updatedOptions } = createSpan(\"PageBlobClient-uploadPagesFromURL\", options);\n    try {\n      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n      return await this.pageBlobContext.uploadPagesFromURL(\n        sourceURL,\n        rangeToString({ offset: sourceOffset, count }),\n        0,\n        rangeToString({ offset: destOffset, count }),\n        {\n          abortSignal: options.abortSignal,\n          sourceContentMD5: options.sourceContentMD5,\n          sourceContentCrc64: options.sourceContentCrc64,\n          leaseAccessConditions: options.conditions,\n          sequenceNumberAccessConditions: options.conditions,\n          modifiedAccessConditions: {\n            ...options.conditions,\n            ifTags: options.conditions?.tagConditions,\n          },\n          sourceModifiedAccessConditions: {\n            sourceIfMatch: options.sourceConditions.ifMatch,\n            sourceIfModifiedSince: options.sourceConditions.ifModifiedSince,\n            sourceIfNoneMatch: options.sourceConditions.ifNoneMatch,\n            sourceIfUnmodifiedSince: options.sourceConditions.ifUnmodifiedSince,\n          },\n          cpkInfo: options.customerProvidedKey,\n          encryptionScope: options.encryptionScope,\n          copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization),\n          ...convertTracingToRequestOptionsBase(updatedOptions),\n        }\n      );\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Frees the specified pages from the page blob.\n   * @see https://docs.microsoft.com/rest/api/storageservices/put-page\n   *\n   * @param offset - Starting byte position of the pages to clear.\n   * @param count - Number of bytes to clear.\n   * @param options - Options to the Page Blob Clear Pages operation.\n   * @returns Response data for the Page Blob Clear Pages operation.\n   */\n  public async clearPages(\n    offset: number = 0,\n    count?: number,\n    options: PageBlobClearPagesOptions = {}\n  ): Promise<PageBlobClearPagesResponse> {\n    options.conditions = options.conditions || {};\n    const { span, updatedOptions } = createSpan(\"PageBlobClient-clearPages\", options);\n    try {\n      return await this.pageBlobContext.clearPages(0, {\n        abortSignal: options.abortSignal,\n        leaseAccessConditions: options.conditions,\n        modifiedAccessConditions: {\n          ...options.conditions,\n          ifTags: options.conditions?.tagConditions,\n        },\n        range: rangeToString({ offset, count }),\n        sequenceNumberAccessConditions: options.conditions,\n        cpkInfo: options.customerProvidedKey,\n        encryptionScope: options.encryptionScope,\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Returns the list of valid page ranges for a page blob or snapshot of a page blob.\n   * @see https://docs.microsoft.com/rest/api/storageservices/get-page-ranges\n   *\n   * @param offset - Starting byte position of the page ranges.\n   * @param count - Number of bytes to get.\n   * @param options - Options to the Page Blob Get Ranges operation.\n   * @returns Response data for the Page Blob Get Ranges operation.\n   */\n  public async getPageRanges(\n    offset: number = 0,\n    count?: number,\n    options: PageBlobGetPageRangesOptions = {}\n  ): Promise<PageBlobGetPageRangesResponse> {\n    options.conditions = options.conditions || {};\n    const { span, updatedOptions } = createSpan(\"PageBlobClient-getPageRanges\", options);\n    try {\n      return await this.pageBlobContext\n        .getPageRanges({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: {\n            ...options.conditions,\n            ifTags: options.conditions?.tagConditions,\n          },\n          range: rangeToString({ offset, count }),\n          ...convertTracingToRequestOptionsBase(updatedOptions),\n        })\n        .then(rangeResponseFromModel);\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * getPageRangesSegment returns a single segment of page ranges starting from the\n   * specified Marker. Use an empty Marker to start enumeration from the beginning.\n   * After getting a segment, process it, and then call getPageRangesSegment again\n   * (passing the the previously-returned Marker) to get the next segment.\n   * @see https://docs.microsoft.com/rest/api/storageservices/get-page-ranges\n   *\n   * @param offset - Starting byte position of the page ranges.\n   * @param count - Number of bytes to get.\n   * @param marker - A string value that identifies the portion of the list to be returned with the next list operation.\n   * @param options - Options to PageBlob Get Page Ranges Segment operation.\n   */\n  private async listPageRangesSegment(\n    offset: number = 0,\n    count?: number,\n    marker?: string,\n    options: PageBlobListPageRangesSegmentOptions = {}\n  ): Promise<PageBlobGetPageRangesResponseModel> {\n    const { span, updatedOptions } = createSpan(\"PageBlobClient-getPageRangesSegment\", options);\n    try {\n      return await this.pageBlobContext.getPageRanges({\n        abortSignal: options.abortSignal,\n        leaseAccessConditions: options.conditions,\n        modifiedAccessConditions: {\n          ...options.conditions,\n          ifTags: options.conditions?.tagConditions,\n        },\n        range: rangeToString({ offset, count }),\n        marker: marker,\n        maxPageSize: options.maxPageSize,\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Returns an AsyncIterableIterator for {@link PageBlobGetPageRangesResponseModel}\n   *\n   * @param offset - Starting byte position of the page ranges.\n   * @param count - Number of bytes to get.\n   * @param marker - A string value that identifies the portion of\n   *                          the get of page ranges to be returned with the next getting operation. The\n   *                          operation returns the ContinuationToken value within the response body if the\n   *                          getting operation did not return all page ranges remaining within the current page.\n   *                          The ContinuationToken value can be used as the value for\n   *                          the marker parameter in a subsequent call to request the next page of get\n   *                          items. The marker value is opaque to the client.\n   * @param options - Options to List Page Ranges operation.\n   */\n  private async *listPageRangeItemSegments(\n    offset: number = 0,\n    count?: number,\n    marker?: string,\n    options: PageBlobListPageRangesSegmentOptions = {}\n  ): AsyncIterableIterator<PageBlobGetPageRangesResponseModel> {\n    let getPageRangeItemSegmentsResponse;\n    if (!!marker || marker === undefined) {\n      do {\n        getPageRangeItemSegmentsResponse = await this.listPageRangesSegment(\n          offset,\n          count,\n          marker,\n          options\n        );\n        marker = getPageRangeItemSegmentsResponse.continuationToken;\n        yield await getPageRangeItemSegmentsResponse;\n      } while (marker);\n    }\n  }\n\n  /**\n   * Returns an AsyncIterableIterator of {@link PageRangeInfo} objects\n   *\n   * @param offset - Starting byte position of the page ranges.\n   * @param count - Number of bytes to get.\n   * @param options - Options to List Page Ranges operation.\n   */\n  private async *listPageRangeItems(\n    offset: number = 0,\n    count?: number,\n    options: PageBlobListPageRangesSegmentOptions = {}\n  ): AsyncIterableIterator<PageRangeInfo> {\n    let marker: string | undefined;\n    for await (const getPageRangesSegment of this.listPageRangeItemSegments(\n      offset,\n      count,\n      marker,\n      options\n    )) {\n      yield* ExtractPageRangeInfoItems(getPageRangesSegment);\n    }\n  }\n\n  /**\n   * Returns an async iterable iterator to list of page ranges for a page blob.\n   * @see https://docs.microsoft.com/rest/api/storageservices/get-page-ranges\n   *\n   *  .byPage() returns an async iterable iterator to list of page ranges for a page blob.\n   *\n   * Example using `for await` syntax:\n   *\n   * ```js\n   * // Get the pageBlobClient before you run these snippets,\n   * // Can be obtained from `blobServiceClient.getContainerClient(\"<your-container-name>\").getPageBlobClient(\"<your-blob-name>\");`\n   * let i = 1;\n   * for await (const pageRange of pageBlobClient.listPageRanges()) {\n   *   console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);\n   * }\n   * ```\n   *\n   * Example using `iter.next()`:\n   *\n   * ```js\n   * let i = 1;\n   * let iter = pageBlobClient.listPageRanges();\n   * let pageRangeItem = await iter.next();\n   * while (!pageRangeItem.done) {\n   *   console.log(`Page range ${i++}: ${pageRangeItem.value.start} - ${pageRangeItem.value.end}, IsClear: ${pageRangeItem.value.isClear}`);\n   *   pageRangeItem = await iter.next();\n   * }\n   * ```\n   *\n   * Example using `byPage()`:\n   *\n   * ```js\n   * // passing optional maxPageSize in the page settings\n   * let i = 1;\n   * for await (const response of pageBlobClient.listPageRanges().byPage({ maxPageSize: 20 })) {\n   *   for (const pageRange of response) {\n   *     console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);\n   *   }\n   * }\n   * ```\n   *\n   * Example using paging with a marker:\n   *\n   * ```js\n   * let i = 1;\n   * let iterator = pageBlobClient.listPageRanges().byPage({ maxPageSize: 2 });\n   * let response = (await iterator.next()).value;\n   *\n   * // Prints 2 page ranges\n   * for (const pageRange of response) {\n   *   console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);\n   * }\n   *\n   * // Gets next marker\n   * let marker = response.continuationToken;\n   *\n   * // Passing next marker as continuationToken\n   *\n   * iterator = pageBlobClient.listPageRanges().byPage({ continuationToken: marker, maxPageSize: 10 });\n   * response = (await iterator.next()).value;\n   *\n   * // Prints 10 page ranges\n   * for (const blob of response) {\n   *   console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);\n   * }\n   * ```\n   * @param offset - Starting byte position of the page ranges.\n   * @param count - Number of bytes to get.\n   * @param options - Options to the Page Blob Get Ranges operation.\n   * @returns An asyncIterableIterator that supports paging.\n   */\n  public listPageRanges(\n    offset: number = 0,\n    count?: number,\n    options: PageBlobListPageRangesOptions = {}\n  ): PagedAsyncIterableIterator<PageRangeInfo, PageBlobGetPageRangesResponseModel> {\n    options.conditions = options.conditions || {};\n    // AsyncIterableIterator to iterate over blobs\n    const iter = this.listPageRangeItems(offset, count, options);\n    return {\n      /**\n       * The next method, part of the iteration protocol\n       */\n      next() {\n        return iter.next();\n      },\n      /**\n       * The connection to the async iterator, part of the iteration protocol\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      /**\n       * Return an AsyncIterableIterator that works a page at a time\n       */\n      byPage: (settings: PageSettings = {}) => {\n        return this.listPageRangeItemSegments(offset, count, settings.continuationToken, {\n          maxPageSize: settings.maxPageSize,\n          ...options,\n        });\n      },\n    };\n  }\n\n  /**\n   * Gets the collection of page ranges that differ between a specified snapshot and this page blob.\n   * @see https://docs.microsoft.com/rest/api/storageservices/get-page-ranges\n   *\n   * @param offset - Starting byte position of the page blob\n   * @param count - Number of bytes to get ranges diff.\n   * @param prevSnapshot - Timestamp of snapshot to retrieve the difference.\n   * @param options - Options to the Page Blob Get Page Ranges Diff operation.\n   * @returns Response data for the Page Blob Get Page Range Diff operation.\n   */\n  public async getPageRangesDiff(\n    offset: number,\n    count: number,\n    prevSnapshot: string,\n    options: PageBlobGetPageRangesDiffOptions = {}\n  ): Promise<PageBlobGetPageRangesDiffResponse> {\n    options.conditions = options.conditions || {};\n    const { span, updatedOptions } = createSpan(\"PageBlobClient-getPageRangesDiff\", options);\n\n    try {\n      return await this.pageBlobContext\n        .getPageRangesDiff({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: {\n            ...options.conditions,\n            ifTags: options.conditions?.tagConditions,\n          },\n          prevsnapshot: prevSnapshot,\n          range: rangeToString({ offset, count }),\n          ...convertTracingToRequestOptionsBase(updatedOptions),\n        })\n        .then(rangeResponseFromModel);\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * getPageRangesDiffSegment returns a single segment of page ranges starting from the\n   * specified Marker for difference between previous snapshot and the target page blob.\n   * Use an empty Marker to start enumeration from the beginning.\n   * After getting a segment, process it, and then call getPageRangesDiffSegment again\n   * (passing the the previously-returned Marker) to get the next segment.\n   * @see https://docs.microsoft.com/rest/api/storageservices/get-page-ranges\n   *\n   * @param offset - Starting byte position of the page ranges.\n   * @param count - Number of bytes to get.\n   * @param prevSnapshotOrUrl - Timestamp of snapshot to retrieve the difference or URL of snapshot to retrieve the difference.\n   * @param marker - A string value that identifies the portion of the get to be returned with the next get operation.\n   * @param options - Options to the Page Blob Get Page Ranges Diff operation.\n   */\n  private async listPageRangesDiffSegment(\n    offset: number,\n    count: number,\n    prevSnapshotOrUrl: string,\n    marker?: string,\n    options?: PageBlobListPageRangesDiffSegmentOptions\n  ): Promise<PageBlobGetPageRangesResponseModel> {\n    const { span, updatedOptions } = createSpan(\"PageBlobClient-getPageRangesDiffSegment\", options);\n    try {\n      return await this.pageBlobContext.getPageRangesDiff({\n        abortSignal: options?.abortSignal,\n        leaseAccessConditions: options?.conditions,\n        modifiedAccessConditions: {\n          ...options?.conditions,\n          ifTags: options?.conditions?.tagConditions,\n        },\n        prevsnapshot: prevSnapshotOrUrl,\n        range: rangeToString({\n          offset: offset,\n          count: count,\n        }),\n        marker: marker,\n        maxPageSize: options?.maxPageSize,\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Returns an AsyncIterableIterator for {@link PageBlobGetPageRangesDiffResponseModel}\n   *\n   *\n   * @param offset - Starting byte position of the page ranges.\n   * @param count - Number of bytes to get.\n   * @param prevSnapshotOrUrl - Timestamp of snapshot to retrieve the difference or URL of snapshot to retrieve the difference.\n   * @param marker - A string value that identifies the portion of\n   *                          the get of page ranges to be returned with the next getting operation. The\n   *                          operation returns the ContinuationToken value within the response body if the\n   *                          getting operation did not return all page ranges remaining within the current page.\n   *                          The ContinuationToken value can be used as the value for\n   *                          the marker parameter in a subsequent call to request the next page of get\n   *                          items. The marker value is opaque to the client.\n   * @param options - Options to the Page Blob Get Page Ranges Diff operation.\n   */\n  private async *listPageRangeDiffItemSegments(\n    offset: number,\n    count: number,\n    prevSnapshotOrUrl: string,\n    marker?: string,\n    options?: PageBlobListPageRangesDiffSegmentOptions\n  ): AsyncIterableIterator<PageBlobGetPageRangesDiffResponseModel> {\n    let getPageRangeItemSegmentsResponse;\n    if (!!marker || marker === undefined) {\n      do {\n        getPageRangeItemSegmentsResponse = await this.listPageRangesDiffSegment(\n          offset,\n          count,\n          prevSnapshotOrUrl,\n          marker,\n          options\n        );\n        marker = getPageRangeItemSegmentsResponse.continuationToken;\n        yield await getPageRangeItemSegmentsResponse;\n      } while (marker);\n    }\n  }\n\n  /**\n   * Returns an AsyncIterableIterator of {@link PageRangeInfo} objects\n   *\n   * @param offset - Starting byte position of the page ranges.\n   * @param count - Number of bytes to get.\n   * @param prevSnapshotOrUrl - Timestamp of snapshot to retrieve the difference or URL of snapshot to retrieve the difference.\n   * @param options - Options to the Page Blob Get Page Ranges Diff operation.\n   */\n  private async *listPageRangeDiffItems(\n    offset: number,\n    count: number,\n    prevSnapshotOrUrl: string,\n    options?: PageBlobListPageRangesDiffSegmentOptions\n  ): AsyncIterableIterator<PageRangeInfo> {\n    let marker: string | undefined;\n    for await (const getPageRangesSegment of this.listPageRangeDiffItemSegments(\n      offset,\n      count,\n      prevSnapshotOrUrl,\n      marker,\n      options\n    )) {\n      yield* ExtractPageRangeInfoItems(getPageRangesSegment);\n    }\n  }\n\n  /**\n   * Returns an async iterable iterator to list of page ranges that differ between a specified snapshot and this page blob.\n   * @see https://docs.microsoft.com/rest/api/storageservices/get-page-ranges\n   *\n   *  .byPage() returns an async iterable iterator to list of page ranges that differ between a specified snapshot and this page blob.\n   *\n   * Example using `for await` syntax:\n   *\n   * ```js\n   * // Get the pageBlobClient before you run these snippets,\n   * // Can be obtained from `blobServiceClient.getContainerClient(\"<your-container-name>\").getPageBlobClient(\"<your-blob-name>\");`\n   * let i = 1;\n   * for await (const pageRange of pageBlobClient.listPageRangesDiff()) {\n   *   console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);\n   * }\n   * ```\n   *\n   * Example using `iter.next()`:\n   *\n   * ```js\n   * let i = 1;\n   * let iter = pageBlobClient.listPageRangesDiff();\n   * let pageRangeItem = await iter.next();\n   * while (!pageRangeItem.done) {\n   *   console.log(`Page range ${i++}: ${pageRangeItem.value.start} - ${pageRangeItem.value.end}, IsClear: ${pageRangeItem.value.isClear}`);\n   *   pageRangeItem = await iter.next();\n   * }\n   * ```\n   *\n   * Example using `byPage()`:\n   *\n   * ```js\n   * // passing optional maxPageSize in the page settings\n   * let i = 1;\n   * for await (const response of pageBlobClient.listPageRangesDiff().byPage({ maxPageSize: 20 })) {\n   *   for (const pageRange of response) {\n   *     console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);\n   *   }\n   * }\n   * ```\n   *\n   * Example using paging with a marker:\n   *\n   * ```js\n   * let i = 1;\n   * let iterator = pageBlobClient.listPageRangesDiff().byPage({ maxPageSize: 2 });\n   * let response = (await iterator.next()).value;\n   *\n   * // Prints 2 page ranges\n   * for (const pageRange of response) {\n   *   console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);\n   * }\n   *\n   * // Gets next marker\n   * let marker = response.continuationToken;\n   *\n   * // Passing next marker as continuationToken\n   *\n   * iterator = pageBlobClient.listPageRangesDiff().byPage({ continuationToken: marker, maxPageSize: 10 });\n   * response = (await iterator.next()).value;\n   *\n   * // Prints 10 page ranges\n   * for (const blob of response) {\n   *   console.log(`Page range ${i++}: ${pageRange.start} - ${pageRange.end}`);\n   * }\n   * ```\n   * @param offset - Starting byte position of the page ranges.\n   * @param count - Number of bytes to get.\n   * @param prevSnapshot - Timestamp of snapshot to retrieve the difference.\n   * @param options - Options to the Page Blob Get Ranges operation.\n   * @returns An asyncIterableIterator that supports paging.\n   */\n  public listPageRangesDiff(\n    offset: number,\n    count: number,\n    prevSnapshot: string,\n    options: PageBlobListPageRangesDiffOptions = {}\n  ): PagedAsyncIterableIterator<PageRangeInfo, PageBlobGetPageRangesDiffResponseModel> {\n    options.conditions = options.conditions || {};\n\n    // AsyncIterableIterator to iterate over blobs\n    const iter = this.listPageRangeDiffItems(offset, count, prevSnapshot, {\n      ...options,\n    });\n    return {\n      /**\n       * The next method, part of the iteration protocol\n       */\n      next() {\n        return iter.next();\n      },\n      /**\n       * The connection to the async iterator, part of the iteration protocol\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      /**\n       * Return an AsyncIterableIterator that works a page at a time\n       */\n      byPage: (settings: PageSettings = {}) => {\n        return this.listPageRangeDiffItemSegments(\n          offset,\n          count,\n          prevSnapshot,\n          settings.continuationToken,\n          {\n            maxPageSize: settings.maxPageSize,\n            ...options,\n          }\n        );\n      },\n    };\n  }\n\n  /**\n   * Gets the collection of page ranges that differ between a specified snapshot and this page blob for managed disks.\n   * @see https://docs.microsoft.com/rest/api/storageservices/get-page-ranges\n   *\n   * @param offset - Starting byte position of the page blob\n   * @param count - Number of bytes to get ranges diff.\n   * @param prevSnapshotUrl - URL of snapshot to retrieve the difference.\n   * @param options - Options to the Page Blob Get Page Ranges Diff operation.\n   * @returns Response data for the Page Blob Get Page Range Diff operation.\n   */\n  public async getPageRangesDiffForManagedDisks(\n    offset: number,\n    count: number,\n    prevSnapshotUrl: string,\n    options: PageBlobGetPageRangesDiffOptions = {}\n  ): Promise<PageBlobGetPageRangesDiffResponse> {\n    options.conditions = options.conditions || {};\n    const { span, updatedOptions } = createSpan(\n      \"PageBlobClient-GetPageRangesDiffForManagedDisks\",\n      options\n    );\n\n    try {\n      return await this.pageBlobContext\n        .getPageRangesDiff({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: {\n            ...options.conditions,\n            ifTags: options.conditions?.tagConditions,\n          },\n          prevSnapshotUrl,\n          range: rangeToString({ offset, count }),\n          ...convertTracingToRequestOptionsBase(updatedOptions),\n        })\n        .then(rangeResponseFromModel);\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Resizes the page blob to the specified size (which must be a multiple of 512).\n   * @see https://docs.microsoft.com/rest/api/storageservices/set-blob-properties\n   *\n   * @param size - Target size\n   * @param options - Options to the Page Blob Resize operation.\n   * @returns Response data for the Page Blob Resize operation.\n   */\n  public async resize(\n    size: number,\n    options: PageBlobResizeOptions = {}\n  ): Promise<PageBlobResizeResponse> {\n    options.conditions = options.conditions || {};\n    const { span, updatedOptions } = createSpan(\"PageBlobClient-resize\", options);\n    try {\n      return await this.pageBlobContext.resize(size, {\n        abortSignal: options.abortSignal,\n        leaseAccessConditions: options.conditions,\n        modifiedAccessConditions: {\n          ...options.conditions,\n          ifTags: options.conditions?.tagConditions,\n        },\n        encryptionScope: options.encryptionScope,\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Sets a page blob's sequence number.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-properties\n   *\n   * @param sequenceNumberAction - Indicates how the service should modify the blob's sequence number.\n   * @param sequenceNumber - Required if sequenceNumberAction is max or update\n   * @param options - Options to the Page Blob Update Sequence Number operation.\n   * @returns Response data for the Page Blob Update Sequence Number operation.\n   */\n  public async updateSequenceNumber(\n    sequenceNumberAction: SequenceNumberActionType,\n    sequenceNumber?: number,\n    options: PageBlobUpdateSequenceNumberOptions = {}\n  ): Promise<PageBlobUpdateSequenceNumberResponse> {\n    options.conditions = options.conditions || {};\n    const { span, updatedOptions } = createSpan(\"PageBlobClient-updateSequenceNumber\", options);\n    try {\n      return await this.pageBlobContext.updateSequenceNumber(sequenceNumberAction, {\n        abortSignal: options.abortSignal,\n        blobSequenceNumber: sequenceNumber,\n        leaseAccessConditions: options.conditions,\n        modifiedAccessConditions: {\n          ...options.conditions,\n          ifTags: options.conditions?.tagConditions,\n        },\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Begins an operation to start an incremental copy from one page blob's snapshot to this page blob.\n   * The snapshot is copied such that only the differential changes between the previously\n   * copied snapshot are transferred to the destination.\n   * The copied snapshots are complete copies of the original snapshot and can be read or copied from as usual.\n   * @see https://docs.microsoft.com/rest/api/storageservices/incremental-copy-blob\n   * @see https://docs.microsoft.com/en-us/azure/virtual-machines/windows/incremental-snapshots\n   *\n   * @param copySource - Specifies the name of the source page blob snapshot. For example,\n   *                            https://myaccount.blob.core.windows.net/mycontainer/myblob?snapshot=<DateTime>\n   * @param options - Options to the Page Blob Copy Incremental operation.\n   * @returns Response data for the Page Blob Copy Incremental operation.\n   */\n  public async startCopyIncremental(\n    copySource: string,\n    options: PageBlobStartCopyIncrementalOptions = {}\n  ): Promise<PageBlobCopyIncrementalResponse> {\n    const { span, updatedOptions } = createSpan(\"PageBlobClient-startCopyIncremental\", options);\n    try {\n      return await this.pageBlobContext.copyIncremental(copySource, {\n        abortSignal: options.abortSignal,\n        modifiedAccessConditions: {\n          ...options.conditions,\n          ifTags: options.conditions?.tagConditions,\n        },\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}