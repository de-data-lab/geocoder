{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { getOperationLocation, getOperationStatus, getResourceLocation, getStatusFromInitialResponse, inferLroMode, isOperationError, parseRetryAfter } from \"./operation\";\nimport { buildCreatePoller } from \"../poller/poller\";\n/**\n * Creates a poller that can be used to poll a long-running operation.\n * @param lro - Description of the long-running operation\n * @param options - options to configure the poller\n * @returns an initialized poller\n */\nexport async function createHttpPoller(lro, options) {\n  const {\n    resourceLocationConfig,\n    intervalInMs,\n    processResult,\n    restoreFrom,\n    updateState,\n    withOperationLocation,\n    resolveOnUnsuccessful = false\n  } = options || {};\n  return buildCreatePoller({\n    getStatusFromInitialResponse,\n    getStatusFromPollResponse: getOperationStatus,\n    isOperationError,\n    getOperationLocation,\n    getResourceLocation,\n    getPollingInterval: parseRetryAfter,\n    resolveOnUnsuccessful\n  })({\n    init: async () => {\n      const response = await lro.sendInitialRequest();\n      const config = inferLroMode({\n        rawResponse: response.rawResponse,\n        requestPath: lro.requestPath,\n        requestMethod: lro.requestMethod,\n        resourceLocationConfig\n      });\n      return Object.assign({\n        response,\n        operationLocation: config === null || config === void 0 ? void 0 : config.operationLocation,\n        resourceLocation: config === null || config === void 0 ? void 0 : config.resourceLocation\n      }, (config === null || config === void 0 ? void 0 : config.mode) ? {\n        metadata: {\n          mode: config.mode\n        }\n      } : {});\n    },\n    poll: lro.sendPollRequest\n  }, {\n    intervalInMs,\n    withOperationLocation,\n    restoreFrom,\n    updateState,\n    processResult: processResult ? (_ref, state) => {\n      let {\n        flatResponse\n      } = _ref;\n      return processResult(flatResponse, state);\n    } : _ref2 => {\n      let {\n        flatResponse\n      } = _ref2;\n      return flatResponse;\n    }\n  });\n}","map":{"version":3,"mappings":"AAAA;AACA;AAIA,SACEA,oBAAoB,EACpBC,kBAAkB,EAClBC,mBAAmB,EACnBC,4BAA4B,EAC5BC,YAAY,EACZC,gBAAgB,EAChBC,eAAe,QACV,aAAa;AAEpB,SAASC,iBAAiB,QAAQ,kBAAkB;AAEpD;;;;;;AAMA,OAAO,eAAeC,gBAAgB,CACpCC,GAAyB,EACzBC,OAAkD;EAElD,MAAM;IACJC,sBAAsB;IACtBC,YAAY;IACZC,aAAa;IACbC,WAAW;IACXC,WAAW;IACXC,qBAAqB;IACrBC,qBAAqB,GAAG;EAAK,CAC9B,GAAGP,OAAO,IAAI,EAAE;EACjB,OAAOH,iBAAiB,CAA+B;IACrDJ,4BAA4B;IAC5Be,yBAAyB,EAAEjB,kBAAkB;IAC7CI,gBAAgB;IAChBL,oBAAoB;IACpBE,mBAAmB;IACnBiB,kBAAkB,EAAEb,eAAe;IACnCW;GACD,CAAC,CACA;IACEG,IAAI,EAAE,YAAW;MACf,MAAMC,QAAQ,GAAG,MAAMZ,GAAG,CAACa,kBAAkB,EAAE;MAC/C,MAAMC,MAAM,GAAGnB,YAAY,CAAC;QAC1BoB,WAAW,EAAEH,QAAQ,CAACG,WAAW;QACjCC,WAAW,EAAEhB,GAAG,CAACgB,WAAW;QAC5BC,aAAa,EAAEjB,GAAG,CAACiB,aAAa;QAChCf;OACD,CAAC;MACF;QACEU,QAAQ;QACRM,iBAAiB,EAAEJ,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAEI,iBAAiB;QAC5CC,gBAAgB,EAAEL,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAEK;MAAgB,GACtC,OAAM,aAANL,MAAM,uBAANA,MAAM,CAAEM,IAAI,IAAG;QAAEC,QAAQ,EAAE;UAAED,IAAI,EAAEN,MAAM,CAACM;QAAI;MAAE,CAAE,GAAG,EAAE,CAAC;IAEhE,CAAC;IACDE,IAAI,EAAEtB,GAAG,CAACuB;GACX,EACD;IACEpB,YAAY;IACZI,qBAAqB;IACrBF,WAAW;IACXC,WAAW;IACXF,aAAa,EAAEA,aAAa,GACxB,OAAmBoB,KAAK;MAAA,IAAvB;QAAEC;MAAY,CAAE;MAAA,OAAYrB,aAAa,CAACqB,YAAY,EAAED,KAAK,CAAC;IAAA,IAC/D;MAAA,IAAC;QAAEC;MAAY,CAAE;MAAA,OAAKA,YAAuB;IAAA;GAClD,CACF;AACH","names":["getOperationLocation","getOperationStatus","getResourceLocation","getStatusFromInitialResponse","inferLroMode","isOperationError","parseRetryAfter","buildCreatePoller","createHttpPoller","lro","options","resourceLocationConfig","intervalInMs","processResult","restoreFrom","updateState","withOperationLocation","resolveOnUnsuccessful","getStatusFromPollResponse","getPollingInterval","init","response","sendInitialRequest","config","rawResponse","requestPath","requestMethod","operationLocation","resourceLocation","mode","metadata","poll","sendPollRequest","state","flatResponse"],"sources":["/Users/yupenglei/Documents/geo-react/node_modules/@azure/core-lro/src/http/poller.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { LongRunningOperation, LroResponse } from \"./models\";\nimport { OperationState, SimplePollerLike } from \"../poller/models\";\nimport {\n  getOperationLocation,\n  getOperationStatus,\n  getResourceLocation,\n  getStatusFromInitialResponse,\n  inferLroMode,\n  isOperationError,\n  parseRetryAfter,\n} from \"./operation\";\nimport { CreateHttpPollerOptions } from \"./models\";\nimport { buildCreatePoller } from \"../poller/poller\";\n\n/**\n * Creates a poller that can be used to poll a long-running operation.\n * @param lro - Description of the long-running operation\n * @param options - options to configure the poller\n * @returns an initialized poller\n */\nexport async function createHttpPoller<TResult, TState extends OperationState<TResult>>(\n  lro: LongRunningOperation,\n  options?: CreateHttpPollerOptions<TResult, TState>\n): Promise<SimplePollerLike<TState, TResult>> {\n  const {\n    resourceLocationConfig,\n    intervalInMs,\n    processResult,\n    restoreFrom,\n    updateState,\n    withOperationLocation,\n    resolveOnUnsuccessful = false,\n  } = options || {};\n  return buildCreatePoller<LroResponse, TResult, TState>({\n    getStatusFromInitialResponse,\n    getStatusFromPollResponse: getOperationStatus,\n    isOperationError,\n    getOperationLocation,\n    getResourceLocation,\n    getPollingInterval: parseRetryAfter,\n    resolveOnUnsuccessful,\n  })(\n    {\n      init: async () => {\n        const response = await lro.sendInitialRequest();\n        const config = inferLroMode({\n          rawResponse: response.rawResponse,\n          requestPath: lro.requestPath,\n          requestMethod: lro.requestMethod,\n          resourceLocationConfig,\n        });\n        return {\n          response,\n          operationLocation: config?.operationLocation,\n          resourceLocation: config?.resourceLocation,\n          ...(config?.mode ? { metadata: { mode: config.mode } } : {}),\n        };\n      },\n      poll: lro.sendPollRequest,\n    },\n    {\n      intervalInMs,\n      withOperationLocation,\n      restoreFrom,\n      updateState,\n      processResult: processResult\n        ? ({ flatResponse }, state) => processResult(flatResponse, state)\n        : ({ flatResponse }) => flatResponse as TResult,\n    }\n  );\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}