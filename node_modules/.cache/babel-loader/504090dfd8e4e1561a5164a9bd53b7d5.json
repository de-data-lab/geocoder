{"ast":null,"code":"import _asyncToGenerator from \"/Users/tbeckett/Documents/Azure dev/Azure Test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/tbeckett/Documents/Azure dev/Azure Test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/tbeckett/Documents/Azure dev/Azure Test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/Users/tbeckett/Documents/Azure dev/Azure Test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/Users/tbeckett/Documents/Azure dev/Azure Test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/tbeckett/Documents/Azure dev/Azure Test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _slicedToArray from \"/Users/tbeckett/Documents/Azure dev/Azure Test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectSpread from \"/Users/tbeckett/Documents/Azure dev/Azure Test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _toConsumableArray from \"/Users/tbeckett/Documents/Azure dev/Azure Test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nimport React__default, { createContext, useEffect, useMemo, useReducer, useContext, useState, useRef, useCallback } from 'react';\nimport { stubbedPublicClientApplication, InteractionStatus, Logger, WrapperSKU, EventMessageUtils, AccountEntity, AuthError, InteractionType, InteractionRequiredAuthError, EventType, OIDC_DEFAULT_SCOPES } from '@azure/msal-browser';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/*\r\n * Stubbed context implementation\r\n * Only used when there is no provider, which is an unsupported scenario\r\n */\n\nvar defaultMsalContext = {\n  instance: stubbedPublicClientApplication,\n  inProgress: InteractionStatus.None,\n  accounts: [],\n  logger: /*#__PURE__*/new Logger({})\n};\nvar MsalContext = /*#__PURE__*/createContext(defaultMsalContext);\nvar MsalConsumer = MsalContext.Consumer;\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nfunction getChildrenOrFunction(children, args) {\n  if (typeof children === \"function\") {\n    return children(args);\n  }\n  return children;\n}\n/**\r\n * Helper function to determine whether 2 arrays are equal\r\n * Used to avoid unnecessary state updates\r\n * @param arrayA\r\n * @param arrayB\r\n */\n\nfunction accountArraysAreEqual(arrayA, arrayB) {\n  if (arrayA.length !== arrayB.length) {\n    return false;\n  }\n  var comparisonArray = _toConsumableArray(arrayB);\n  return arrayA.every(function (elementA) {\n    var elementB = comparisonArray.shift();\n    if (!elementA || !elementB) {\n      return false;\n    }\n    return elementA.homeAccountId === elementB.homeAccountId && elementA.localAccountId === elementB.localAccountId && elementA.username === elementB.username;\n  });\n}\nfunction getAccountByIdentifiers(allAccounts, accountIdentifiers) {\n  if (allAccounts.length > 0 && (accountIdentifiers.homeAccountId || accountIdentifiers.localAccountId || accountIdentifiers.username)) {\n    var matchedAccounts = allAccounts.filter(function (accountObj) {\n      if (accountIdentifiers.username && accountIdentifiers.username.toLowerCase() !== accountObj.username.toLowerCase()) {\n        return false;\n      }\n      if (accountIdentifiers.homeAccountId && accountIdentifiers.homeAccountId.toLowerCase() !== accountObj.homeAccountId.toLowerCase()) {\n        return false;\n      }\n      if (accountIdentifiers.localAccountId && accountIdentifiers.localAccountId.toLowerCase() !== accountObj.localAccountId.toLowerCase()) {\n        return false;\n      }\n      return true;\n    });\n    return matchedAccounts[0] || null;\n  } else {\n    return null;\n  }\n}\n\n/* eslint-disable header/header */\nvar name = \"@azure/msal-react\";\nvar version = \"1.5.1\";\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nvar MsalProviderActionType;\n(function (MsalProviderActionType) {\n  MsalProviderActionType[\"UNBLOCK_INPROGRESS\"] = \"UNBLOCK_INPROGRESS\";\n  MsalProviderActionType[\"EVENT\"] = \"EVENT\";\n})(MsalProviderActionType || (MsalProviderActionType = {}));\n/**\r\n * Returns the next inProgress and accounts state based on event message\r\n * @param previousState\r\n * @param action\r\n */\n\nvar reducer = function reducer(previousState, action) {\n  var type = action.type,\n    payload = action.payload;\n  var newInProgress = previousState.inProgress;\n  switch (type) {\n    case MsalProviderActionType.UNBLOCK_INPROGRESS:\n      if (previousState.inProgress === InteractionStatus.Startup) {\n        newInProgress = InteractionStatus.None;\n        payload.logger.info(\"MsalProvider - handleRedirectPromise resolved, setting inProgress to 'none'\");\n      }\n      break;\n    case MsalProviderActionType.EVENT:\n      var message = payload.message;\n      var status = EventMessageUtils.getInteractionStatusFromEvent(message, previousState.inProgress);\n      if (status) {\n        payload.logger.info(\"MsalProvider - \".concat(message.eventType, \" results in setting inProgress from \").concat(previousState.inProgress, \" to \").concat(status));\n        newInProgress = status;\n      }\n      break;\n    default:\n      throw new Error(\"Unknown action type: \".concat(type));\n  }\n  var currentAccounts = payload.instance.getAllAccounts();\n  if (newInProgress !== previousState.inProgress && !accountArraysAreEqual(currentAccounts, previousState.accounts)) {\n    // Both inProgress and accounts changed\n    return _objectSpread(_objectSpread({}, previousState), {}, {\n      inProgress: newInProgress,\n      accounts: currentAccounts\n    });\n  } else if (newInProgress !== previousState.inProgress) {\n    // Only only inProgress changed\n    return _objectSpread(_objectSpread({}, previousState), {}, {\n      inProgress: newInProgress\n    });\n  } else if (!accountArraysAreEqual(currentAccounts, previousState.accounts)) {\n    // Only accounts changed\n    return _objectSpread(_objectSpread({}, previousState), {}, {\n      accounts: currentAccounts\n    });\n  } else {\n    // Nothing changed\n    return previousState;\n  }\n};\n/**\r\n * MSAL context provider component. This must be rendered above any other components that use MSAL.\r\n */\n\nfunction MsalProvider(_ref) {\n  var instance = _ref.instance,\n    children = _ref.children;\n  useEffect(function () {\n    instance.initializeWrapperLibrary(WrapperSKU.React, version);\n  }, [instance]); // Create a logger instance for msal-react with the same options as PublicClientApplication\n\n  var logger = useMemo(function () {\n    return instance.getLogger().clone(name, version);\n  }, [instance]);\n  var _useReducer = useReducer(reducer, undefined, function () {\n      // Lazy initialization of the initial state\n      return {\n        inProgress: InteractionStatus.Startup,\n        accounts: instance.getAllAccounts()\n      };\n    }),\n    _useReducer2 = _slicedToArray(_useReducer, 2),\n    state = _useReducer2[0],\n    updateState = _useReducer2[1];\n  useEffect(function () {\n    var callbackId = instance.addEventCallback(function (message) {\n      updateState({\n        payload: {\n          instance: instance,\n          logger: logger,\n          message: message\n        },\n        type: MsalProviderActionType.EVENT\n      });\n    });\n    logger.verbose(\"MsalProvider - Registered event callback with id: \".concat(callbackId));\n    instance.initialize().then(function () {\n      instance.handleRedirectPromise().catch(function () {\n        // Errors should be handled by listening to the LOGIN_FAILURE event\n        return;\n      }).finally(function () {\n        /*\r\n         * If handleRedirectPromise returns a cached promise the necessary events may not be fired\r\n         * This is a fallback to prevent inProgress from getting stuck in 'startup'\r\n         */\n        updateState({\n          payload: {\n            instance: instance,\n            logger: logger\n          },\n          type: MsalProviderActionType.UNBLOCK_INPROGRESS\n        });\n      });\n    });\n    return function () {\n      // Remove callback when component unmounts or accounts change\n      if (callbackId) {\n        logger.verbose(\"MsalProvider - Removing event callback \".concat(callbackId));\n        instance.removeEventCallback(callbackId);\n      }\n    };\n  }, [instance, logger]);\n  var contextValue = {\n    instance: instance,\n    inProgress: state.inProgress,\n    accounts: state.accounts,\n    logger: logger\n  };\n  return React__default.createElement(MsalContext.Provider, {\n    value: contextValue\n  }, children);\n}\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * Returns Msal Context values\r\n */\n\nvar useMsal = function useMsal() {\n  return useContext(MsalContext);\n};\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nfunction isAuthenticated(allAccounts, matchAccount) {\n  if (matchAccount && (matchAccount.username || matchAccount.homeAccountId || matchAccount.localAccountId)) {\n    return !!getAccountByIdentifiers(allAccounts, matchAccount);\n  }\n  return allAccounts.length > 0;\n}\n/**\r\n * Returns whether or not a user is currently signed-in. Optionally provide 1 or more accountIdentifiers to determine if a specific user is signed-in\r\n * @param matchAccount\r\n */\n\nfunction useIsAuthenticated(matchAccount) {\n  var _useMsal = useMsal(),\n    allAccounts = _useMsal.accounts,\n    inProgress = _useMsal.inProgress;\n  var _useState = useState(function () {\n      if (inProgress === InteractionStatus.Startup) {\n        return false;\n      }\n      return isAuthenticated(allAccounts, matchAccount);\n    }),\n    _useState2 = _slicedToArray(_useState, 2),\n    hasAuthenticated = _useState2[0],\n    setHasAuthenticated = _useState2[1];\n  useEffect(function () {\n    setHasAuthenticated(isAuthenticated(allAccounts, matchAccount));\n  }, [allAccounts, matchAccount]);\n  return hasAuthenticated;\n}\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * Renders child components if user is authenticated\r\n * @param props\r\n */\n\nfunction AuthenticatedTemplate(_ref) {\n  var username = _ref.username,\n    homeAccountId = _ref.homeAccountId,\n    localAccountId = _ref.localAccountId,\n    children = _ref.children;\n  var context = useMsal();\n  var accountIdentifier = useMemo(function () {\n    return {\n      username: username,\n      homeAccountId: homeAccountId,\n      localAccountId: localAccountId\n    };\n  }, [username, homeAccountId, localAccountId]);\n  var isAuthenticated = useIsAuthenticated(accountIdentifier);\n  if (isAuthenticated && context.inProgress !== InteractionStatus.Startup) {\n    return React__default.createElement(React__default.Fragment, null, getChildrenOrFunction(children, context));\n  }\n  return null;\n}\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * Renders child components if user is unauthenticated\r\n * @param props\r\n */\n\nfunction UnauthenticatedTemplate(_ref) {\n  var username = _ref.username,\n    homeAccountId = _ref.homeAccountId,\n    localAccountId = _ref.localAccountId,\n    children = _ref.children;\n  var context = useMsal();\n  var accountIdentifier = useMemo(function () {\n    return {\n      username: username,\n      homeAccountId: homeAccountId,\n      localAccountId: localAccountId\n    };\n  }, [username, homeAccountId, localAccountId]);\n  var isAuthenticated = useIsAuthenticated(accountIdentifier);\n  if (!isAuthenticated && context.inProgress !== InteractionStatus.Startup && context.inProgress !== InteractionStatus.HandleRedirect) {\n    return React__default.createElement(React__default.Fragment, null, getChildrenOrFunction(children, context));\n  }\n  return null;\n}\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nfunction getAccount(instance, accountIdentifiers) {\n  if (!accountIdentifiers || !accountIdentifiers.homeAccountId && !accountIdentifiers.localAccountId && !accountIdentifiers.username) {\n    // If no account identifiers are provided, return active account\n    return instance.getActiveAccount();\n  }\n  return getAccountByIdentifiers(instance.getAllAccounts(), accountIdentifiers);\n}\n/**\r\n * Given 1 or more accountIdentifiers, returns the Account object if the user is signed-in\r\n * @param accountIdentifiers\r\n */\n\nfunction useAccount(accountIdentifiers) {\n  var _useMsal2 = useMsal(),\n    instance = _useMsal2.instance,\n    inProgress = _useMsal2.inProgress,\n    logger = _useMsal2.logger;\n  var _useState3 = useState(function () {\n      return getAccount(instance, accountIdentifiers);\n    }),\n    _useState4 = _slicedToArray(_useState3, 2),\n    account = _useState4[0],\n    setAccount = _useState4[1];\n  useEffect(function () {\n    setAccount(function (currentAccount) {\n      var nextAccount = getAccount(instance, accountIdentifiers);\n      if (!AccountEntity.accountInfoIsEqual(currentAccount, nextAccount, true)) {\n        logger.info(\"useAccount - Updating account\");\n        return nextAccount;\n      }\n      return currentAccount;\n    });\n  }, [inProgress, accountIdentifiers, instance, logger]);\n  return account;\n}\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nvar ReactAuthErrorMessage = {\n  invalidInteractionType: {\n    code: \"invalid_interaction_type\",\n    desc: \"The provided interaction type is invalid.\"\n  },\n  unableToFallbackToInteraction: {\n    code: \"unable_to_fallback_to_interaction\",\n    desc: \"Interaction is required but another interaction is already in progress. Please try again when the current interaction is complete.\"\n  }\n};\nvar ReactAuthError = /*#__PURE__*/function (_AuthError) {\n  _inherits(ReactAuthError, _AuthError);\n  var _super = _createSuper(ReactAuthError);\n  function ReactAuthError(errorCode, errorMessage) {\n    var _this;\n    _classCallCheck(this, ReactAuthError);\n    _this = _super.call(this, errorCode, errorMessage);\n    Object.setPrototypeOf(_assertThisInitialized(_this), ReactAuthError.prototype);\n    _this.name = \"ReactAuthError\";\n    return _this;\n  }\n  _createClass(ReactAuthError, null, [{\n    key: \"createInvalidInteractionTypeError\",\n    value: function createInvalidInteractionTypeError() {\n      return new ReactAuthError(ReactAuthErrorMessage.invalidInteractionType.code, ReactAuthErrorMessage.invalidInteractionType.desc);\n    }\n  }, {\n    key: \"createUnableToFallbackToInteractionError\",\n    value: function createUnableToFallbackToInteractionError() {\n      return new ReactAuthError(ReactAuthErrorMessage.unableToFallbackToInteraction.code, ReactAuthErrorMessage.unableToFallbackToInteraction.desc);\n    }\n  }]);\n  return ReactAuthError;\n}(AuthError);\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * If a user is not currently signed in this hook invokes a login. Failed logins can be retried using the login callback returned.\r\n * If a user is currently signed in this hook attempts to acquire a token. Subsequent token requests can use the acquireToken callback returned.\r\n * Optionally provide a request object to be used in the login/acquireToken call.\r\n * Optionally provide a specific user that should be logged in.\r\n * @param interactionType\r\n * @param authenticationRequest\r\n * @param accountIdentifiers\r\n */\nfunction useMsalAuthentication(interactionType, authenticationRequest, accountIdentifiers) {\n  var _useMsal3 = useMsal(),\n    instance = _useMsal3.instance,\n    inProgress = _useMsal3.inProgress,\n    logger = _useMsal3.logger;\n  var isAuthenticated = useIsAuthenticated(accountIdentifiers);\n  var account = useAccount(accountIdentifiers);\n  var _useState5 = useState([null, null]),\n    _useState6 = _slicedToArray(_useState5, 2),\n    _useState6$ = _slicedToArray(_useState6[0], 2),\n    result = _useState6$[0],\n    error = _useState6$[1],\n    setResponse = _useState6[1]; // Used to prevent state updates after unmount\n\n  var mounted = useRef(true);\n  useEffect(function () {\n    return function () {\n      mounted.current = false;\n    };\n  }, []); // Boolean used to check if interaction is in progress in acquireTokenSilent fallback. Use Ref instead of state to prevent acquireToken function from being regenerated on each change to interactionInProgress value\n\n  var interactionInProgress = useRef(inProgress !== InteractionStatus.None);\n  useEffect(function () {\n    interactionInProgress.current = inProgress !== InteractionStatus.None;\n  }, [inProgress]); // Flag used to control when the hook calls login/acquireToken\n\n  var shouldAcquireToken = useRef(true);\n  useEffect(function () {\n    if (!!error) {\n      // Errors should be handled by consuming component\n      shouldAcquireToken.current = false;\n      return;\n    }\n    if (!!result) {\n      // Token has already been acquired, consuming component/application is responsible for renewing\n      shouldAcquireToken.current = false;\n      return;\n    }\n  }, [error, result]);\n  var login = useCallback( /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(callbackInteractionType, callbackRequest) {\n      var loginType, loginRequest;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              loginType = callbackInteractionType || interactionType;\n              loginRequest = callbackRequest || authenticationRequest;\n              _context.t0 = loginType;\n              _context.next = _context.t0 === InteractionType.Popup ? 5 : _context.t0 === InteractionType.Redirect ? 7 : _context.t0 === InteractionType.Silent ? 9 : 11;\n              break;\n            case 5:\n              logger.verbose(\"useMsalAuthentication - Calling loginPopup\");\n              return _context.abrupt(\"return\", instance.loginPopup(loginRequest));\n            case 7:\n              // This promise is not expected to resolve due to full frame redirect\n              logger.verbose(\"useMsalAuthentication - Calling loginRedirect\");\n              return _context.abrupt(\"return\", instance.loginRedirect(loginRequest).then(null));\n            case 9:\n              logger.verbose(\"useMsalAuthentication - Calling ssoSilent\");\n              return _context.abrupt(\"return\", instance.ssoSilent(loginRequest));\n            case 11:\n              throw ReactAuthError.createInvalidInteractionTypeError();\n            case 12:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n    return function (_x, _x2) {\n      return _ref2.apply(this, arguments);\n    };\n  }(), [instance, interactionType, authenticationRequest, logger]);\n  var acquireToken = useCallback( /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(callbackInteractionType, callbackRequest) {\n      var fallbackInteractionType, tokenRequest, getToken;\n      return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              fallbackInteractionType = callbackInteractionType || interactionType;\n              if (callbackRequest) {\n                logger.trace(\"useMsalAuthentication - acquireToken - Using request provided in the callback\");\n                tokenRequest = _objectSpread({}, callbackRequest);\n              } else if (authenticationRequest) {\n                logger.trace(\"useMsalAuthentication - acquireToken - Using request provided in the hook\");\n                tokenRequest = _objectSpread(_objectSpread({}, authenticationRequest), {}, {\n                  scopes: authenticationRequest.scopes || OIDC_DEFAULT_SCOPES\n                });\n              } else {\n                logger.trace(\"useMsalAuthentication - acquireToken - No request object provided, using default request.\");\n                tokenRequest = {\n                  scopes: OIDC_DEFAULT_SCOPES\n                };\n              }\n              if (!tokenRequest.account && account) {\n                logger.trace(\"useMsalAuthentication - acquireToken - Attaching account to request\");\n                tokenRequest.account = account;\n              }\n              getToken = /*#__PURE__*/function () {\n                var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n                  return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                    while (1) {\n                      switch (_context3.prev = _context3.next) {\n                        case 0:\n                          logger.verbose(\"useMsalAuthentication - Calling acquireTokenSilent\");\n                          return _context3.abrupt(\"return\", instance.acquireTokenSilent(tokenRequest).catch( /*#__PURE__*/function () {\n                            var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(e) {\n                              return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                                while (1) {\n                                  switch (_context2.prev = _context2.next) {\n                                    case 0:\n                                      if (!(e instanceof InteractionRequiredAuthError)) {\n                                        _context2.next = 8;\n                                        break;\n                                      }\n                                      if (interactionInProgress.current) {\n                                        _context2.next = 6;\n                                        break;\n                                      }\n                                      logger.error(\"useMsalAuthentication - Interaction required, falling back to interaction\");\n                                      return _context2.abrupt(\"return\", login(fallbackInteractionType, tokenRequest));\n                                    case 6:\n                                      logger.error(\"useMsalAuthentication - Interaction required but is already in progress. Please try again, if needed, after interaction completes.\");\n                                      throw ReactAuthError.createUnableToFallbackToInteractionError();\n                                    case 8:\n                                      throw e;\n                                    case 9:\n                                    case \"end\":\n                                      return _context2.stop();\n                                  }\n                                }\n                              }, _callee2);\n                            }));\n                            return function (_x5) {\n                              return _ref5.apply(this, arguments);\n                            };\n                          }()));\n                        case 2:\n                        case \"end\":\n                          return _context3.stop();\n                      }\n                    }\n                  }, _callee3);\n                }));\n                return function getToken() {\n                  return _ref4.apply(this, arguments);\n                };\n              }();\n              return _context4.abrupt(\"return\", getToken().then(function (response) {\n                if (mounted.current) {\n                  setResponse([response, null]);\n                }\n                return response;\n              }).catch(function (e) {\n                if (mounted.current) {\n                  setResponse([null, e]);\n                }\n                throw e;\n              }));\n            case 5:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }));\n    return function (_x3, _x4) {\n      return _ref3.apply(this, arguments);\n    };\n  }(), [instance, interactionType, authenticationRequest, logger, account, login]);\n  useEffect(function () {\n    var callbackId = instance.addEventCallback(function (message) {\n      switch (message.eventType) {\n        case EventType.LOGIN_SUCCESS:\n        case EventType.SSO_SILENT_SUCCESS:\n          if (message.payload) {\n            setResponse([message.payload, null]);\n          }\n          break;\n        case EventType.LOGIN_FAILURE:\n        case EventType.SSO_SILENT_FAILURE:\n          if (message.error) {\n            setResponse([null, message.error]);\n          }\n          break;\n      }\n    });\n    logger.verbose(\"useMsalAuthentication - Registered event callback with id: \".concat(callbackId));\n    return function () {\n      if (callbackId) {\n        logger.verbose(\"useMsalAuthentication - Removing event callback \".concat(callbackId));\n        instance.removeEventCallback(callbackId);\n      }\n    };\n  }, [instance, logger]);\n  useEffect(function () {\n    if (shouldAcquireToken.current && inProgress === InteractionStatus.None) {\n      shouldAcquireToken.current = false;\n      if (!isAuthenticated) {\n        logger.info(\"useMsalAuthentication - No user is authenticated, attempting to login\");\n        login().catch(function () {\n          // Errors are saved in state above\n          return;\n        });\n      } else if (account) {\n        logger.info(\"useMsalAuthentication - User is authenticated, attempting to acquire token\");\n        acquireToken().catch(function () {\n          // Errors are saved in state above\n          return;\n        });\n      }\n    }\n  }, [isAuthenticated, account, inProgress, login, acquireToken, logger]);\n  return {\n    login: login,\n    acquireToken: acquireToken,\n    result: result,\n    error: error\n  };\n}\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * Attempts to authenticate user if not already authenticated, then renders child components\r\n * @param props\r\n */\n\nfunction MsalAuthenticationTemplate(_ref) {\n  var interactionType = _ref.interactionType,\n    username = _ref.username,\n    homeAccountId = _ref.homeAccountId,\n    localAccountId = _ref.localAccountId,\n    authenticationRequest = _ref.authenticationRequest,\n    LoadingComponent = _ref.loadingComponent,\n    ErrorComponent = _ref.errorComponent,\n    children = _ref.children;\n  var accountIdentifier = useMemo(function () {\n    return {\n      username: username,\n      homeAccountId: homeAccountId,\n      localAccountId: localAccountId\n    };\n  }, [username, homeAccountId, localAccountId]);\n  var context = useMsal();\n  var msalAuthResult = useMsalAuthentication(interactionType, authenticationRequest, accountIdentifier);\n  var isAuthenticated = useIsAuthenticated(accountIdentifier);\n  if (msalAuthResult.error && context.inProgress === InteractionStatus.None) {\n    if (!!ErrorComponent) {\n      return React__default.createElement(ErrorComponent, Object.assign({}, msalAuthResult));\n    }\n    throw msalAuthResult.error;\n  }\n  if (isAuthenticated) {\n    return React__default.createElement(React__default.Fragment, null, getChildrenOrFunction(children, msalAuthResult));\n  }\n  if (!!LoadingComponent && context.inProgress !== InteractionStatus.None) {\n    return React__default.createElement(LoadingComponent, Object.assign({}, context));\n  }\n  return null;\n}\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * Higher order component wraps provided component with msal by injecting msal context values into the component's props\r\n * @param Component\r\n */\n\nvar withMsal = function withMsal(Component) {\n  var ComponentWithMsal = function ComponentWithMsal(props) {\n    var msal = useMsal();\n    return React__default.createElement(Component, Object.assign({}, props, {\n      msalContext: msal\n    }));\n  };\n  var componentName = Component.displayName || Component.name || \"Component\";\n  ComponentWithMsal.displayName = \"withMsal(\".concat(componentName, \")\");\n  return ComponentWithMsal;\n};\nexport { AuthenticatedTemplate, MsalAuthenticationTemplate, MsalConsumer, MsalContext, MsalProvider, UnauthenticatedTemplate, useAccount, useIsAuthenticated, useMsal, useMsalAuthentication, version, withMsal };","map":{"version":3,"mappings":"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","names":["defaultMsalContext","instance","stubbedPublicClientApplication","inProgress","InteractionStatus","None","accounts","logger","Logger","MsalContext","React","MsalConsumer","Consumer","getChildrenOrFunction","children","args","accountArraysAreEqual","arrayA","arrayB","length","comparisonArray","every","elementA","elementB","shift","homeAccountId","localAccountId","username","getAccountByIdentifiers","allAccounts","accountIdentifiers","matchedAccounts","filter","accountObj","toLowerCase","name","version","MsalProviderActionType","reducer","previousState","action","type","payload","newInProgress","UNBLOCK_INPROGRESS","Startup","info","EVENT","message","status","EventMessageUtils","getInteractionStatusFromEvent","eventType","Error","currentAccounts","getAllAccounts","MsalProvider","_ref","useEffect","initializeWrapperLibrary","WrapperSKU","useMemo","getLogger","clone","SKU","useReducer","undefined","state","updateState","callbackId","addEventCallback","verbose","initialize","then","handleRedirectPromise","catch","finally","removeEventCallback","contextValue","Provider","value","useMsal","useContext","isAuthenticated","matchAccount","useIsAuthenticated","useState","hasAuthenticated","setHasAuthenticated","AuthenticatedTemplate","context","accountIdentifier","Fragment","UnauthenticatedTemplate","HandleRedirect","getAccount","getActiveAccount","useAccount","account","setAccount","currentAccount","nextAccount","AccountEntity","accountInfoIsEqual","ReactAuthErrorMessage","invalidInteractionType","code","desc","unableToFallbackToInteraction","ReactAuthError","constructor","errorCode","errorMessage","Object","setPrototypeOf","prototype","AuthError","useMsalAuthentication","interactionType","authenticationRequest","result","error","setResponse","mounted","useRef","current","interactionInProgress","shouldAcquireToken","login","useCallback","callbackInteractionType","callbackRequest","loginType","loginRequest","InteractionType","Popup","Redirect","Silent","loginPopup","loginRedirect","ssoSilent","createInvalidInteractionTypeError","acquireToken","fallbackInteractionType","trace","tokenRequest","scopes","OIDC_DEFAULT_SCOPES","getToken","acquireTokenSilent","e","InteractionRequiredAuthError","createUnableToFallbackToInteractionError","response","EventType","LOGIN_SUCCESS","SSO_SILENT_SUCCESS","LOGIN_FAILURE","SSO_SILENT_FAILURE","MsalAuthenticationTemplate","LoadingComponent","loadingComponent","ErrorComponent","errorComponent","msalAuthResult","withMsal","Component","ComponentWithMsal","props","msal","msalContext","componentName","displayName"],"sources":["../src/MsalContext.ts","../src/utils/utilities.ts","../src/packageMetadata.ts","../src/MsalProvider.tsx","../src/hooks/useMsal.ts","../src/hooks/useIsAuthenticated.ts","../src/components/AuthenticatedTemplate.tsx","../src/components/UnauthenticatedTemplate.tsx","../src/hooks/useAccount.ts","../src/error/ReactAuthError.ts","../src/hooks/useMsalAuthentication.ts","../src/components/MsalAuthenticationTemplate.tsx","../src/components/withMsal.tsx"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport * as React from \"react\";\nimport { IPublicClientApplication, stubbedPublicClientApplication, Logger, InteractionStatus, AccountInfo } from \"@azure/msal-browser\";\n\nexport interface IMsalContext {\n    instance: IPublicClientApplication;\n    inProgress: InteractionStatus;\n    accounts: AccountInfo[];\n    logger: Logger;\n}\n\n/*\n * Stubbed context implementation\n * Only used when there is no provider, which is an unsupported scenario\n */\nconst defaultMsalContext: IMsalContext = {\n    instance: stubbedPublicClientApplication,\n    inProgress: InteractionStatus.None,\n    accounts: [],\n    logger: new Logger({})\n};\n\nexport const MsalContext = React.createContext<IMsalContext>(\n    defaultMsalContext\n);\nexport const MsalConsumer = MsalContext.Consumer;\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { AccountIdentifiers } from \"../types/AccountIdentifiers\";\nimport { AccountInfo } from \"@azure/msal-browser\";\n\ntype FaaCFunction = <T>(args: T) => React.ReactNode;\n\nexport function getChildrenOrFunction<T>(\n    children: React.ReactNode | FaaCFunction,\n    args: T\n): React.ReactNode {\n    if (typeof children === \"function\") {\n        return children(args);\n    }\n    return children;\n}\n\n/*\n * Utility types\n * Reference: https://github.com/piotrwitek/utility-types\n */\ntype SetDifference<A, B> = A extends B ? never : A;\ntype SetComplement<A, A1 extends A> = SetDifference<A, A1>;\nexport type Subtract<T extends T1, T1 extends object> = Pick<T,SetComplement<keyof T, keyof T1>>;\n\n/**\n * Helper function to determine whether 2 arrays are equal\n * Used to avoid unnecessary state updates\n * @param arrayA \n * @param arrayB \n */\nexport function accountArraysAreEqual(arrayA: Array<AccountIdentifiers>, arrayB: Array<AccountIdentifiers>): boolean {\n    if (arrayA.length !== arrayB.length) {\n        return false;\n    }\n\n    const comparisonArray = [...arrayB];\n\n    return arrayA.every((elementA) => {\n        const elementB = comparisonArray.shift();\n        if (!elementA || !elementB) {\n            return false;\n        }\n\n        return (elementA.homeAccountId === elementB.homeAccountId) && \n               (elementA.localAccountId === elementB.localAccountId) &&\n               (elementA.username === elementB.username);\n    });\n}\n\nexport function getAccountByIdentifiers(allAccounts: AccountInfo[], accountIdentifiers: AccountIdentifiers): AccountInfo | null {\n    if (allAccounts.length > 0 && (accountIdentifiers.homeAccountId || accountIdentifiers.localAccountId || accountIdentifiers.username)) {\n        const matchedAccounts = allAccounts.filter(accountObj => {\n            if (accountIdentifiers.username && accountIdentifiers.username.toLowerCase() !== accountObj.username.toLowerCase()) {\n                return false;\n            }\n            if (accountIdentifiers.homeAccountId && accountIdentifiers.homeAccountId.toLowerCase() !== accountObj.homeAccountId.toLowerCase()) {\n                return false;\n            }\n            if (accountIdentifiers.localAccountId && accountIdentifiers.localAccountId.toLowerCase() !== accountObj.localAccountId.toLowerCase()) {\n                return false;\n            }\n\n            return true;\n        });\n\n        return matchedAccounts[0] || null;\n    } else {\n        return null;\n    }\n}\n","/* eslint-disable header/header */\nexport const name = \"@azure/msal-react\";\nexport const version = \"1.5.1\";\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport React, { useEffect, useReducer, PropsWithChildren, useMemo} from \"react\";\nimport {\n    IPublicClientApplication,\n    EventMessage,\n    EventMessageUtils,\n    InteractionStatus,\n    Logger,\n    WrapperSKU,\n    AccountInfo\n} from \"@azure/msal-browser\";\nimport { MsalContext, IMsalContext } from \"./MsalContext\";\nimport { accountArraysAreEqual } from \"./utils/utilities\";\nimport { name as SKU, version } from \"./packageMetadata\";\n\nexport type MsalProviderProps = PropsWithChildren<{\n    instance: IPublicClientApplication;\n}>;\n\ntype MsalState = {\n    inProgress: InteractionStatus;\n    accounts: AccountInfo[];\n};\n\nenum MsalProviderActionType {\n    UNBLOCK_INPROGRESS = \"UNBLOCK_INPROGRESS\",\n    EVENT = \"EVENT\"\n}\n\ntype MsalProviderReducerAction = {\n    type: MsalProviderActionType,\n    payload: {\n        logger: Logger;\n        instance: IPublicClientApplication;\n        message?: EventMessage;\n    };\n};\n\n/**\n * Returns the next inProgress and accounts state based on event message\n * @param previousState \n * @param action \n */\nconst reducer = (previousState: MsalState, action: MsalProviderReducerAction): MsalState => {\n    const { type, payload } = action;\n    let newInProgress = previousState.inProgress;\n\n    switch (type) {\n        case MsalProviderActionType.UNBLOCK_INPROGRESS:\n            if (previousState.inProgress === InteractionStatus.Startup){\n                newInProgress = InteractionStatus.None;\n                payload.logger.info(\"MsalProvider - handleRedirectPromise resolved, setting inProgress to 'none'\");\n            }\n            break;\n        case MsalProviderActionType.EVENT:\n            const message = payload.message as EventMessage;\n            const status = EventMessageUtils.getInteractionStatusFromEvent(message, previousState.inProgress);\n            if (status) {\n                payload.logger.info(`MsalProvider - ${message.eventType} results in setting inProgress from ${previousState.inProgress} to ${status}`);\n                newInProgress = status;\n            }\n            break;\n        default:\n            throw new Error(`Unknown action type: ${type}`);\n    }\n    \n    const currentAccounts = payload.instance.getAllAccounts();\n    if (newInProgress !== previousState.inProgress && \n        !accountArraysAreEqual(currentAccounts, previousState.accounts)) {\n        // Both inProgress and accounts changed\n        return {\n            ...previousState,\n            inProgress: newInProgress,\n            accounts: currentAccounts\n        };\n    } else if (newInProgress !== previousState.inProgress) {\n        // Only only inProgress changed\n        return {\n            ...previousState,\n            inProgress: newInProgress\n        };\n    } else if (!accountArraysAreEqual(currentAccounts, previousState.accounts)) {\n        // Only accounts changed\n        return {\n            ...previousState,\n            accounts: currentAccounts\n        };\n    } else {\n        // Nothing changed\n        return previousState;\n    }\n};\n\n/**\n * MSAL context provider component. This must be rendered above any other components that use MSAL.\n */\nexport function MsalProvider({instance, children}: MsalProviderProps): React.ReactElement {\n    useEffect(() => {\n        instance.initializeWrapperLibrary(WrapperSKU.React, version);\n    }, [instance]);\n    // Create a logger instance for msal-react with the same options as PublicClientApplication\n    const logger = useMemo(() => {\n        return instance.getLogger().clone(SKU, version);\n    }, [instance]);\n\n    const [state, updateState] = useReducer(reducer, undefined, () => {\n        // Lazy initialization of the initial state\n        return {\n            inProgress: InteractionStatus.Startup,\n            accounts: instance.getAllAccounts()\n        };\n    });\n    \n    useEffect(() => {\n        const callbackId = instance.addEventCallback((message: EventMessage) => {\n            updateState({\n                payload: {\n                    instance,\n                    logger,\n                    message\n                }, \n                type: MsalProviderActionType.EVENT\n            });\n        });\n        logger.verbose(`MsalProvider - Registered event callback with id: ${callbackId}`);\n\n        instance.initialize().then(() => {\n            instance.handleRedirectPromise().catch(() => {\n                // Errors should be handled by listening to the LOGIN_FAILURE event\n                return;\n            }).finally(() => {\n                /*\n                 * If handleRedirectPromise returns a cached promise the necessary events may not be fired\n                 * This is a fallback to prevent inProgress from getting stuck in 'startup'\n                 */\n                updateState({\n                    payload: {\n                        instance,\n                        logger\n                    },\n                    type: MsalProviderActionType.UNBLOCK_INPROGRESS \n                });\n            });\n        });\n\n        return () => {\n            // Remove callback when component unmounts or accounts change\n            if (callbackId) {\n                logger.verbose(`MsalProvider - Removing event callback ${callbackId}`);\n                instance.removeEventCallback(callbackId);\n            }\n        };\n    }, [instance, logger]);\n\n    const contextValue: IMsalContext = {\n        instance,\n        inProgress: state.inProgress,\n        accounts: state.accounts,\n        logger\n    };\n\n    return (\n        <MsalContext.Provider value={contextValue}>\n            {children}\n        </MsalContext.Provider>\n    );\n}\n\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { useContext } from \"react\";\nimport { IMsalContext, MsalContext } from \"../MsalContext\";\n\n/**\n * Returns Msal Context values\n */\nexport const useMsal = (): IMsalContext => useContext(MsalContext);\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { useState, useEffect } from \"react\";\nimport { useMsal } from \"./useMsal\";\nimport { AccountIdentifiers } from \"../types/AccountIdentifiers\";\nimport { AccountInfo, InteractionStatus } from \"@azure/msal-browser\";\nimport { getAccountByIdentifiers } from \"../utils/utilities\";\n\nfunction isAuthenticated(allAccounts: AccountInfo[], matchAccount?: AccountIdentifiers): boolean {\n    if(matchAccount && (matchAccount.username || matchAccount.homeAccountId || matchAccount.localAccountId)) {\n        return !!getAccountByIdentifiers(allAccounts, matchAccount);\n    }   \n\n    return allAccounts.length > 0;\n}\n\n/**\n * Returns whether or not a user is currently signed-in. Optionally provide 1 or more accountIdentifiers to determine if a specific user is signed-in\n * @param matchAccount \n */\nexport function useIsAuthenticated(matchAccount?: AccountIdentifiers): boolean {\n    const { accounts: allAccounts, inProgress } = useMsal();\n\n    const [hasAuthenticated, setHasAuthenticated] = useState<boolean>(() => {\n        if (inProgress === InteractionStatus.Startup) {\n            return false;\n        }\n        return isAuthenticated(allAccounts, matchAccount);\n    });\n\n    useEffect(() => {\n        setHasAuthenticated(isAuthenticated(allAccounts, matchAccount));\n    }, [allAccounts, matchAccount]);\n\n    return hasAuthenticated;\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport React, { PropsWithChildren, useMemo } from \"react\";\nimport { AccountIdentifiers } from \"../types/AccountIdentifiers\";\nimport { getChildrenOrFunction } from \"../utils/utilities\";\nimport { useMsal } from \"../hooks/useMsal\";\nimport { useIsAuthenticated } from \"../hooks/useIsAuthenticated\";\nimport { InteractionStatus } from \"@azure/msal-browser\";\n\nexport type AuthenticatedTemplateProps = PropsWithChildren<AccountIdentifiers>;\n\n/**\n * Renders child components if user is authenticated\n * @param props \n */\nexport function AuthenticatedTemplate({ username, homeAccountId, localAccountId, children }: AuthenticatedTemplateProps): React.ReactElement|null {\n    const context = useMsal();\n    const accountIdentifier: AccountIdentifiers = useMemo(() => {\n        return {\n            username,\n            homeAccountId,\n            localAccountId\n        };\n    }, [username, homeAccountId, localAccountId]);\n    const isAuthenticated = useIsAuthenticated(accountIdentifier);\n\n    if (isAuthenticated && context.inProgress !== InteractionStatus.Startup) {\n        return (\n            <React.Fragment>\n                {getChildrenOrFunction(children, context)}\n            </React.Fragment>\n        );\n    }\n    return null;\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport React, { PropsWithChildren, useMemo } from \"react\";\nimport { useMsal } from \"../hooks/useMsal\";\nimport { useIsAuthenticated } from \"../hooks/useIsAuthenticated\";\nimport { getChildrenOrFunction } from \"../utils/utilities\";\nimport { AccountIdentifiers } from \"../types/AccountIdentifiers\";\nimport { InteractionStatus } from \"@azure/msal-browser\";\n\nexport type UnauthenticatedTemplateProps = PropsWithChildren<AccountIdentifiers>;\n\n/**\n * Renders child components if user is unauthenticated\n * @param props \n */\nexport function UnauthenticatedTemplate({ username, homeAccountId, localAccountId, children }: UnauthenticatedTemplateProps): React.ReactElement|null {\n    const context = useMsal();\n    const accountIdentifier: AccountIdentifiers = useMemo(() => {\n        return {\n            username,\n            homeAccountId,\n            localAccountId\n        };\n    }, [username, homeAccountId, localAccountId]);\n    const isAuthenticated = useIsAuthenticated(accountIdentifier);\n\n    if (!isAuthenticated && context.inProgress !== InteractionStatus.Startup && context.inProgress !== InteractionStatus.HandleRedirect) {\n        return (\n            <React.Fragment>\n                {getChildrenOrFunction(children, context)}\n            </React.Fragment>\n        );\n    }\n    return null;\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { useState, useEffect } from \"react\";\nimport { AccountInfo, IPublicClientApplication, AccountEntity } from \"@azure/msal-browser\";\nimport { useMsal } from \"./useMsal\";\nimport { AccountIdentifiers } from \"../types/AccountIdentifiers\";\nimport { getAccountByIdentifiers } from \"../utils/utilities\";\n\nfunction getAccount(instance: IPublicClientApplication, accountIdentifiers?: AccountIdentifiers): AccountInfo | null {\n    if (!accountIdentifiers || (!accountIdentifiers.homeAccountId && !accountIdentifiers.localAccountId && !accountIdentifiers.username)) {\n        // If no account identifiers are provided, return active account\n        return instance.getActiveAccount();\n    }\n\n    return getAccountByIdentifiers(instance.getAllAccounts(), accountIdentifiers);\n}\n\n/**\n * Given 1 or more accountIdentifiers, returns the Account object if the user is signed-in\n * @param accountIdentifiers \n */\nexport function useAccount(accountIdentifiers?: AccountIdentifiers): AccountInfo | null {\n    const { instance, inProgress, logger } = useMsal();\n\n    const [account, setAccount] = useState<AccountInfo|null>(() => getAccount(instance, accountIdentifiers));\n\n    useEffect(() => {\n        setAccount((currentAccount: AccountInfo | null) => {\n            const nextAccount = getAccount(instance, accountIdentifiers);\n            if (!AccountEntity.accountInfoIsEqual(currentAccount, nextAccount, true)) {\n                logger.info(\"useAccount - Updating account\");\n                return nextAccount;\n            }\n\n            return currentAccount;\n        });\n    }, [inProgress, accountIdentifiers, instance, logger]);\n\n    return account;\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { AuthError } from \"@azure/msal-browser\";\n\nexport const ReactAuthErrorMessage = {\n    invalidInteractionType: {\n        code: \"invalid_interaction_type\",\n        desc: \"The provided interaction type is invalid.\"\n    },\n    unableToFallbackToInteraction: {\n        code: \"unable_to_fallback_to_interaction\",\n        desc: \"Interaction is required but another interaction is already in progress. Please try again when the current interaction is complete.\"\n    }\n};\n\nexport class ReactAuthError extends AuthError {\n    constructor(errorCode: string, errorMessage?: string) {\n        super(errorCode, errorMessage);\n\n        Object.setPrototypeOf(this, ReactAuthError.prototype);\n        this.name = \"ReactAuthError\";\n    }\n\n    static createInvalidInteractionTypeError(): ReactAuthError {\n        return new ReactAuthError(ReactAuthErrorMessage.invalidInteractionType.code, ReactAuthErrorMessage.invalidInteractionType.desc);\n    }\n\n    static createUnableToFallbackToInteractionError(): ReactAuthError {\n        return new ReactAuthError(ReactAuthErrorMessage.unableToFallbackToInteraction.code, ReactAuthErrorMessage.unableToFallbackToInteraction.desc);\n    }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { useCallback, useEffect, useState, useRef } from \"react\";\nimport { PopupRequest, RedirectRequest, SsoSilentRequest, InteractionType, AuthenticationResult, AuthError, EventMessage, EventType, InteractionStatus, SilentRequest, InteractionRequiredAuthError, OIDC_DEFAULT_SCOPES } from \"@azure/msal-browser\";\nimport { useIsAuthenticated } from \"./useIsAuthenticated\";\nimport { AccountIdentifiers } from \"../types/AccountIdentifiers\";\nimport { useMsal } from \"./useMsal\";\nimport { useAccount } from \"./useAccount\";\nimport { ReactAuthError } from \"../error/ReactAuthError\";\n\nexport type MsalAuthenticationResult = {\n    login: (callbackInteractionType?: InteractionType | undefined, callbackRequest?: PopupRequest | RedirectRequest | SilentRequest) => Promise<AuthenticationResult | null>; \n    acquireToken: (callbackInteractionType?: InteractionType | undefined, callbackRequest?: SilentRequest | undefined) => Promise<AuthenticationResult | null>;\n    result: AuthenticationResult|null;\n    error: AuthError|null;\n};\n\n/**\n * If a user is not currently signed in this hook invokes a login. Failed logins can be retried using the login callback returned.\n * If a user is currently signed in this hook attempts to acquire a token. Subsequent token requests can use the acquireToken callback returned.\n * Optionally provide a request object to be used in the login/acquireToken call.\n * Optionally provide a specific user that should be logged in.\n * @param interactionType \n * @param authenticationRequest \n * @param accountIdentifiers \n */\nexport function useMsalAuthentication(\n    interactionType: InteractionType, \n    authenticationRequest?: PopupRequest|RedirectRequest|SsoSilentRequest, \n    accountIdentifiers?: AccountIdentifiers\n): MsalAuthenticationResult {\n    const { instance, inProgress, logger } = useMsal();\n    const isAuthenticated = useIsAuthenticated(accountIdentifiers);\n    const account = useAccount(accountIdentifiers);\n    const [[result, error], setResponse] = useState<[AuthenticationResult|null, AuthError|null]>([null, null]);\n\n    // Used to prevent state updates after unmount\n    const mounted = useRef(true);\n    useEffect(() => {\n        return () => {\n            mounted.current = false;\n        };\n    },[]);\n\n    // Boolean used to check if interaction is in progress in acquireTokenSilent fallback. Use Ref instead of state to prevent acquireToken function from being regenerated on each change to interactionInProgress value\n    const interactionInProgress = useRef(inProgress !== InteractionStatus.None);\n    useEffect(() => {\n        interactionInProgress.current = inProgress !== InteractionStatus.None;\n    }, [inProgress]);\n\n    // Flag used to control when the hook calls login/acquireToken\n    const shouldAcquireToken = useRef(true);\n    useEffect(() => {\n        if (!!error) {\n            // Errors should be handled by consuming component\n            shouldAcquireToken.current = false;\n            return;\n        }\n\n        if (!!result) {\n            // Token has already been acquired, consuming component/application is responsible for renewing\n            shouldAcquireToken.current = false;\n            return;\n        }\n    }, [error, result]);\n\n    const login = useCallback(async (callbackInteractionType?: InteractionType, callbackRequest?: PopupRequest|RedirectRequest|SsoSilentRequest): Promise<AuthenticationResult|null> => {\n        const loginType = callbackInteractionType || interactionType;\n        const loginRequest = callbackRequest || authenticationRequest;\n        switch (loginType) {\n            case InteractionType.Popup:\n                logger.verbose(\"useMsalAuthentication - Calling loginPopup\");\n                return instance.loginPopup(loginRequest as PopupRequest);\n            case InteractionType.Redirect:\n                // This promise is not expected to resolve due to full frame redirect\n                logger.verbose(\"useMsalAuthentication - Calling loginRedirect\");\n                return instance.loginRedirect(loginRequest as RedirectRequest).then(null);\n            case InteractionType.Silent:\n                logger.verbose(\"useMsalAuthentication - Calling ssoSilent\");\n                return instance.ssoSilent(loginRequest as SsoSilentRequest);\n            default:\n                throw ReactAuthError.createInvalidInteractionTypeError();\n        }\n    }, [instance, interactionType, authenticationRequest, logger]);\n\n    const acquireToken = useCallback(async (callbackInteractionType?: InteractionType, callbackRequest?: SilentRequest): Promise<AuthenticationResult|null> => {\n        const fallbackInteractionType = callbackInteractionType || interactionType;\n\n        let tokenRequest: SilentRequest;\n\n        if (callbackRequest) {\n            logger.trace(\"useMsalAuthentication - acquireToken - Using request provided in the callback\");\n            tokenRequest = {\n                ...callbackRequest\n            };\n        } else if (authenticationRequest) {\n            logger.trace(\"useMsalAuthentication - acquireToken - Using request provided in the hook\");\n            tokenRequest = {\n                ...authenticationRequest,\n                scopes: authenticationRequest.scopes || OIDC_DEFAULT_SCOPES\n            };\n        } else {\n            logger.trace(\"useMsalAuthentication - acquireToken - No request object provided, using default request.\");\n            tokenRequest = {\n                scopes: OIDC_DEFAULT_SCOPES\n            };\n        }\n        \n        if (!tokenRequest.account && account) {\n            logger.trace(\"useMsalAuthentication - acquireToken - Attaching account to request\");\n            tokenRequest.account = account;\n        }\n\n        const getToken = async (): Promise<AuthenticationResult|null> => {\n            logger.verbose(\"useMsalAuthentication - Calling acquireTokenSilent\");\n            return instance.acquireTokenSilent(tokenRequest).catch(async (e: AuthError) => {\n                if (e instanceof InteractionRequiredAuthError) {\n                    if (!interactionInProgress.current) {\n                        logger.error(\"useMsalAuthentication - Interaction required, falling back to interaction\");\n                        return login(fallbackInteractionType, tokenRequest);\n                    } else {\n                        logger.error(\"useMsalAuthentication - Interaction required but is already in progress. Please try again, if needed, after interaction completes.\");\n                        throw ReactAuthError.createUnableToFallbackToInteractionError();\n                    }\n                }\n\n                throw e;\n            });\n        };\n\n        return getToken().then((response: AuthenticationResult|null) => {\n            if (mounted.current) {\n                setResponse([response, null]);\n            }\n            return response;\n        }).catch((e: AuthError) => {\n            if (mounted.current) {\n                setResponse([null, e]);\n            }\n            throw e;\n        });\n    }, [instance, interactionType, authenticationRequest, logger, account, login]);\n\n    useEffect(() => {\n        const callbackId = instance.addEventCallback((message: EventMessage) => {\n            switch(message.eventType) {\n                case EventType.LOGIN_SUCCESS:\n                case EventType.SSO_SILENT_SUCCESS:\n                    if (message.payload) {\n                        setResponse([message.payload as AuthenticationResult, null]);\n                    }\n                    break;\n                case EventType.LOGIN_FAILURE:\n                case EventType.SSO_SILENT_FAILURE:\n                    if (message.error) {\n                        setResponse([null, message.error as AuthError]);\n                    }\n                    break;\n            }\n        });\n        logger.verbose(`useMsalAuthentication - Registered event callback with id: ${callbackId}`);\n\n        return () => {\n            if (callbackId) {\n                logger.verbose(`useMsalAuthentication - Removing event callback ${callbackId}`);\n                instance.removeEventCallback(callbackId);\n            }\n        };\n    }, [instance, logger]);\n\n    useEffect(() => {\n        if (shouldAcquireToken.current && inProgress === InteractionStatus.None) {\n            shouldAcquireToken.current = false;\n            if (!isAuthenticated) {\n                logger.info(\"useMsalAuthentication - No user is authenticated, attempting to login\");\n                login().catch(() => {\n                    // Errors are saved in state above\n                    return;\n                });\n            } else if (account) {\n                logger.info(\"useMsalAuthentication - User is authenticated, attempting to acquire token\");\n                acquireToken().catch(() => {\n                    // Errors are saved in state above\n                    return;\n                });\n            }\n        }\n    }, [isAuthenticated, account, inProgress, login, acquireToken, logger]);\n\n    return { \n        login, \n        acquireToken, \n        result, \n        error\n    };\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport React, { PropsWithChildren, useMemo } from \"react\";\nimport { AccountIdentifiers } from \"../types/AccountIdentifiers\";\nimport { getChildrenOrFunction } from \"../utils/utilities\";\nimport { useMsal } from \"../hooks/useMsal\";\nimport { MsalAuthenticationResult, useMsalAuthentication } from \"../hooks/useMsalAuthentication\";\nimport { useIsAuthenticated } from \"../hooks/useIsAuthenticated\";\nimport { InteractionType, PopupRequest, RedirectRequest, SsoSilentRequest, InteractionStatus } from \"@azure/msal-browser\";\nimport { IMsalContext } from \"../MsalContext\";\n\nexport type MsalAuthenticationProps = PropsWithChildren<AccountIdentifiers & {\n    interactionType: InteractionType;\n    authenticationRequest?: PopupRequest|RedirectRequest|SsoSilentRequest;\n    loadingComponent?: React.ElementType<IMsalContext>;\n    errorComponent?: React.ElementType<MsalAuthenticationResult>;\n}>;\n\n/**\n * Attempts to authenticate user if not already authenticated, then renders child components\n * @param props\n */\nexport function MsalAuthenticationTemplate({ \n    interactionType, \n    username, \n    homeAccountId, \n    localAccountId,\n    authenticationRequest, \n    loadingComponent: LoadingComponent,\n    errorComponent: ErrorComponent,\n    children \n}: MsalAuthenticationProps): React.ReactElement|null {\n    const accountIdentifier: AccountIdentifiers = useMemo(() => {\n        return {\n            username,\n            homeAccountId,\n            localAccountId\n        };\n    }, [username, homeAccountId, localAccountId]);\n    const context = useMsal();\n    const msalAuthResult = useMsalAuthentication(interactionType, authenticationRequest, accountIdentifier);\n    const isAuthenticated = useIsAuthenticated(accountIdentifier);\n\n    if (msalAuthResult.error && context.inProgress === InteractionStatus.None) {\n        if (!!ErrorComponent) {\n            return <ErrorComponent {...msalAuthResult} />;\n        }\n\n        throw msalAuthResult.error;\n    }\n    \n    if (isAuthenticated) {\n        return (\n            <React.Fragment>\n                {getChildrenOrFunction(children, msalAuthResult)}\n            </React.Fragment>\n        );\n    } \n    \n    if (!!LoadingComponent && context.inProgress !== InteractionStatus.None) {\n        return <LoadingComponent {...context} />;\n    }\n\n    return null;\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport React from \"react\";\nimport { IMsalContext } from \"../MsalContext\";\nimport { useMsal } from \"../hooks/useMsal\";\nimport { Subtract } from \"../utils/utilities\";\n\nexport type WithMsalProps = {\n    msalContext: IMsalContext;\n};\n\n/**\n * Higher order component wraps provided component with msal by injecting msal context values into the component's props \n * @param Component \n */\nexport const withMsal = <P extends WithMsalProps>(Component: React.ComponentType<P>): React.FunctionComponent<Subtract<P,WithMsalProps>> => {\n    const ComponentWithMsal: React.FunctionComponent<Subtract<P,WithMsalProps>> = props => {\n        const msal = useMsal();\n        return <Component {...(props as P)} msalContext={msal} />;\n    };\n\n    const componentName =\n        Component.displayName || Component.name || \"Component\";\n    ComponentWithMsal.displayName = `withMsal(${componentName})`;\n\n    return ComponentWithMsal;\n};\n"]},"metadata":{},"sourceType":"module"}